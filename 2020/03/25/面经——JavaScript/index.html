<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"holichang.github.io","root":"/","scheme":"Muse","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1. 闭包无论通过何种手段将内部函数传递到所在的词法作用域以外，它持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包  思考：通过使用闭包，在作用域之外也可以调用函数，同时该函数还可以访问本身词法作用域中的变量  在定时器、事件监听器、AJAX请求、跨窗口通信、Web Workers或者任何其他的异步（或同步）任务中，只要使用了回调函数，实际上就是在使用闭包 1.1 循环和闭包IIFE">
<meta property="og:type" content="article">
<meta property="og:title" content="面经——JavaScript">
<meta property="og:url" content="https://holichang.github.io/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/index.html">
<meta property="og:site_name" content="Cheshire Cat">
<meta property="og:description" content="1. 闭包无论通过何种手段将内部函数传递到所在的词法作用域以外，它持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包  思考：通过使用闭包，在作用域之外也可以调用函数，同时该函数还可以访问本身词法作用域中的变量  在定时器、事件监听器、AJAX请求、跨窗口通信、Web Workers或者任何其他的异步（或同步）任务中，只要使用了回调函数，实际上就是在使用闭包 1.1 循环和闭包IIFE">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://holichang.github.io/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/D:%5CFront-End-Note%5Cimage%5C%E5%8E%9F%E5%9E%8B.png">
<meta property="og:image" content="https://holichang.github.io/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/D:%5CFront-End-Note%5Cimage%5C%E5%8E%9F%E5%9E%8B%E9%93%BE.png">
<meta property="og:image" content="https://holichang.github.io/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/D:%5CmyBlog%5Csource_posts%5C%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript%5C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.png">
<meta property="og:image" content="https://holichang.github.io/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/D:%5CmyBlog%5Csource_posts%5C%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript%5C%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%AE%8F%E4%BB%BB%E5%8A%A1.jpg">
<meta property="article:published_time" content="2020-03-25T13:30:05.000Z">
<meta property="article:modified_time" content="2020-04-01T13:47:59.141Z">
<meta property="article:author" content="柴郡猫">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://holichang.github.io/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/D:%5CFront-End-Note%5Cimage%5C%E5%8E%9F%E5%9E%8B.png">

<link rel="canonical" href="https://holichang.github.io/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>面经——JavaScript | Cheshire Cat</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Cheshire Cat</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://holichang.github.io/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="柴郡猫">
      <meta itemprop="description" content="向死而生的生命都在热烈地生长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cheshire Cat">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面经——JavaScript
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-25 21:30:05" itemprop="dateCreated datePublished" datetime="2020-03-25T21:30:05+08:00">2020-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-01 21:47:59" itemprop="dateModified" datetime="2020-04-01T21:47:59+08:00">2020-04-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="1-闭包"><a href="#1-闭包" class="headerlink" title="1. 闭包"></a>1. 闭包</h3><p><strong>无论通过何种手段将内部函数传递到所在的词法作用域以外，它持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包</strong></p>
<blockquote>
<p>思考：通过使用闭包，在作用域之外也可以调用函数，同时该函数还可以访问本身词法作用域中的变量</p>
</blockquote>
<p>在定时器、事件监听器、AJAX请求、跨窗口通信、Web Workers或者任何其他的异步（或同步）任务中，只要使用了<strong>回调函数</strong>，实际上就是在使用闭包</p>
<h5 id="1-1-循环和闭包"><a href="#1-1-循环和闭包" class="headerlink" title="1.1 循环和闭包"></a>1.1 循环和闭包</h5><p>IIFE：立即执行函数表达式，相当于将块转为了一个可以被关闭的作用域（var）</p>
<p>先看下面这个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;,<span class="number">1000</span>*i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//预期：分别输出数字1-5，每秒一次，每次一个</span></span><br><span class="line"><span class="comment">//该段代码会以每秒一次的频率输出五次6</span></span><br></pre></td></tr></table></figure>

<p>缺陷是我们试图假设循环中的每个迭代在运行时都会给自己捕获一个i的副本，但是根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被<strong>封闭在一个共享的全局作用域中，</strong>因此事实上只有一个i。</p>
<p>如何修改？</p>
<p><strong>方法一：使用IIFE</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(j)</span><br><span class="line">        &#125;,<span class="number">1000</span>*j)</span><br><span class="line">    &#125;(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：使用setTimeout第三个参数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;,i*<span class="number">1000</span>,i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//setTimeout的第三个参数为传给执行函数的其他参数（IE9 及其更早版本不支持该参数）。</span></span><br></pre></td></tr></table></figure>

<p><strong>方法三：使用let：块级作用域</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> j=i;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;,j*<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line">或：</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;=<span class="number">5</span>;i++)</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;,i*<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每次迭代都会创建一个i的副本</span></span><br></pre></td></tr></table></figure>

<h5 id="1-2-模块"><a href="#1-2-模块" class="headerlink" title="1.2 模块"></a>1.2 模块</h5><p>模块模式需要具备两个必要条件：</p>
<p>（1）必须有外部的封闭函数，该函数必须至少被调用一次，（<strong>每次调用都会创建一个新的模块实例？</strong>）</p>
<p>（2）封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态</p>
<p><strong>现代的模块机制：</strong></p>
<p>大多数模块依赖加载器/管理器本质上都是将这种模块定义封装进一个友好的API。这里并不会研究某个具体的库，为了宏观了解会简单介绍一些核心概念：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyModules=(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">module</span>=&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">define</span>(<span class="params">name,deps,impl</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;deps.length;i++)&#123;</span><br><span class="line">            deps[i]=<span class="built_in">module</span>[deps[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        modules[name]=impl.apply(impl,deps)</span><br><span class="line">        <span class="comment">//引入需要的依赖</span></span><br><span class="line">    &#125;<span class="comment">//该函数用于向管理中添加模块</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">module</span>[name];</span><br><span class="line">    &#125;<span class="comment">//通过名称获取模块</span></span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        define:define,</span><br><span class="line">        <span class="keyword">get</span>:<span class="keyword">get</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">//下面为使用方法：[]为新定义的模块需要引入的依赖模块列表</span><br><span class="line">MyModules.define("bar",[],function()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">who</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'let me introduce:'</span>+who;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        hello:hello</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">MyModules.define(<span class="string">"foo"</span>,[<span class="string">"bar"</span>],<span class="function"><span class="keyword">function</span>(<span class="params">bar</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hungry=<span class="string">"hippo"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">awesome</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(bar.hello(hungry).toUpperCase());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>&#123;</span><br><span class="line">        awesome:awesome</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> bar=MyModules.get(<span class="string">"bar"</span>);</span><br><span class="line"><span class="keyword">var</span> foo=MyModules.get(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	bar.hello(<span class="string">"hippo"</span>)</span><br><span class="line">);<span class="comment">//let me introduce: hippo</span></span><br><span class="line">foo.awesome();<span class="comment">//LET ME INTRODUCE:HIPPO</span></span><br></pre></td></tr></table></figure>

<p><strong>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包</strong></p>
<h3 id="2-对象"><a href="#2-对象" class="headerlink" title="2. 对象"></a>2. 对象</h3><h4 id="对象深度克隆的简单实现"><a href="#对象深度克隆的简单实现" class="headerlink" title="对象深度克隆的简单实现"></a>对象深度克隆的简单实现</h4><h4 id="js监听对象属性的改变"><a href="#js监听对象属性的改变" class="headerlink" title="js监听对象属性的改变"></a>js监听对象属性的改变</h4><h4 id="2-1-理解对象"><a href="#2-1-理解对象" class="headerlink" title="2.1 理解对象"></a>2.1 理解对象</h4><h5 id="2-1-1-属性类型"><a href="#2-1-1-属性类型" class="headerlink" title="2.1.1 属性类型"></a>2.1.1 属性类型</h5><p>ES5中有两种属性：数据属性和访问器属性</p>
<p><strong>数据属性</strong>：数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性：</p>
<p>[[Configurable]]:表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。</p>
<p>[[Enumerable]]：表示能否通过for-in循环返回属性。</p>
<p>[[Writable]]：表示能否修改属性的值。</p>
<p>[[Value]]：包含这个属性的值。</p>
<p><strong>要修改属性默认的特性：</strong>ES5的<strong>Object.defineProperty()</strong>方法（三个参数：属性所在的对象、属性的名字、描述符对象）使用如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">"name"</span>,&#123;</span><br><span class="line">    writable:<span class="literal">false</span>;</span><br><span class="line">    value:<span class="string">"Nicholas"</span>;</span><br><span class="line">&#125;)</span><br><span class="line">alert(person.name);<span class="comment">//"Nicholas"</span></span><br><span class="line">person.name=<span class="string">"Greg"</span>;</span><br><span class="line">alert(person.name);<span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>

<p>可以多次调用Object.defineProperty()方法修改同一个属性，但在把configurable特性设置为false之后就会有限制了。同时，<strong>在调用Object.defineProperty()方法创建一个新属性时，如果不指定，configurable，enumerable和writable特性的默认值都是false</strong>,如果调用Object.defineProperty()方法是修改已定义属性的特性，则无此限制。</p>
<p><strong>访问器属性</strong>（常用方法：设置一个属性的值会导致其他属性发生变化）</p>
<p>访问器属性不包含数据值，它包含一对getter函数和setter函数（不过这两个函数都不是必需的）。在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值，在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性：</p>
<p>[[Configurable]]:表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。</p>
<p>[[Enumerable]]：表示能否通过for-in循环返回属性。</p>
<p>[[Get]]：在读取属性时调用的函数。默认值为undefined。</p>
<p>[[Set]]：在写入属性时调用的函数。默认值为undefined。</p>
<p><strong>访问器属性不能直接定义，必须使用</strong>Object.defineProperty()来定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book=&#123;</span><br><span class="line">    _year:<span class="number">2004</span>,</span><br><span class="line">    edition:<span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book,<span class="string">"year"</span>,&#123;</span><br><span class="line">    <span class="keyword">get</span>:function()&#123;</span><br><span class="line">        <span class="keyword">return</span> book._year;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>:function(newValue)&#123;</span><br><span class="line">        <span class="keyword">if</span>(newValue&gt;<span class="number">2004</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>._year=newValue;</span><br><span class="line">            <span class="keyword">this</span>.edition=newValue<span class="number">-2004</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">book.year=<span class="number">2005</span>;</span><br><span class="line">alert(book.edition);<span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h5 id="2-1-2-定义多个属性"><a href="#2-1-2-定义多个属性" class="headerlink" title="2.1.2 定义多个属性"></a>2.1.2 定义多个属性</h5><p>Object.defineProperties()方法:可以一次性定义多个属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperties(book,&#123;</span><br><span class="line">    _year:&#123;</span><br><span class="line">        writable:<span class="literal">true</span>,</span><br><span class="line">        value:<span class="number">2004</span></span><br><span class="line">    &#125;,</span><br><span class="line">    edition:&#123;</span><br><span class="line">        writable:<span class="literal">true</span>;</span><br><span class="line">        value:<span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    year:&#123;</span><br><span class="line">        <span class="keyword">get</span>:function()&#123;</span><br><span class="line">            <span class="keyword">return</span> book._year;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>:function(newValue)&#123;</span><br><span class="line">            <span class="keyword">if</span>(newValue&gt;<span class="number">2004</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>._year=newValue;</span><br><span class="line">                <span class="keyword">this</span>.edition=newValue<span class="number">-2004</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="2-1-3-读取属性的特性"><a href="#2-1-3-读取属性的特性" class="headerlink" title="2.1.3 读取属性的特性"></a>2.1.3 读取属性的特性</h5><p><strong>Object.getOwnPropertyDescriptor()</strong>方法：取得给定属性的描述符。接收两个参数：属性所在的对象和要读取其描述符的属性名称，如：(接上段代码)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> descriptor=<span class="built_in">Object</span>.getOwnPropertyDescriptor(book,<span class="string">"_year"</span>);</span><br><span class="line">alert(descriptor.value);<span class="comment">//2004</span></span><br><span class="line">alert(descriptor.configurable);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p><strong>ES5的Object.getOwnPropertyDescriptor（）方法只能用于实例属性，要取得原型属性的描述符，必须直接在原型对象上调用该方法。</strong></p>
<p>在JavaScript 中，可以针对任何对象——包括 DOM 和BOM 对象，使用Object.getOwnProperty-Descriptor()方法。支持这个方法的浏览器有IE9+、Firefox 4+、Safari 5+、Opera 12+和Chrome。</p>
<h4 id="2-2创建对象"><a href="#2-2创建对象" class="headerlink" title="2.2创建对象"></a>2.2创建对象</h4><h5 id="2-2-1-工厂模式："><a href="#2-2-1-工厂模式：" class="headerlink" title="2.2.1 工厂模式："></a>2.2.1 工厂模式：</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> person=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">   person.name=name;</span><br><span class="line">   person.age=age;</span><br><span class="line">   person.job=job;</span><br><span class="line">   person.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'my name is'</span>+<span class="keyword">this</span>.name)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1=createPerson(<span class="string">"Nicholas"</span>,<span class="number">29</span>,<span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2=createPerson(<span class="string">"Greg"</span>,<span class="number">27</span>,<span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure>

<p>用函数来封装以特定接口创建对象的细节（虽然解决了创建多个相似对象的问题，但没有解决对象识别的问题,即怎么知道一个对象的类型）</p>
<h5 id="2-2-2-构造函数模式"><a href="#2-2-2-构造函数模式" class="headerlink" title="2.2.2 构造函数模式"></a>2.2.2 构造函数模式</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.job=job;</span><br><span class="line">    <span class="keyword">this</span>.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>,<span class="number">29</span>,<span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2=<span class="keyword">new</span> Person(<span class="string">"Greg"</span>,<span class="number">23</span>,<span class="string">"Doctor"</span>);</span><br><span class="line">alert(person1.constructor==Person);<span class="comment">//true</span></span><br><span class="line">alert(person1 <span class="keyword">instanceof</span> Person);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>构造函数模式和工厂模式的区别：</strong></p>
<p>（1）没有显式地创建一个新对象</p>
<p>（2）直接将属性和方法赋给了新对象</p>
<p>（3）没有return语句</p>
<p><strong>使用new操作符调用构造函数实际会经历以下步骤：</strong></p>
<p>（1）创建一个新对象</p>
<p>（2）这个新对象会被执行[[Prototype]]连接；</p>
<p>（3）将构造函数的作用域赋给新对象（因此this就指向了这个对象）</p>
<p>（4）执行构造函数中的代码（为这个新对象添加属性）</p>
<p>（5）返回新对象</p>
<p><strong>创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式胜过工厂模式的地方。</strong>在这个例子中，person1 和person2 之所以同时是Object 的实例，是因为所有对象均继承自Object</p>
<p><strong>构造函数模式存在的问题</strong>：每个方法都要在每个实例重新创建一遍</p>
<h5 id="2-2-3-原型模式"><a href="#2-2-3-原型模式" class="headerlink" title="2.2.3 原型模式"></a>2.2.3 原型模式</h5><blockquote>
<p>在所有实现中都无法访问[[prototype]]或<em>proto</em></p>
</blockquote>
<p><strong>构造函数，原型和实例的关系：</strong></p>
<p>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。</p>
<p><strong>（1）理解原型对象</strong>：prototype是通过调用构造函数而创建的那个对象实例的原型对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name=<span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age=<span class="number">29</span>;</span><br><span class="line">Person.prototype.job=<span class="string">"Software Engineer"</span>;</span><br><span class="line">Person.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName();<span class="comment">//"Nicholas"</span></span><br><span class="line"><span class="comment">//person1._proto_为Person.prototype</span></span><br></pre></td></tr></table></figure>

<p>在默认情况下，所有原型对象都会自动获得一个constructor(构造函数)属性，这个属性是一个指向prototype属性所在函数的指针。Person.prototype.constructor指向Person</p>
<p><img src="/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/D:%5CFront-End-Note%5Cimage%5C%E5%8E%9F%E5%9E%8B.png" alt="原型"></p>
<p>明确一点：<strong>这个连接存在于实例与构造函数的原型对象之间</strong>，而不是存在于实例与构造函数之间（即person1与Person.prototype之间的联系）person1内部有一个指向Person.prototype的指针（<code>[[prototype]]</code>或<code>_proto_</code>：虽然在所有实现中都无法访问到，但可以通过<code>isprototypeOf()</code>来确定是否是某实例的原型对象）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(Person.prototype.isPrototypeOf(person1));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>Object.getPrototypeOf():</strong>可以方便地获取一个对象的原型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">Object</span>.getPrototypeOf(person1)==Person.prototype);<span class="comment">//true</span></span><br><span class="line">alert(<span class="built_in">Object</span>.getPrototypeOf(person1).name);<span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>

<p>当代码要取得某个对象的某个属性时，会先从对象实例本身开始搜索，如果没有找到属性名，则继续搜索指针指向的原型对象。</p>
<p>当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性，也就是说，添加这个属性值会阻止我们访问原型中的那个属性，但不会修改那个属性;不过<strong>使用delete操作符可以完全删除实例属性</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">person1.name=<span class="string">"Greg"</span>;</span><br><span class="line">alert(person1.name);<span class="comment">//Greg</span></span><br><span class="line">alert(person1.hasOwnProperty(<span class="string">"name"</span>));<span class="comment">//true</span></span><br><span class="line"><span class="keyword">delete</span> person1.name;</span><br><span class="line">alert(person1.hasOwnProperty(<span class="string">"name"</span>));<span class="comment">//false</span></span><br><span class="line">alert(person1.name);<span class="comment">//Nicholas</span></span><br></pre></td></tr></table></figure>

<p><strong>hasOwnProperty()</strong>方法：检测一个属性是存在于实例中还是原型中</p>
<p><em>Object.getOwnPropertyDescriptor()方法只能用于实例属性，要取得原型属性的描述符，必须直接在原型对象上调用Object.getOwnPropertyDescriptor()方法</em></p>
<p><strong>（2）原型与in操作符</strong></p>
<p><strong>单独使用</strong>：in操作符只要通过对象能访问到属性就返回true,hasOwnProperty()只在属性存在于实例中时才返回true,因此当in操作符返回true，而hasOwnProperty()返回false时,就说明该属性存在于原型中</p>
<p><strong>for-in循环</strong>时：返回的是所有能够通过对象访问的，可枚举的属性，其中既包括存在于实例中的属性，也包括在原型中的属性。（<strong>屏蔽了原型中不可枚举属性（即将[[Enumerable]]标记为false属性）的实例属性也会在for-in循环中返回，因为根据规定，所有开发人员定义的属性都是可枚举的——只有在IE8及更早版本中例外</strong>）</p>
<p><strong>Object.keys()</strong>方法：接收一个对象作为参数，返回一个包含所有<strong>可枚举</strong>属性的<strong>字符串</strong>数组</p>
<p><strong>Object.getOwnPropertyNames():</strong>接收一个对象作为参数，返回一个包含<strong>所有实例属性</strong>的<strong>字符串</strong>数组</p>
<p><strong>（3）更简单的原型语法</strong>：用字面量法重写原型对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype=&#123;</span><br><span class="line">    <span class="keyword">constructor</span>:Person,</span><br><span class="line">    name:"Nicholas",</span><br><span class="line">    age:29,</span><br><span class="line">    job:"Software Engineer",</span><br><span class="line">    sayName:function()&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype,<span class="string">"constructor"</span>,&#123;</span><br><span class="line">    enumerable:<span class="literal">false</span>,</span><br><span class="line">    value:Person</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName();<span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>

<p>但此时，constructor属性不再指向Person函数，而是<strong>指向Object</strong>,但由于此时constructor属性为自定义的，<strong>可枚举</strong>，因此可以通过Object.defineProperty()将其[[Enumerable]]属性特性改为false。</p>
<p><strong>（4）原型的动态性</strong></p>
<p>重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系，他们引用的仍然是最初的原型。</p>
<p><strong>所以只能修改</strong></p>
<p><strong>（5）原生对象的原型</strong></p>
<p>可以修改如Array,Object,String等原生引用类型的原型，如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.startsWith=<span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.indexof(text)==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（6）原型对象的问题</strong></p>
<p><strong>原型对象中的引用类型值会被共享</strong></p>
<h5 id="2-2-4-组合使用构造函数模式和原型模式（最广泛、认同度最高）"><a href="#2-2-4-组合使用构造函数模式和原型模式（最广泛、认同度最高）" class="headerlink" title="2.2.4 组合使用构造函数模式和原型模式（最广泛、认同度最高）"></a>2.2.4 组合使用构造函数模式和原型模式（最广泛、认同度最高）</h5><p>构造函数用于定义实例属性，而原型模式用于定义方法和共享的属性。</p>
<h5 id="2-2-5-动态原型模式（可以把所有信息都封装在构造函数中）"><a href="#2-2-5-动态原型模式（可以把所有信息都封装在构造函数中）" class="headerlink" title="2.2.5 动态原型模式（可以把所有信息都封装在构造函数中）"></a>2.2.5 动态原型模式（可以把所有信息都封装在构造函数中）</h5><p>通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型，如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.job=job;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName!=<span class="string">"function"</span>)</span><br><span class="line">        <span class="comment">//此时sayName若是不存在或者不是函数类型，都会对原型初始化，而且检查一个属性或方法就可以</span></span><br><span class="line">    &#123;</span><br><span class="line">        Person.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-6-寄生（parasitic）构造函数模式（不建议使用）"><a href="#2-2-6-寄生（parasitic）构造函数模式（不建议使用）" class="headerlink" title="2.2.6 寄生（parasitic）构造函数模式（不建议使用）"></a>2.2.6 寄生（parasitic）构造函数模式（不建议使用）</h5><p>假如我们想创建一个具有额外方法的特殊数组，由于不能直接修改Array函数，因此可以使用这个模式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">values.push.apply(values,<span class="built_in">arguments</span>);<span class="comment">//arguments是个类数组对象，不能直接push到数组中</span></span><br></pre></td></tr></table></figure>

<p>构造函数在没有返回值的情况下，默认返回新对象实例，而该模式下的构造函数形式类似于工厂模式，在末尾有return语句，可以重写调用构造函数时返回的值，因此，<strong>返回的对象与构造函数以及构造函数的原型属性之间没有关系</strong>，也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。使用instanceof 没有意义。</p>
<h5 id="2-2-7-稳妥构造函数模式"><a href="#2-2-7-稳妥构造函数模式" class="headerlink" title="2.2.7 稳妥构造函数模式"></a>2.2.7 稳妥构造函数模式</h5><p>指的是没有公共属性，最适合在一些安全环境中使用，也与工厂模式很像</p>
<p>与寄生构造函数模式的区别：（1）不引用this对象（寄生模式在声明方法时使用）；（2）不使用new操作符</p>
<p>这种模式下创建的对象除了使用方法，没有其他办法访问属性值。</p>
<h4 id="2-3-继承"><a href="#2-3-继承" class="headerlink" title="2.3 继承"></a>2.3 继承</h4><p>ES只支持实现继承，而且主要依靠原型链</p>
<p>方法签名：</p>
<h5 id="2-3-1-原型链继承"><a href="#2-3-1-原型链继承" class="headerlink" title="2.3.1 原型链继承"></a>2.3.1 原型链继承</h5><p>基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法</p>
<p>实现本质是重写原型对象，代之以另一个新类型的实例</p>
<p><strong>（1）别忘记默认的原型</strong></p>
<p>所有函数的默认原型都是Object的实例</p>
<p><img src="/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/D:%5CFront-End-Note%5Cimage%5C%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="原型链"></p>
<p><strong>（2）确定原型和实例的关系</strong></p>
<p>instanceof操作符：+构造函数：只要用这个操作符测试实例与原型链中出现过的构造函数，就会返回true</p>
<p>isPrototypeOf()方法:只要是原型链中出现过的原型对象，都可以说是该原型链所派生的实例的原型</p>
<p><strong>（3）谨慎的定义方法</strong></p>
<p>给原型添加方法的代码一定要放在替换原型的语句之后，且不能使用字面量方法创建原型方法</p>
<p><strong>（4）原型链的问题</strong></p>
<p>第一个问题：包含引用类型值的原型属性会被所有实例共享</p>
<p>第二个问题：在创建子类型的实例时，不能向超类型的构造函数中传递参数</p>
<h5 id="2-3-2-借用构造函数（伪造对象或经典继承）"><a href="#2-3-2-借用构造函数（伪造对象或经典继承）" class="headerlink" title="2.3.2 借用构造函数（伪造对象或经典继承）"></a>2.3.2 借用构造函数（伪造对象或经典继承）</h5><p>基本思想：在子类型构造函数的内部调用超类型构造函数（使用call()方法或apply()方法）<strong>屏蔽掉超类型中的引用类型值</strong></p>
<p>好处：可以传递参数</p>
<p>问题：无法避免构造函数模式存在的问题——方法都在构造函数中定义，无法复用</p>
<h5 id="2-3-3-组合继承（JS中最常用的继承模式，也称伪经典继承）"><a href="#2-3-3-组合继承（JS中最常用的继承模式，也称伪经典继承）" class="headerlink" title="2.3.3 组合继承（JS中最常用的继承模式，也称伪经典继承）"></a>2.3.3 组合继承（JS中最常用的继承模式，也称伪经典继承）</h5><p>指的是将原型链和借用构造函数的技术组合到一起，使用原型链实现对原型属性和方法的继承，而使用借用构造函数来实现对实例属性的继承。</p>
<p>而且instanceof()和isPrototypeOf()也能够用于识别基于组合继承创建的对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.colors=[<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//继承属性</span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>,name);<span class="comment">//第二次调用构造函数，SubType实例中传入了第二组name和colors</span></span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承方法</span></span><br><span class="line">SubType.prototype=<span class="keyword">new</span> SuperType();<span class="comment">//第一次调用构造函数，SubType原型中传入了name和colors</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用寄生式组合继承方法：</span></span><br><span class="line"><span class="comment">function inheriPrototype(subType,superType)&#123;</span></span><br><span class="line"><span class="comment">    var prototype=object(superType.prototype);//创建对象：构建超类型原型的一个副本</span></span><br><span class="line"><span class="comment">    prototype.constructer=subType;//增强对象</span></span><br><span class="line"><span class="comment">    subType.prototype=prototype;//指定对象：将新创建的对象（即副本）赋值给子类型的原型</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">inheriPrototype(SubType,SuperType);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">SubType.prototype.constructor=SubType;</span><br><span class="line">SubType.prototype.sayAge=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 =<span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>,<span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"yellow"</span>);</span><br><span class="line">alert(instance1.colors);<span class="comment">//"red","green","blue","yellow"</span></span><br><span class="line">instance1.sayName();<span class="comment">//"Nicholas"</span></span><br><span class="line">instance1.sayAge();<span class="comment">//29</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 =<span class="keyword">new</span> SubType(<span class="string">"Greg"</span>,<span class="number">27</span>);</span><br><span class="line">alert(instance2.colors);<span class="comment">//"red","green","blue"</span></span><br><span class="line">instance2.sayName();<span class="comment">//"Greg"</span></span><br><span class="line">instance2.sayAge();<span class="comment">//27</span></span><br></pre></td></tr></table></figure>

<p><u>问题：会调用两次超类型构造函数</u></p>
<h5 id="2-3-4-原型式继承-ES5通过Object-create-方法规范化了原型式继承"><a href="#2-3-4-原型式继承-ES5通过Object-create-方法规范化了原型式继承" class="headerlink" title="2.3.4 原型式继承:ES5通过Object.create()方法规范化了原型式继承"></a>2.3.4 原型式继承:ES5通过Object.create()方法规范化了原型式继承</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype=o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;<span class="comment">//相当于利用一个构造函数做桥接，</span></span><br></pre></td></tr></table></figure>

<p>思想是基于对象o，创建一个实例，该实例的原型对象o,在包含引用类型属性值方面该方法与原型模式是一样的</p>
<p>ES5新增了Object.create()方法：接受两个参数：一个是用作新对象原型的对象和（可选的）一个新对象定义额外的对象，该对象中每个属性都是通过自己的描述符定义的.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">     name:<span class="string">'Nicholas'</span>,</span><br><span class="line">     friends:[<span class="string">'Shelby'</span>,<span class="string">'Court'</span>,;Van]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1=<span class="built_in">Object</span>.create(person,&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        value:<span class="string">'Greg'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(person1.name);<span class="comment">//'Greg'</span></span><br></pre></td></tr></table></figure>

<p>支持Object.create()方法的浏览器有IE9+、Firefox 4+、Safari 5+、Opera 12+ 和Chrome。<strong>在没有必要兴师动众地创建构造函数</strong>，而只想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的。不过别忘了，包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。</p>
<h5 id="2-3-5-寄生式继承"><a href="#2-3-5-寄生式继承" class="headerlink" title="2.3.5 寄生式继承"></a>2.3.5 寄生式继承</h5><p>思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象（即在内部通过构造函数创建一个实例，再为该对象增加方法，最后返回该对象）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone=<span class="built_in">Object</span>.create(o);</span><br><span class="line">    clone.sayHi=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"Hi!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">    name:<span class="string">'Nichlas'</span>,</span><br><span class="line">    friends:[<span class="string">'Tom'</span>,<span class="string">'Bob'</span>,<span class="string">'Greg'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> another=createAnother(person);</span><br><span class="line">another.sayHi();<span class="comment">//'Hi!'</span></span><br></pre></td></tr></table></figure>

<p>在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示范继承模式时使用的Object.create()函数不是必需的；任何能够返回新对象的函数都适用于此模式。</p>
<h5 id="2-3-6-寄生组合式继承（最理想）"><a href="#2-3-6-寄生组合式继承（最理想）" class="headerlink" title="2.3.6 寄生组合式继承（最理想）"></a>2.3.6 寄生组合式继承（最理想）</h5><p>用于解决组合继承两次调用构造函数的问题，方法见上方代码，该方法只调用一次SuperType构造函数,且原型链保持不变。</p>
<p><strong>基本思路：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的不过是超类型原型的一个副本而已，方法同原型式继承</strong></p>
<h3 id="3-混合对象“类”"><a href="#3-混合对象“类”" class="headerlink" title="3. 混合对象“类”"></a>3. 混合对象“类”</h3><h3 id="4-原型"><a href="#4-原型" class="headerlink" title="4. 原型"></a>4. 原型</h3><h3 id="5-异步"><a href="#5-异步" class="headerlink" title="5. 异步"></a>5. 异步</h3><h4 id="5-1-浏览器的进程与线程："><a href="#5-1-浏览器的进程与线程：" class="headerlink" title="5.1 浏览器的进程与线程："></a>5.1 浏览器的进程与线程：</h4><p><strong>5.1.1 进程：</strong></p>
<p>进程是cpu的资源分配的最小单位。</p>
<p><strong>多进程</strong>：多进程指的是在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如你可以听歌的同时，打开编辑器敲代码，编辑器和听歌软件的进程之间丝毫不会相互干扰。</p>
<p><strong>浏览器是多进程的，浏览器的进程主要包括以下几种：</strong></p>
<ol>
<li>Browser进程：浏览器的主进程（负责协调，主控）</li>
<li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</li>
<li>GPU进程：最多一个，用于3D绘制</li>
<li><strong>浏览器渲染进程（内核）</strong>：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）</li>
</ol>
<p>在浏览网页时，同时打开几个新的页面， 这就要打开几个浏览窗口，但一旦开启十几个窗口，整个计算机就会越来越慢。</p>
<p><strong>多进程浏览器的优点</strong></p>
<ul>
<li><p>避免页面渲染影响整个浏览器</p>
</li>
<li><p>避免第三方插件影响整个浏览器</p>
</li>
<li><p>多进程充分利用多核优势</p>
</li>
<li><p>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性</p>
<blockquote>
<p><strong>沙盒模型：</strong></p>
</blockquote>
</li>
</ul>
<p>通俗的讲，就是用户打开多个窗口，如果其中一个窗口崩掉了，也不会影响整个浏览器，其他的界面照样正常运行</p>
<p><strong>5.1.2 线程：</strong></p>
<p>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；</p>
<p>进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)。</p>
<p><strong>浏览器的渲染进程（浏览器内核）是多线程的，主要为以下几大类：</strong></p>
<ol>
<li><p><strong>GUI线程</strong></p>
<p>负责渲染浏览器界面HTML元素,当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时,该线程就会执行。在Javascript引擎运行脚本期间,GUI渲染线程都是处于挂起状态的,也就是说被”冻结”了.</p>
</li>
<li><p><strong>Javascript引擎线程</strong></p>
<p>也可以称为JS内核，主要负责处理Javascript脚本程序，例如V8引擎。Javascript引擎线程理所当然是负责解析Javascript脚本，运行代码。</p>
<p><strong>Javascript是单线程的</strong></p>
<p>这是因为Javascript这门脚本语言诞生的使命所致：JavaScript为处理页面中用户的交互，以及操作DOM树、CSS样式树来给用户呈现一份动态而丰富的交互体验和服务器逻辑的交互处理。如果JavaScript是多线程的方式来操作这些UI DOM，则可能出现UI操作的冲突； 如果Javascript是多线程的话，在多线程的交互下，处于UI中的DOM节点就可能成为一个临界资源，假设存在两个线程同时操作一个DOM，一个负责修改一个负责删除，那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果。当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性，Javascript在最初就选择了单线程执行。</p>
<p><strong>GUI 渲染线程 与 JavaScript引擎线程互斥！</strong></p>
<p>由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JavaScript线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JavaScript引擎为互斥的关系，当JavaScript引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到引擎线程空闲时立即被执行。</p>
<p><strong>JS阻塞页面加载</strong></p>
<p>由于GUI渲染线程与JavaScript执行线程是互斥的关系，当浏览器在执行JavaScript程序的时候，GUI渲染线程会被保存在一个队列中，直到JS程序执行完成，才会接着执行。因此如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p>
</li>
<li><p><strong>事件触发线程</strong></p>
<p>当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。</p>
</li>
<li><p><strong>定时器线程</strong></p>
<p>浏览器定时计数器并不是由JavaScript引擎计数的, 因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。</p>
</li>
<li><p><strong>网络请求线程</strong></p>
<p>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript引擎的处理队列中等</p>
<p>待处理。</p>
</li>
</ol>
<h4 id="5-2-EventLoop：事件循环"><a href="#5-2-EventLoop：事件循环" class="headerlink" title="5.2 EventLoop：事件循环"></a>5.2 EventLoop：事件循环</h4><p><strong>在ES6之前：</strong>所有JS的执行环境都有事件循环的内置机制，它随着时间的推移每次都调用JS引擎处理程序中多个代码块的执行。也就是说，是JS周围的环境来调度这些事情的。</p>
<p><img src="/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/D:%5CmyBlog%5Csource_posts%5C%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript%5C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.png" alt="事件循环"></p>
<p>事件循环有一个简单的任务 —— 去监控执行栈和任务队列。如果执行栈是空的，它就会取出任务队列中的第一个事件，然后将它压入到任务中，然后运行它。</p>
<p>这样的迭代在事件循环中被称作一个 <strong>tick</strong>。每一个事件就是一个回调函数。</p>
<p><strong>5.2.1 执行栈和任务队列</strong></p>
<p>所有的任务可以分为同步任务和异步任务，同步任务，顾名思义，就是立即执行的任务，同步任务一般会直接进入到主线程中执行；而异步任务，就是异步执行的任务，比如ajax网络请求，setTimeout 定时函数等都属于异步任务，异步任务会通过任务队列( Event Queue )的机制来进行协调。</p>
<p>同步和异步任务分别进入不同的执行环境，同步的进入主线程，即主执行栈，异步的进入 Event Queue 。主线程内的任务执行完毕为空，会去 Event Queue 读取对应的任务，推入主线程执行。 上述过程的不断重复就是我们说的 Event Loop (事件循环)。</p>
<p>在事件循环中，每进行一次循环操作称为tick，通过阅读规范可知，每一次 tick 的任务处理模型是比较复杂的，其关键的步骤可以总结如下：</p>
<ol>
<li>在此次 tick 中选择最先进入队列的任务( oldest task )，如果有则执行(一次)</li>
<li>检查是否存在 Microtasks ，如果存在则不停地执行，直至清空Microtask Queue</li>
<li>更新 render</li>
<li>主线程重复执行上述步骤</li>
</ol>
<p>可以用一张图来说明下流程：</p>
<p><img src="/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/D:%5CmyBlog%5Csource_posts%5C%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript%5C%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%AE%8F%E4%BB%BB%E5%8A%A1.jpg" alt="微任务与宏任务"></p>
<p>规范中规定，task分为两大类, 分别是 Macro Task （宏任务）和 Micro Task（微任务）, 并且每个宏任务结束后, 都要清空所有的微任务,这里的 Macro Task也是我们常说的 task ，有些文章并没有对其做区分，后面文章中所提及的task皆看做宏任务( macro task)。</p>
<p>(macro)task 主要包含：script( 整体代码)、setTimeout、setInterval、I/O、UI 交互事件、setImmediate(Node.js 环境)</p>
<p>microtask主要包含：Promise、MutaionObserver、process.nextTick(Node.js 环境)</p>
<p>setTimeout/Promise 等API便是任务源，而进入任务队列的是由他们指定的具体执行任务。来自不同任务源的任务会进入到不同的任务队列。其中 setTimeout 与 setInterval 是同源的。</p>
<h3 id="6-回调"><a href="#6-回调" class="headerlink" title="6. 回调"></a>6. 回调</h3><p><strong>多层回调会导致回掉地狱，那么如何解决这种问题呢？</strong></p>
<p>（1）promise</p>
<p>（2）generater</p>
<p>（3）async/await</p>
<h4 id="6-1-Promise"><a href="#6-1-Promise" class="headerlink" title="6.1 Promise:"></a>6.1 Promise:</h4><p><strong>6.1.1 Promise的含义</strong></p>
<p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<p><strong><code>Promise</code>对象有以下两个特点。</strong></p>
<p>（1）<strong>对象的状态不受外界影响：</strong><code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>
<p>（2）<strong>一旦状态改变，就不会再变，任何时候都可以得到这个结果：</strong><code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>
<p><strong>6.1.1 Promise基本用法</strong></p>
<p>以Ajax异步请求为例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getJson=<span class="function"><span class="keyword">function</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> promise=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> handler=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.readyState!=<span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status===<span class="number">200</span>)&#123;</span><br><span class="line">                resolve(<span class="keyword">this</span>.response);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">const</span> client=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        client.open(<span class="string">"GET"</span>,url);</span><br><span class="line">        client.onreadystatechange=handler;</span><br><span class="line">        client.responseType=<span class="string">"json"</span>;</span><br><span class="line">        client.setRequestHeader(<span class="string">"Accept"</span>,<span class="string">"application/json"</span>);</span><br><span class="line">        client.send();</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line">getJson(<span class="string">"./posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Contents:'</span>+result);<span class="comment">//result为resolve()函数的参数，此处为返回的repsonse</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'出错率！'</span>+err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>6.1.2 Promise.prototype.then()</strong></p>
<p>它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，<code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数（可选）是<code>rejected</code>状态的回调函数。</p>
<p>可以采用链式写法：then方法后面再调用另一个then方法</p>
<p><strong>6.1.3  Promise.prototype.catch()</strong></p>
<p><code>Promise.prototype.catch</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。</p>
<p><strong>Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。</strong></p>
<p><strong>6.1.4 Promise.prototype.finally</strong></p>
<p><code>finally</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p>
<p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p>
<h4 id="6-1-5-Promise-all"><a href="#6-1-5-Promise-all" class="headerlink" title="6.1.5 Promise.all()"></a>6.1.5 Promise.all()</h4><p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p=<span class="built_in">Promise</span>.all([p1,p2,p3]);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Promise.all()</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例，如果不是，就会先调用下面讲到的<strong><code>Promise.resolve</code></strong>方法，将参数转为 Promise 实例，再进一步处理。另外，<code>Promise.all()</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</p>
<p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p>
<p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p>
<p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p>
<p><strong>6.1.6 Promise.race()</strong></p>
<p>Promise.race()方法同样是将多个Promise实例，包装成一个新的Promise实例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p>
<p><strong>6.1.7 Promise.allsettled()</strong></p>
<p><code>Promise.allSettled()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束。该方法由 <a href="https://github.com/tc39/proposal-promise-allSettled" target="_blank" rel="noopener">ES2020</a> 引入。</p>
<p><strong>6.1.8 Promise.any()</strong></p>
<p><code>Promise.any()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。该方法目前是一个第三阶段的<a href="https://github.com/tc39/proposal-promise-any" target="_blank" rel="noopener">提案</a> 。</p>
<p><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是不会因为某个 Promise 变成<code>rejected</code>状态而结束</p>
<h4 id="6-2-Generator-生成器"><a href="#6-2-Generator-生成器" class="headerlink" title="6.2 Generator:生成器"></a>6.2 Generator:生成器</h4><h4 id="6-3-async-await"><a href="#6-3-async-await" class="headerlink" title="6.3 async/await"></a>6.3 async/await</h4><h3 id="8-前端中的事件流"><a href="#8-前端中的事件流" class="headerlink" title="8. 前端中的事件流"></a>8. 前端中的事件流</h3><p>事件循环：</p>
<p>浏览器渲染进程包括多个线程，如JS引擎线程，GUI渲染现场，定时器线程，事件触发线程，网络请求线程，JS是单线程的，避免同时对同一DOM进行不同操作，JS引擎线程与GUI渲染线程是互斥的</p>
<p>任务分为同步任务和异步任务，同步任务即即刻执行的任务，异步任务即一段时间后执行，如setTimeout定时器参数中的回调函数即为异步任务，时间到后将该回掉函数放入任务队列，等待JS执行。</p>
<p>主线程执行栈为空后，将任务队列按照先入先出的顺序压入执行栈，每次循环是一个tick，分为宏任务和微任务，宏任务比如script整体内容，setTimeout,setInterval,UI交互事件，微任务比如promise，先执行宏任务，执行结束后如果有微任务执行微任务</p>
<h3 id="9-图片的预加载和懒加载"><a href="#9-图片的预加载和懒加载" class="headerlink" title="9. 图片的预加载和懒加载"></a>9. 图片的预加载和懒加载</h3><h4 id="9-2-JS的各种位置，比如clientHeight-scrollHeight-offsetHeight-以及scrollTop-offsetTop-clientTop的区别"><a href="#9-2-JS的各种位置，比如clientHeight-scrollHeight-offsetHeight-以及scrollTop-offsetTop-clientTop的区别" class="headerlink" title="9.2 JS的各种位置，比如clientHeight,scrollHeight,offsetHeight,以及scrollTop,offsetTop,clientTop的区别"></a>9.2 JS的各种位置，比如clientHeight,scrollHeight,offsetHeight,以及scrollTop,offsetTop,clientTop的区别</h4><h3 id="10-事件"><a href="#10-事件" class="headerlink" title="10. 事件"></a>10. 事件</h3><h4 id="10-1-冒泡"><a href="#10-1-冒泡" class="headerlink" title="10.1 冒泡"></a>10.1 冒泡</h4><h4 id="10-2-捕获"><a href="#10-2-捕获" class="headerlink" title="10.2 捕获"></a>10.2 捕获</h4><h4 id="10-3-如何让事件先冒泡后捕获？"><a href="#10-3-如何让事件先冒泡后捕获？" class="headerlink" title="10.3 如何让事件先冒泡后捕获？"></a>10.3 如何让事件先冒泡后捕获？</h4><h4 id="10-4-事件委托"><a href="#10-4-事件委托" class="headerlink" title="10.4 事件委托"></a>10.4 事件委托</h4><h4 id="10-5-mouseover-和mouseenter的区别"><a href="#10-5-mouseover-和mouseenter的区别" class="headerlink" title="10.5 mouseover 和mouseenter的区别"></a>10.5 mouseover 和mouseenter的区别</h4><h3 id="11-this"><a href="#11-this" class="headerlink" title="11. this"></a>11. this</h3><h4 id="11-1-new操作符做了哪些事情"><a href="#11-1-new操作符做了哪些事情" class="headerlink" title="11.1 new操作符做了哪些事情"></a>11.1 new操作符做了哪些事情</h4><p>（1）创建一个新对象</p>
<p>（2）执行[[prototype]]连接</p>
<p>（3）将该对象绑定到构造函数中的this</p>
<p>（4）如果没有return返回值，则返回该对象</p>
<h4 id="11-2-改变函数内部this指针的指向函数（bind-apply-call的区别）"><a href="#11-2-改变函数内部this指针的指向函数（bind-apply-call的区别）" class="headerlink" title="11.2 改变函数内部this指针的指向函数（bind,apply,call的区别）"></a>11.2 改变函数内部this指针的指向函数（bind,apply,call的区别）</h4><h3 id="12-JS拖拽功能的实现"><a href="#12-JS拖拽功能的实现" class="headerlink" title="12. JS拖拽功能的实现"></a>12. JS拖拽功能的实现</h3><h3 id="13-JS的节流和防抖"><a href="#13-JS的节流和防抖" class="headerlink" title="13. JS的节流和防抖"></a>13. JS的节流和防抖</h3><h3 id="14-JS的垃圾回收机制"><a href="#14-JS的垃圾回收机制" class="headerlink" title="14. JS的垃圾回收机制"></a>14. JS的垃圾回收机制</h3><h3 id="15-AJAX解决浏览器缓存问题"><a href="#15-AJAX解决浏览器缓存问题" class="headerlink" title="15. AJAX解决浏览器缓存问题"></a>15. AJAX解决浏览器缓存问题</h3><h3 id="16-eval是做什么的-（欺骗词法）"><a href="#16-eval是做什么的-（欺骗词法）" class="headerlink" title="16. eval是做什么的?（欺骗词法）"></a>16. eval是做什么的?（欺骗词法）</h3><p><strong>eval(str)：</strong>它的功能是将对应的字符串解析成js并执行，可以在运行期修改书写期的词法作用域:</p>
<p><strong>with(obj）：</strong>with可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符</p>
<p><strong>eval()函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而with()声明实际上是根据你传给它的对象凭空创建了一个新的词法作用域</strong></p>
<p><strong>为什么不推荐使用eval()和with()?</strong></p>
<p>(1)欺骗词法会导致性能下降</p>
<p>(2)会被严格模式所限制，with被完全禁止，而在保留核心功能的前提下，间接或非安全地使用eval()也被禁止了</p>
<p><strong>为什么会导致性能下降？</strong></p>
<p>JS引擎会在编译阶段进行数项的性能优化，其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。但如果引擎在代码中发现了eval()和with()，在悲观情况下可能会做不到任何优化。</p>
<p><strong>引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的</strong></p>
<h3 id="17-如何理解前端模块化？"><a href="#17-如何理解前端模块化？" class="headerlink" title="17. 如何理解前端模块化？"></a>17. 如何理解前端模块化？</h3><h4 id="17-1-说一下Commonjs-AMD-CMD"><a href="#17-1-说一下Commonjs-AMD-CMD" class="headerlink" title="17.1 说一下Commonjs,AMD,CMD"></a>17.1 说一下Commonjs,AMD,CMD</h4><h3 id="18-实现一个once函数，传入函数参数只执行一次"><a href="#18-实现一个once函数，传入函数参数只执行一次" class="headerlink" title="18. 实现一个once函数，传入函数参数只执行一次"></a>18. 实现一个once函数，传入函数参数只执行一次</h3><h3 id="19-Promise"><a href="#19-Promise" class="headerlink" title="19. Promise"></a>19. Promise</h3><h4 id="将原声的ajax封装成promise"><a href="#将原声的ajax封装成promise" class="headerlink" title="将原声的ajax封装成promise"></a>将原声的ajax封装成promise</h4><h3 id="20-如何实现一个私有变量，用getName方法可以访问，不能直接访问"><a href="#20-如何实现一个私有变量，用getName方法可以访问，不能直接访问" class="headerlink" title="20. 如何实现一个私有变量，用getName方法可以访问，不能直接访问"></a>20. 如何实现一个私有变量，用getName方法可以访问，不能直接访问</h3><h3 id="21-重排和重绘"><a href="#21-重排和重绘" class="headerlink" title="21. 重排和重绘"></a>21. 重排和重绘</h3><p>重排（重构/回流/reflow）：当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建, 这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。</p>
<p>重绘（repaint或redraw）：当盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器便把这些元素都按照各自的特性绘制一遍，将内容呈现在页面上。重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。</p>
<p>触发重绘的条件：改变元素外观属性。如：color，background-color等。</p>
<p>注意：table及其内部元素可能需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花两倍时间，这就是我们尽量避免使用table布局页面的原因之一。</p>
<p>重绘和重排的关系：在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。所以，<strong>重排必定会引发重绘，但重绘不一定会引发重排。</strong></p>
<h3 id="22-const、let、var"><a href="#22-const、let、var" class="headerlink" title="22. const、let、var"></a>22. const、let、var</h3><h4 id="22-1-let-和-var-的区别："><a href="#22-1-let-和-var-的区别：" class="headerlink" title="22.1 let 和 var 的区别："></a>22.1 let 和 var 的区别：</h4><p>（1）let有块作用域，所声明的变量只在let命令所在的代码块内有效（for循环：<em>JavaScript引擎内部可以记住上一次循环的值</em>）</p>
<p>（2）let不存在变量提升：let:报错ReferenceError  var:输出undefined</p>
<p>（3）let暂时性死区：ES6 明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。“暂时性死区”也意味着<code>typeof</code>不再是一个百分之百安全的操作。</p>
<p>（4）let不允许在相同作用域内重复声明同一个变量</p>
<h4 id="22-2-为什么需要块级作用域？"><a href="#22-2-为什么需要块级作用域？" class="headerlink" title="22.2 为什么需要块级作用域？"></a>22.2 为什么需要块级作用域？</h4><p><strong>场景一：</strong>内层变量可能会覆盖外层变量；</p>
<p><strong>场景二：</strong>用来计数的循环变量泄露为全局变量</p>
<h4 id="22-3-const命令"><a href="#22-3-const命令" class="headerlink" title="22.3 const命令"></a>22.3 const命令</h4><p>（1）<code>const</code>声明的变量不得改变值，这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>
<p>（2）<code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效</p>
<p>（3）const命令声明的常量也不提升，也存在暂时性死区</p>
<p>（4）const声明的常量同样不可以重复声明</p>
<p><code>const</code>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于将对象声明为常量，该常量所存储的地址不能变，但对象本身可以变。可以用Object.freeze()方法将对象冻结</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/25/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/" rel="prev" title="微信小程序开发">
      <i class="fa fa-chevron-left"></i> 微信小程序开发
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-闭包"><span class="nav-text">1. 闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-循环和闭包"><span class="nav-text">1.1 循环和闭包</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-模块"><span class="nav-text">1.2 模块</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-对象"><span class="nav-text">2. 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对象深度克隆的简单实现"><span class="nav-text">对象深度克隆的简单实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#js监听对象属性的改变"><span class="nav-text">js监听对象属性的改变</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-理解对象"><span class="nav-text">2.1 理解对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-1-属性类型"><span class="nav-text">2.1.1 属性类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-2-定义多个属性"><span class="nav-text">2.1.2 定义多个属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-3-读取属性的特性"><span class="nav-text">2.1.3 读取属性的特性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2创建对象"><span class="nav-text">2.2创建对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-1-工厂模式："><span class="nav-text">2.2.1 工厂模式：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-2-构造函数模式"><span class="nav-text">2.2.2 构造函数模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-3-原型模式"><span class="nav-text">2.2.3 原型模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-4-组合使用构造函数模式和原型模式（最广泛、认同度最高）"><span class="nav-text">2.2.4 组合使用构造函数模式和原型模式（最广泛、认同度最高）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-5-动态原型模式（可以把所有信息都封装在构造函数中）"><span class="nav-text">2.2.5 动态原型模式（可以把所有信息都封装在构造函数中）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-6-寄生（parasitic）构造函数模式（不建议使用）"><span class="nav-text">2.2.6 寄生（parasitic）构造函数模式（不建议使用）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-7-稳妥构造函数模式"><span class="nav-text">2.2.7 稳妥构造函数模式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-继承"><span class="nav-text">2.3 继承</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-1-原型链继承"><span class="nav-text">2.3.1 原型链继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-2-借用构造函数（伪造对象或经典继承）"><span class="nav-text">2.3.2 借用构造函数（伪造对象或经典继承）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-3-组合继承（JS中最常用的继承模式，也称伪经典继承）"><span class="nav-text">2.3.3 组合继承（JS中最常用的继承模式，也称伪经典继承）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-4-原型式继承-ES5通过Object-create-方法规范化了原型式继承"><span class="nav-text">2.3.4 原型式继承:ES5通过Object.create()方法规范化了原型式继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-5-寄生式继承"><span class="nav-text">2.3.5 寄生式继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-6-寄生组合式继承（最理想）"><span class="nav-text">2.3.6 寄生组合式继承（最理想）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-混合对象“类”"><span class="nav-text">3. 混合对象“类”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-原型"><span class="nav-text">4. 原型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-异步"><span class="nav-text">5. 异步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-浏览器的进程与线程："><span class="nav-text">5.1 浏览器的进程与线程：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-EventLoop：事件循环"><span class="nav-text">5.2 EventLoop：事件循环</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-回调"><span class="nav-text">6. 回调</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-Promise"><span class="nav-text">6.1 Promise:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-5-Promise-all"><span class="nav-text">6.1.5 Promise.all()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-Generator-生成器"><span class="nav-text">6.2 Generator:生成器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-async-await"><span class="nav-text">6.3 async&#x2F;await</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-前端中的事件流"><span class="nav-text">8. 前端中的事件流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-图片的预加载和懒加载"><span class="nav-text">9. 图片的预加载和懒加载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-JS的各种位置，比如clientHeight-scrollHeight-offsetHeight-以及scrollTop-offsetTop-clientTop的区别"><span class="nav-text">9.2 JS的各种位置，比如clientHeight,scrollHeight,offsetHeight,以及scrollTop,offsetTop,clientTop的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-事件"><span class="nav-text">10. 事件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-1-冒泡"><span class="nav-text">10.1 冒泡</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-2-捕获"><span class="nav-text">10.2 捕获</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-3-如何让事件先冒泡后捕获？"><span class="nav-text">10.3 如何让事件先冒泡后捕获？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-4-事件委托"><span class="nav-text">10.4 事件委托</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-5-mouseover-和mouseenter的区别"><span class="nav-text">10.5 mouseover 和mouseenter的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-this"><span class="nav-text">11. this</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-1-new操作符做了哪些事情"><span class="nav-text">11.1 new操作符做了哪些事情</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-2-改变函数内部this指针的指向函数（bind-apply-call的区别）"><span class="nav-text">11.2 改变函数内部this指针的指向函数（bind,apply,call的区别）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-JS拖拽功能的实现"><span class="nav-text">12. JS拖拽功能的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-JS的节流和防抖"><span class="nav-text">13. JS的节流和防抖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-JS的垃圾回收机制"><span class="nav-text">14. JS的垃圾回收机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-AJAX解决浏览器缓存问题"><span class="nav-text">15. AJAX解决浏览器缓存问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-eval是做什么的-（欺骗词法）"><span class="nav-text">16. eval是做什么的?（欺骗词法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-如何理解前端模块化？"><span class="nav-text">17. 如何理解前端模块化？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#17-1-说一下Commonjs-AMD-CMD"><span class="nav-text">17.1 说一下Commonjs,AMD,CMD</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-实现一个once函数，传入函数参数只执行一次"><span class="nav-text">18. 实现一个once函数，传入函数参数只执行一次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-Promise"><span class="nav-text">19. Promise</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#将原声的ajax封装成promise"><span class="nav-text">将原声的ajax封装成promise</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-如何实现一个私有变量，用getName方法可以访问，不能直接访问"><span class="nav-text">20. 如何实现一个私有变量，用getName方法可以访问，不能直接访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-重排和重绘"><span class="nav-text">21. 重排和重绘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-const、let、var"><span class="nav-text">22. const、let、var</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#22-1-let-和-var-的区别："><span class="nav-text">22.1 let 和 var 的区别：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22-2-为什么需要块级作用域？"><span class="nav-text">22.2 为什么需要块级作用域？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22-3-const命令"><span class="nav-text">22.3 const命令</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="柴郡猫"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">柴郡猫</p>
  <div class="site-description" itemprop="description">向死而生的生命都在热烈地生长</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/holichang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;holichang" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1185381333@qq.com" title="E-Mail → mailto:1185381333@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">柴郡猫</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
