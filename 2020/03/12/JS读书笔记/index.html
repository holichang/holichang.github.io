<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"holichang.github.io","root":"/","scheme":"Muse","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="[TOC] 1.JavaScript简介1.1 ECMA-262：ECMAScript脚本语言标准，与Web浏览器没有依赖关系，常见的Web浏览器只是JavaScript可能实现的宿主环境之一，宿主环境不仅提供基本的ECMAScript实现，同时也会提供该语言的扩展，以便语言与宿主环境之间交互。而这些扩展——如DOM，则利用ECMAScript的核心类型和语法提供更多更具体的功能，以便实现针对环境">
<meta property="og:type" content="article">
<meta property="og:title" content="JS读书笔记">
<meta property="og:url" content="https://holichang.github.io/2020/03/12/JS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Cheshire Cat">
<meta property="og:description" content="[TOC] 1.JavaScript简介1.1 ECMA-262：ECMAScript脚本语言标准，与Web浏览器没有依赖关系，常见的Web浏览器只是JavaScript可能实现的宿主环境之一，宿主环境不仅提供基本的ECMAScript实现，同时也会提供该语言的扩展，以便语言与宿主环境之间交互。而这些扩展——如DOM，则利用ECMAScript的核心类型和语法提供更多更具体的功能，以便实现针对环境">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-03-12T12:38:55.000Z">
<meta property="article:modified_time" content="2020-03-12T12:41:24.089Z">
<meta property="article:author" content="柴郡猫">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://holichang.github.io/2020/03/12/JS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>JS读书笔记 | Cheshire Cat</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Cheshire Cat</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://holichang.github.io/2020/03/12/JS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="柴郡猫">
      <meta itemprop="description" content="向死而生的生命都在热烈地生长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cheshire Cat">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JS读书笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-12 20:38:55 / 修改时间：20:41:24" itemprop="dateCreated datePublished" datetime="2020-03-12T20:38:55+08:00">2020-03-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>[TOC]</p>
<h2 id="1-JavaScript简介"><a href="#1-JavaScript简介" class="headerlink" title="1.JavaScript简介"></a>1.JavaScript简介</h2><h4 id="1-1-ECMA-262："><a href="#1-1-ECMA-262：" class="headerlink" title="1.1 ECMA-262："></a>1.1 ECMA-262：</h4><p>ECMAScript脚本语言标准，与Web浏览器没有依赖关系，常见的Web浏览器只是JavaScript可能实现的宿主环境之一，宿主环境不仅提供基本的ECMAScript实现，同时也会提供该语言的扩展，以便语言与宿主环境之间交互。而这些扩展——如DOM，则利用ECMAScript的核心类型和语法提供更多更具体的功能，以便实现针对环境的操作。其他宿主环境包括Node和Adobe Flash.</p>
<h4 id="1-2-一个完整的JavaScript实现应该由下列三个不同的部分组成："><a href="#1-2-一个完整的JavaScript实现应该由下列三个不同的部分组成：" class="headerlink" title="1.2 一个完整的JavaScript实现应该由下列三个不同的部分组成："></a>1.2 一个完整的JavaScript实现应该由下列三个不同的部分组成：</h4><p>（1）核心（ECMAScript）：由ECMA-262定义，提供核心语言功能</p>
<p>（2）文档对象模型(DOM)：提供访问和操作网页内容的方法和接口，DOM1—DOM2—DOM3</p>
<p>DOM不只是针对JavaScript的，很多别的语言也都实现了DOM（如SVG,MathML,SMIL都基于XML）</p>
<p>（3）浏览器对象模型（BOM）：提供与浏览器交互的方法和接口，HTML5将很多BOM功能写入了正式规范</p>
<p>大多数浏览器在提及对JavaScript的支持情况时，一般都以ECMAScript兼容性和对DOM的支持情况为准。</p>
<h2 id="2-在HTML中使用JavaScript"><a href="#2-在HTML中使用JavaScript" class="headerlink" title="2 .在HTML中使用JavaScript"></a>2 .在HTML中使用JavaScript</h2><h4 id="2-1-lt-script-gt-元素"><a href="#2-1-lt-script-gt-元素" class="headerlink" title="2.1 &lt; script &gt;元素"></a>2.1 &lt; script &gt;元素</h4><p><strong>2.1.1 标签的位置</strong></p>
<p><strong>2.1.2 延迟脚本：</strong>表明脚本在执行时不会影响页面的构造，也就是说，脚本会被延迟到整个页面都解析完毕后再执行。在&lt; script &gt;元素中设置defer 属性，相当于告诉浏览器立即下载，但延迟执行。</p>
<p><strong>2.1.3 异步脚本：</strong>与defer 类似，async 只适用于外部脚本文件，并告诉浏览器立即下载文件。但与defer<br>不同的是，标记为async 的脚本并不保证按照指定它们的先后顺序执行，第二个脚本文件可能会在第一个脚本文件之前执行，因此设置async属性的两个脚本之间互不依赖非常重要。指定async 属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。为此，建议异步脚本不要在加载期间修改DOM。</p>
<p><strong>2.1.4 在XHTML中的用法</strong></p>
<p>XHTML的规则比HTML严格的多，为避免在XHTML中出现类似语法错误，有两个方法：</p>
<p>（1）用相应的HTML实体，如用&amp;lt代替&lt;,但该方法不利于理解</p>
<p>（2）用一个CData片段来包含JS代码：有的浏览器不兼容XHTML，因此不支持CData片段，因此可以注释掉：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="comment">//&lt;![CDATA[</span></span><br><span class="line"><span class="comment">//]]&gt;</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>2.1.5 不推荐使用的语法</strong>（已过时）</p>
<h4 id="2-2-嵌入代码与外部文件"><a href="#2-2-嵌入代码与外部文件" class="headerlink" title="2.2 嵌入代码与外部文件"></a>2.2 嵌入代码与外部文件</h4><p>外部文件（更推荐）：可维护性、可缓存、适应未来（通过外部文件来包含JavaScript 无须使用前面提到XHTML 或注释hack。HTML 和XHTML 包含外部文件的语法是相同的。）</p>
<h4 id="2-3-文档模式："><a href="#2-3-文档模式：" class="headerlink" title="2.3 文档模式："></a>2.3 文档模式：</h4><p>通过使用文档类型（doctype）切换实现：最初的两种文档模式：混杂模式和标准模式</p>
<p><strong>如果在文档开始处没有发现文档类型声明，则所有浏览器都会默认开启混杂模式</strong></p>
<p>后期：对于准标准模式，可以通过使用过渡型或框架集型文档类型来触发</p>
<h2 id="3-基本概念"><a href="#3-基本概念" class="headerlink" title="3.基本概念"></a>3.基本概念</h2><h4 id="3-4-数据类型"><a href="#3-4-数据类型" class="headerlink" title="3.4 数据类型"></a>3.4 数据类型</h4><p><strong>3.4.1 typeof操作符</strong></p>
<p>5种基本数据类型：Undefined,Null,Boolean,String,Number</p>
<p>一种复杂数据类型：Object</p>
<p><code>typeof 函数</code>   //  “function”</p>
<p><code>typeof  对象或null</code>   //  ‘’object’’</p>
<p><strong>3.4.2 Undefined类型</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message;<span class="comment">//这个变量声明后默认取得了undefined值</span></span><br><span class="line"><span class="comment">// var age;</span></span><br><span class="line">alert (message);<span class="comment">//"undefined"</span></span><br><span class="line">alert (age);<span class="comment">//报错</span></span><br><span class="line">alert (<span class="keyword">typeof</span> message);<span class="comment">//"undefined"</span></span><br><span class="line">alert (<span class="keyword">typeof</span> age);<span class="comment">//"undefined"</span></span><br></pre></td></tr></table></figure>

<p><strong>3.4.3 Null类型</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span>==<span class="literal">undefined</span><span class="comment">//true</span></span><br><span class="line"><span class="literal">null</span>===<span class="literal">undefined</span><span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p><strong>3.4.4 Number类型</strong></p>
<p>将非数值转为数值类型的函数：</p>
<p>Number():与一元+操作符的操作相同，对于Object类型：先调用.valueOf()方法 ,再调用toString()方法</p>
<p><code>Number(&#39;&#39;)\\0</code></p>
<p>parseInt()：把字符串转为整数  <code>parseInt(&#39;&#39;)//NaN</code></p>
<p>parseFloat()：只解析十进制</p>
<p><strong>3.4.5 String类型</strong></p>
<p>将值转为字符串类型的方法：</p>
<p>（1）数值、布尔值、对象和字符串值都有toString()方法，但null和undefined值没有这个方法</p>
<p>（2）String():能够将任何类型的值转换为字符串：</p>
<p><code>String(null)//&#39;null&#39;</code></p>
<p><code>String(undefined)//&#39;undefined&#39;</code></p>
<p>（3）’’+要转为字符串类型的值</p>
<p><strong>3.4.5 Object类型</strong></p>
<p>Object的每个实例都具有下列属性和方法：</p>
<p>constructor:保存用于创建当前对象的函数</p>
<p>hasOwnProperty:用于检查给定的属性在当前对象实例中是否存在</p>
<p>isPrototypeOf(object)：用于检查对象是否是传入对象的原型</p>
<p>propertyIsEnumerable(propertyName)：用于检查给定属性是否能够使用for-in语句来枚举</p>
<p>toLocaleString()：该字符串与执行环境的地区对应</p>
<p>toString()：返回对象的字符串表示</p>
<p>valueOf()：返回对象的字符串、数值或布尔值表示</p>
<h4 id="3-5-操作符"><a href="#3-5-操作符" class="headerlink" title="3.5 操作符"></a>3.5 操作符</h4><p><strong>3.5.1 一元操作符</strong></p>
<p>（1）递增或递减操作符：<strong>不仅适用于整数，还可以用于字符串、布尔值、浮点数值、对象</strong></p>
<p>前置：先求值再执行语句</p>
<p>后置：先执行语句再求值</p>
<p>（2）一元加和减操作符：应用于非数值时，类似于Number()转换函数</p>
<p>*<em>3.5.2 位操作符 *</em></p>
<p>（1）按位非（NOT）：用~表示：<strong>相当于对操作数的负值-1</strong></p>
<p>（2）按位与（AND）：用&amp;表示</p>
<p>（3）按位或（OR）：用|表示</p>
<p>（4）异或（XOR）：用^表示：不同才为1</p>
<p>（5）左移（&lt;&lt;）:左移不会影响操作数的符号位</p>
<p>（6）右移：有符号右移：&gt;&gt;用符号位的值来填充右移产生的所有空位，与左移类似</p>
<p>​                     无符号右移：&gt;&gt;&gt;用0来填充右移产生的所有空位(对于负数而言，由于将负数看作整数的表示方法，右移后的结果会非常大)</p>
<p><strong>3.5.3 布尔操作符</strong></p>
<p>（1）逻辑非：！</p>
<p>（2）逻辑与：&amp;&amp;：可以应用于任何类型的操作数，而不仅仅是布尔值，在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值，它遵循以下规则：</p>
<blockquote>
<p>如果第一个操作数是对象，则返回第二个操作数；<br>如果第二个操作数是对象，则只有在第一个操作数的求值结果为true 的情况下才会返回该<br>对象；<br>如果两个操作数都是对象，则返回第二个操作数；<br>如果有一个操作数是null，则返回null；<br>如果有一个操作数是NaN，则返回NaN；<br>如果有一个操作数是undefined，则返回undefined。</p>
</blockquote>
<p>​          短路操作符：<strong>如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值</strong></p>
<p>（3）逻辑或：||</p>
<blockquote>
<p>如果第一个操作数是对象，则返回第一个操作数；<br> 如果第一个操作数的求值结果为false，则返回第二个操作数；<br> 如果两个操作数都是对象，则返回第一个操作数；<br> 如果两个操作数都是null，则返回null；<br> 如果两个操作数都是NaN，则返回NaN；<br> 如果两个操作数都是undefined，则返回undefined。</p>
</blockquote>
<p><strong>3.5.4 乘性操作符</strong></p>
<p>（1）乘法（Infinity*0==NaN）;</p>
<p>（2）除法（Infinity/Infinity==NaN;0/0==NaN）；</p>
<p>（3）求模 ：取余：</p>
<p><strong>如果被除数是无穷大值而除数是有限大的数值,则取余结果是NaN;</strong></p>
<p><strong>如果被除数是有限大的数值，而除数是0，则取余结果是NaN;</strong></p>
<p><strong>如果是Infinity被Infinity除，则取余结果是NaN；</strong></p>
<p><strong>3.5.5 加性操作符</strong></p>
<p>如果是+Infinity与-Infinity相加,结果是NaN；</p>
<p>如果是Infinity减Infinity，结果是NaN;</p>
<p>如果是-Infinity减-Infinity，结果是NaN;</p>
<p><strong>3.5.6关系操作符</strong></p>
<p>任何操作数与NaN进行关系比较，结果都是false</p>
<p><strong>3.5.7  相等操作符</strong></p>
<p><code>null==undefined  //true</code></p>
<p><code>null===undefined//false</code></p>
<p><strong>3.5.8 条件操作符</strong></p>
<p><strong>3.5.9 赋值操作符</strong></p>
<p><strong>3.5.10 逗号操作符</strong></p>
<h4 id="3-6语句"><a href="#3-6语句" class="headerlink" title="3.6语句"></a>3.6语句</h4><p><strong>3.6.1 for-in语句</strong>：是一种精准的迭代语句，可以用来枚举对象的属性，如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> propName <span class="keyword">in</span> <span class="built_in">window</span>)&#123;</span><br><span class="line">    <span class="built_in">document</span>.write(propName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次循环，都会将window对象中存在的一个属性名赋值给变量propName。ECMAScript对象的属性没有顺序，因此for-in循环输出的属性名的顺序事不可预测的。</p>
<p><strong>3.6.2 label语句</strong>：相当于给for循环一个变量名，然后用break或continue来引用</p>
<p><strong>3.6.3 with语句：</strong>将代码的作用域设置到一个特定的对象中，用于简化多次编写同一个对象的工作（严格模式下不允许使用）</p>
<p><strong>3.6.4 switch语句：</strong>switch语句在比较值时使用的是全等操作符</p>
<h4 id="3-7-函数"><a href="#3-7-函数" class="headerlink" title="3.7 函数"></a>3.7 函数</h4><p><strong>参数：</strong>ECMAScript中的参数在内部是用一个数组表示，可以用arguments对象访问该参数数组，arguments与数组类似。</p>
<p><strong>ECMAScript中的所有参数传递的都是值，不可能通过引用传递参数</strong></p>
<h2 id="4-变量、作用域和内存问题"><a href="#4-变量、作用域和内存问题" class="headerlink" title="4 变量、作用域和内存问题"></a>4 变量、作用域和内存问题</h2><h3 id="4-1-基本类型和引用类型的值"><a href="#4-1-基本类型和引用类型的值" class="headerlink" title="4.1 基本类型和引用类型的值"></a>4.1 基本类型和引用类型的值</h3><p>值类型与引用类型的区别:</p>
<p>（1）存储方式的不同：值类型存储的是实际的值，存在栈中；而引用类型的值是保存在堆内存中的对象，JS不允许直接操作对象的内存空间，因此实际操作的是对象的引用而不是实际的对象。</p>
<p>（2）引用类型可以动态添加属性：引用类型可以动态添加对象的属性，值类型不可以</p>
<p>（3）复制变量值的方式不同：从一个变量向另一个变量复制基本类型值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上，这两个变量可以参与任何操作互不影响；而引用类型复制的是对象的地址引用，指向的是同一个对象，对副本的操作会影响对象本身。</p>
<p>（4）传递参数的方式不同，JS中所有函数的参数都是按值传递的，与复制变量值的过程是一样的，因此在向参数传递引用类型的值时，这个局部变量的变化会反映在函数的外部。（可以把ES函数的参数想象成局部变量）</p>
<p>（5）检测类型时的不同：检测基本数据类型时可以使用typeof操作符；检测引用类型值：instanceof操作符</p>
<h3 id="4-2-执行环境及作用域"><a href="#4-2-执行环境及作用域" class="headerlink" title="4.2 执行环境及作用域"></a>4.2 执行环境及作用域</h3><p>每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。</p>
<p>在<strong>Web浏览器</strong>中，全局执行环境被认为是window对象</p>
<p>当代码在一个环境中执行时，会创建变量对象的一个<strong>作用域链</strong>。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象。活动对象在最开始时只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样一直延续到全局执行环境；全局执行环境始终是作用域链中的最后一个对象。</p>
<p>标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止。</p>
<p><strong>延长作用域链</strong>：try-catch语句的catch块；with语句</p>
<p><strong>with语句</strong>：用于设置代码在特定对象中的作用域，有了 With 语句，在存取对象属性和方法时就不用重复指定参考对象，在 With 语句块中，凡是 JavaScript 不识别的属性和方法都和该语句块指定的对象有关。（with 语句是运行缓慢的代码块，尤其是在已设置了属性值时。大多数情况下，如果可能，最好避免使用它。）</p>
<p>变量的执行环境有助于确定应该何时释放内存</p>
<h3 id="4-3垃圾收集：JS有自动垃圾收集机制"><a href="#4-3垃圾收集：JS有自动垃圾收集机制" class="headerlink" title="4.3垃圾收集：JS有自动垃圾收集机制"></a>4.3垃圾收集：JS有自动垃圾收集机制</h3><p>离开作用域的值被自动标记为可以回收，因此将在垃圾收集期间被删除</p>
<p>垃圾收集机制的原理：找出那些不再继续使用的变量，然后释放其占用的内存，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间）周期性地执行这一操作。</p>
<p><strong>如何标识无用变量</strong>：垃圾收集方式</p>
<p>（1）标记清除：思想是给当前不使用的值加上标记，然后再回收其内存。（<strong>JS中最常用的</strong>）</p>
<p>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后去掉环境中的变量以及被环境中变量引用的变量的标记，在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后垃圾收集机器完成<strong>内存清除</strong>工作，销毁那些带标记的值并回收他们所使用的内存空间。</p>
<p>（2）引用计数：（不太常见）跟踪记录每个值被引用的次数，当引用次数变为0时，将其占用的内存空间回收回来。但有一个严重问题：<strong>循环引用</strong>，因此被放弃了。</p>
<p>（3）性能问题：如何确定垃圾收集的时间间隔：IE7：静态临界值调整为动态修正（&lt;15%：临界值加倍；&gt;85%：重置回默认临界值）</p>
<p>（4）管理内存：<strong>解除引用</strong>：一旦数据不再有用，通过将其值设为null来释放其引用，目的是让值脱离执行环境，以便垃圾收集器下次运行时将其回收，同时也有助于消除循环引用现象。。</p>
<h2 id="5-引用类型"><a href="#5-引用类型" class="headerlink" title="5.引用类型"></a>5.引用类型</h2><p>对象是某个特定引用类型的实例</p>
<h3 id="5-1-Object类型"><a href="#5-1-Object类型" class="headerlink" title="5.1 Object类型"></a>5.1 Object类型</h3><p>创建Object实例的方法：  </p>
<p>使用new操作符后跟Object构造函数：var person= new Object()  </p>
<p>使用对象字面量表示法  </p>
<p>访问属性的方法：点表示法和方括号表示法</p>
<p>点表示法只能接受字面量的成员的名字，不接受变量作为名字</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myDataName = <span class="string">'height'</span></span><br><span class="line"><span class="keyword">var</span> myDataValue = <span class="string">'1.75m'</span></span><br><span class="line">person[myDataName] = myDataValue</span><br></pre></td></tr></table></figure>

<h3 id="5-2-Array类型"><a href="#5-2-Array类型" class="headerlink" title="5.2 Array类型"></a>5.2 Array类型</h3><p>使用Array构造函数时可以省略new操作符，如下面两个例子结果是相同的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var colors &#x3D; new Array(3);</span><br><span class="line">var colors &#x3D; Array(3);</span><br></pre></td></tr></table></figure>

<p>与对象一样，在使用数组字面量表示法时，也不会调用Array构造函数。</p>
<p>检测数组：if(value instanceof Array):但instanceof操作符假定只有一个全局执行环境，当网页包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而<strong>存在两个以上不同版本的Array构造函数</strong>，为解决这个问题，ES5引入了<strong>Array.isArray(value)</strong>。</p>
<h4 id="5-2-1数组转化为字符串："><a href="#5-2-1数组转化为字符串：" class="headerlink" title="5.2.1数组转化为字符串："></a>5.2.1数组转化为字符串：</h4><p>toString(),toLocaleString():实际调用的是数组中每一项的toString()方法</p>
<p>join():参数为用作分隔符的字符串，若不传入任何值，或传入undefined，则使用逗号作为分隔符。</p>
<h4 id="5-2-2-栈方法：后进先出"><a href="#5-2-2-栈方法：后进先出" class="headerlink" title="5.2.2 栈方法：后进先出"></a>5.2.2 栈方法：后进先出</h4><p>push()：可以接受任意数量的参数，把它们逐个添加到数组末尾，并<strong>返回修改后数组的长度</strong></p>
<p>pop()：从数组末尾移除最后一项，减少数组的length值，然后<strong>返回移除的项</strong>。</p>
<h4 id="5-2-3-队列方法：先进先出："><a href="#5-2-3-队列方法：先进先出：" class="headerlink" title="5.2.3 队列方法：先进先出："></a>5.2.3 队列方法：先进先出：</h4><p>push()：可以接受任意数量的参数，把它们逐个添加到数组末尾，并<strong>返回修改后数组的长度</strong></p>
<p>shift()：从数组前端移除一项，减少数组的length值，然后<strong>返回移除的项</strong>。</p>
<p>unshift():能在数组前端添加任意个项，并<strong>返回新数组的长度</strong></p>
<h4 id="5-2-4重排序方法"><a href="#5-2-4重排序方法" class="headerlink" title="5.2.4重排序方法"></a>5.2.4重排序方法</h4><p>reverse()</p>
<p>sort():默认情况下，比较的是每个数组项的字符串，由小到大；因此可以接收函数作为参数，如果第一个参数应该在第二个参数前面，则返回负数，如果第一个参数应该在第二个参数后面则返回整数，<strong>返回对数组的引用</strong>。数组在原数组上进行排序，不生成副本。</p>
<h4 id="5-2-5操作方法"><a href="#5-2-5操作方法" class="headerlink" title="5.2.5操作方法"></a>5.2.5操作方法</h4><p>concat()：连接：操作的是副本</p>
<p>slice()：截取：操作的是副本，返回被截取的数组</p>
<p>splice():可以删除、插入以及替换：直接对原数组进行操作,返回一个数组，数组中包含从原始数组中删除的项。</p>
<h4 id="5-2-6-位置方法："><a href="#5-2-6-位置方法：" class="headerlink" title="5.2.6 位置方法："></a>5.2.6 位置方法：</h4><p>indexOf();lastIndexOf()  要求查找的项必须严格相等（===）</p>
<h4 id="5-2-7-迭代方法："><a href="#5-2-7-迭代方法：" class="headerlink" title="5.2.7 迭代方法："></a>5.2.7 迭代方法：</h4><p>传入这些方法中的函数会接收三个参数：数组项的值，该项在数组中的位置和数组对象本身</p>
<p>every()：对数组中的每一项运行给定函数，如果该函数对<strong>每</strong>一项都返回true，则返回true</p>
<p>some():对数组中的每一项运行给定函数，如果该函数对<strong>任</strong>一项都返回true，则返回true</p>
<p>filter()：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组</p>
<p>forEach()：对数组中的每一项运行给定函数，该方法没有返回值（本质与for循环迭代数组一样）</p>
<p>map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组</p>
<p>（Array.prototype.map.call(“str”,function(){})）:可以将map方法用在字符串上</p>
<h4 id="5-2-8-归并方法："><a href="#5-2-8-归并方法：" class="headerlink" title="5.2.8 归并方法："></a>5.2.8 归并方法：</h4><p>reduce(),reduceRight():传进来的函数包括4个参数：前一个值，当前值，项的索引和数组对象</p>
<blockquote>
<p><strong>ES6中数组的扩展：</strong></p>
</blockquote>
<h3 id="5-3-RegExp类型"><a href="#5-3-RegExp类型" class="headerlink" title="5.3 RegExp类型"></a>5.3 RegExp类型</h3><h4 id="5-3-1-模式："><a href="#5-3-1-模式：" class="headerlink" title="5.3.1 模式："></a>5.3.1 模式：</h4><p>g:全局模式   i:不区分大小写模式    m:多行模式</p>
<h4 id="5-3-2-创建：注意双重转义"><a href="#5-3-2-创建：注意双重转义" class="headerlink" title="5.3.2 创建：注意双重转义"></a>5.3.2 创建：注意双重转义</h4><p>使用字面量模式： var pattern1 = / [bc]at/i;</p>
<p>使用构造函数创建：var pattern1 = new RegExp(“[bc]at”,”i”)</p>
<p>ES3中，正则表达式字面量始终会共享同一个RegExp实例，而使用构造函数创建的没一个新的RegExp实例都是一个新实例。</p>
<h4 id="5-3-3-符号：https-www-w3school-com-cn-jsref-jsref-obj-regexp-asp"><a href="#5-3-3-符号：https-www-w3school-com-cn-jsref-jsref-obj-regexp-asp" class="headerlink" title="5.3.3 符号：https://www.w3school.com.cn/jsref/jsref_obj_regexp.asp"></a>5.3.3 符号：<a href="https://www.w3school.com.cn/jsref/jsref_obj_regexp.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/jsref/jsref_obj_regexp.asp</a></h4><h4 id="5-3-4实例方法："><a href="#5-3-4实例方法：" class="headerlink" title="5.3.4实例方法："></a>5.3.4实例方法：</h4><p>（1）RegExpObject.compile(RegExp):用于在脚本执行过程中编译正则表达式,也可用于改变和重新编译正则表达式。</p>
<p>（2）RegExpObject.exec(string):如果 exec() 找到了匹配的文本，返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为null。此数组的第 0 个元素是与正则表达式相匹配的文本，第 1 个元素是与 RegExpObject 的第 1 个子表达式相匹配的文本（如果有的话），第 2 个元素是与 RegExpObject 的第 2 个子表达式相匹配的文本（如果有的话），以此类推。</p>
<p>返回的数组包含两个额外属性：</p>
<p>index:表示匹配项在字符串中的位置  ；   input:表示应用正则表达式的字符串</p>
<p>对于exec()方法而言，即使在模式中设置了全局标志（g），它每次也只返回一个匹配项。</p>
<p>在不设置全局标志的情况下，在同一个字符串上多次调用exec()将始终返回第一个匹配项的信息，而RegExpObject的lastIndex属性依旧为0；</p>
<p>而在设置全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项，RegExpObject的lastIndex属性依旧为为匹配文本的最后一个字符的下一个位置，当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。</p>
<p>（3）RegExpObject.test(string):用于检测一个字符串是否匹配某个模式.(只想知道是否匹配的情况)</p>
<h4 id="5-3-5-RegExp实例继承的方法："><a href="#5-3-5-RegExp实例继承的方法：" class="headerlink" title="5.3.5 RegExp实例继承的方法："></a>5.3.5 RegExp实例继承的方法：</h4><p>（1）toLocaleString()和toString()方法都会返回正则表达式的字面量，与创建正则表达式的方式无关</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\[bc\\]at"</span>,<span class="string">"gi"</span>);</span><br><span class="line">alert(pattern.toLocaleString());<span class="regexp">/\[bc\]at/gi</span></span><br><span class="line">alert(pattern.toString());<span class="regexp">/\[bc\]at/gi</span></span><br></pre></td></tr></table></figure>

<p>（2）valueof()方法返回正则表达式本身</p>
<h4 id="5-3-6-支持正则表达式的String对象的方法"><a href="#5-3-6-支持正则表达式的String对象的方法" class="headerlink" title="5.3.6 支持正则表达式的String对象的方法"></a>5.3.6 支持正则表达式的String对象的方法</h4><blockquote>
<p><strong>ES6中正则的扩展：</strong></p>
</blockquote>
<h3 id="5-4-Date类型"><a href="#5-4-Date类型" class="headerlink" title="5.4 Date类型"></a>5.4 Date类型</h3><p>Date.parse():接受一个表示日期的字符串,然后根据这个字符串返回相应日期的毫秒数</p>
<p>Date.UTC()：参数分别是年份，基于0的月份（0-11），月中的哪一天（1-31），小时数（0-23），分钟，秒数以及毫秒数。同样返回相应的毫秒数（返回的是GMT时间）</p>
<p>Date.now():返回调用这个方法的日期和时间的毫秒数</p>
<p>Date.getTime():返回系统时间的毫秒数</p>
<h3 id="5-5-Function类型"><a href="#5-5-Function类型" class="headerlink" title="5.5 Function类型"></a>5.5 Function类型</h3><h4 id="5-5-1-函数提升："><a href="#5-5-1-函数提升：" class="headerlink" title="5.5.1 函数提升："></a>5.5.1 函数提升：</h4><p>解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁，解析器会率先读取函数声明，并使其在执行任何代码之前可用，至于函数表达式，则必须等到解析器执行它所在的代码行，才会真正被解释执行。</p>
<p>valueOf()和toString()方法返回函数的源代码</p>
<h4 id="5-5-2-函数内部属性：arguments-和this"><a href="#5-5-2-函数内部属性：arguments-和this" class="headerlink" title="5.5.2 函数内部属性：arguments 和this"></a>5.5.2 函数内部属性：arguments 和this</h4><p>arguments:类数组对象，有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数</p>
<p>arguments.callee:方便用于递归</p>
<p>另一个函数对象的属性：caller：保存着调用当前函数的函数的引用(arguments.callee.caller:可实现松散的耦合)</p>
<h4 id="5-5-3-函数属性和方法："><a href="#5-5-3-函数属性和方法：" class="headerlink" title="5.5.3 函数属性和方法："></a>5.5.3 函数属性和方法：</h4><p>属性：length(表示函数希望接收的命名参数的格式) 和 prototype（ES5中不可枚举）</p>
<p>方法：apply()（第二个参数是数组或arguments）和call():用于在特定的作用域中调用函数，<strong>可以扩充函数赖以运行的作用域</strong></p>
<p>bind():该方法会创建一个函数实例，其this值会被绑定到传给bind()函数的值</p>
<blockquote>
<p><strong>ES6中函数的扩展</strong></p>
</blockquote>
<h3 id="5-6基本包装类型"><a href="#5-6基本包装类型" class="headerlink" title="5.6基本包装类型"></a>5.6基本包装类型</h3><p>ECMAScript提供了3个特殊的引用类型：Boolean,Number和String,每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。</p>
<p>引用类型与基本包装类型的主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。所以我们不能在运行时为基本类型值添加属性和方法。</p>
<p>对基本包装类型的实例调用typeof会返回“object”，而且所有基本包装类型的对象在转换为布尔值时都是true</p>
<p>在使用typeof 和instanceof操作符测试基本类型数值与引用类型数值时，得到的结果完全不同。</p>
<p>基本包装类型重写了valueOf(),toLocaleString(),toString()方法，重写后的valueOf()方法返回对象表示的基本类型的值，另外两个方法则返回字符串形式的值。</p>
<h4 id="5-6-1-Boolean类型"><a href="#5-6-1-Boolean类型" class="headerlink" title="5.6.1 Boolean类型"></a>5.6.1 Boolean类型</h4><p>基本类型的布尔值与Boolean对象之间的区别：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> falseObject=<span class="keyword">new</span> <span class="built_in">Object</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">var</span> result = falseObject &amp;&amp; <span class="literal">true</span>;</span><br><span class="line">alert (result);<span class="comment">//true</span></span><br><span class="line">alert (<span class="keyword">typeof</span> falseObject)；<span class="comment">//Object</span></span><br><span class="line">alert (falseObject <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> falseValue=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> result = falseValue &amp;&amp; <span class="literal">true</span>;</span><br><span class="line">alert (result);<span class="comment">//false</span></span><br><span class="line">alert (<span class="keyword">typeof</span> falseValue)；<span class="comment">//boolean</span></span><br><span class="line">alert (falseValue <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h4 id="5-6-2-Number类型"><a href="#5-6-2-Number类型" class="headerlink" title="5.6.2 Number类型"></a>5.6.2 Number类型</h4><p>将数值格式化为<strong>字符串</strong>的方法：都会进行舍入操作</p>
<p>toFixed(num) ：0&lt;=num&lt;=20：按照指定的小数位数返回数值的字符串表示</p>
<p>toExponential(num): 0&lt;=num&lt;=20,用指数记数法表示，小数点前只有一位</p>
<p>toPrecision(num) :1&lt;=num&lt;=21：返回 NumberObject 的字符串表示，包含 num 个有效数字。如果 num 足够大，能够包括 NumberObject 整数部分的所有数字，那么返回的字符串将采用定点计数法。否则，采用指数计数法，即小数点前有一位数字，小数点后有 num-1 位数字。必要时，该数字会被舍入或用 0 补足。</p>
<blockquote>
<p><strong>ES6中数值的扩展</strong>：</p>
</blockquote>
<h4 id="5-6-3-String类型"><a href="#5-6-3-String类型" class="headerlink" title="5.6.3 String类型"></a>5.6.3 String类型</h4><p>即时字符串中包含双字节字符（不是占一个字节的ASCII字符），每个字符也仍然算一个字符</p>
<p>（1）字符方法：charAt();charCodeAt();方括号表示法：string[index]</p>
<p>（2）字符串操作方法：对原始字符串没有影响</p>
<p>拼接：concat()  或者 +运算符</p>
<p>截取：slice() ; substring() ; substr()（substr第二个参数是返回的字符个数)</p>
<p>slice（）方法会将参数与字符串总长度相加  ;</p>
<p>substring（）方法会将负值变为0，较小值放在第一个参数位置，较大值放在后面  ;</p>
<p>substr（）：第一个参数为负值时，将参数与字符串总长度相加；第二个参数为负值时，将参数变为0 ;</p>
<p>（3）字符串位置方法：indexOf(”str“,index):从字符串开头向后搜索和lastIndexOf(”str“,index)：从末尾向前</p>
<p>（若找不到返回-1,第二个参数可省，表示开始查找的位置）</p>
<p>（4）trim方法：该方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。</p>
<p>（部分浏览器还支持trimLeft()和trimRight()）</p>
<p>（5）字符串大小写转换方法：</p>
<p>toLowerCase(),toUpperCase();<strong>toLocaleLowerCase();toLocaleUpperCase()</strong>：更稳妥</p>
<p>（6）<strong>字符串的模式匹配方法：</strong></p>
<p>match()：与RegExp的exec()方法基本相同（全局模式下有差别）</p>
<p>search():返回字符串中第一个匹配项的索引，若没有查找到则返回-1</p>
<p><strong>replace(argu1,argu2)</strong>:argu1可以是字符串或者RegExp对象;argu2可以是字符串或者函数(字符串本身不变)</p>
<p>要想替换所有子字符串，要用RegExp的全局模式</p>
<p>若第二个参数为函数，则在只有一个匹配项（即与模式匹配的字符串）的情况下，会向这个函数传递3个参数：模式的匹配项、匹配项在字符串中的位置和原始字符串。在正则表达式定义多个捕获组的情况下，传递给函数的参数依次是模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项……，但最后两个参数依然分别是模式匹配项在字符串中的位置和原始字符串。这个函数返回一个字符串，表示应该被替换的匹配项。</p>
<p>split()：基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中，分隔符可以是字符串也可以是一个RegExp对象，可选的第二个参数用于指定数组的大小。</p>
<p>（7）str1.LocaleCompare(str2)方法：比较两个字符串，返回的数组取决于实现:</p>
<p>str1 在 str2前面：return -1; str1 在 str2后面：return 1;str1 等于 str2：return 0</p>
<p>（8）fromCharCode():接收一或多个字符编码，然后将它们转换成一个字符串</p>
<p>（9）一些HTML方法：如anchor(),big()等，但应尽少使用，因为它们创建的标记通常无法表达语义。</p>
<blockquote>
<p><strong>ES6中字符串的扩展和新增方法</strong></p>
</blockquote>
<h3 id="5-7-单体内置对象"><a href="#5-7-单体内置对象" class="headerlink" title="5.7 单体内置对象"></a>5.7 单体内置对象</h3><h2 id="6-理解对象"><a href="#6-理解对象" class="headerlink" title="6.理解对象"></a>6.理解对象</h2><h3 id="6-1-理解对象"><a href="#6-1-理解对象" class="headerlink" title="6.1 理解对象"></a>6.1 理解对象</h3><h4 id="6-1-1-属性类型"><a href="#6-1-1-属性类型" class="headerlink" title="6.1.1 属性类型"></a>6.1.1 属性类型</h4><p>ES5中有两种属性：数据属性和访问器属性</p>
<p><strong>数据属性</strong>：数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性：</p>
<p>[[Configurable]]:表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。</p>
<p>[[Enumerable]]：表示能否通过for-in循环返回属性。</p>
<p>[[Writable]]：表示能否修改属性的值。</p>
<p>[[Value]]：包含这个属性的值。</p>
<p><strong>要修改属性默认的特性：</strong>ES5的<strong>Object.defineProperty()</strong>方法（三个参数：属性所在的对象、属性的名字、描述符对象）使用如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">"name"</span>,&#123;</span><br><span class="line">    writable:<span class="literal">false</span>;</span><br><span class="line">    value:<span class="string">"Nicholas"</span>;</span><br><span class="line">&#125;)</span><br><span class="line">alert(person.name);<span class="comment">//"Nicholas"</span></span><br><span class="line">person.name=<span class="string">"Greg"</span>;</span><br><span class="line">alert(person.name);<span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>

<p>可以多次调用Object.defineProperty()方法修改同一个属性，但在把configurable特性设置为false之后就会有限制了。同时，<strong>在调用Object.defineProperty()方法创建一个新属性时，如果不指定，configurable，enumerable和writable特性的默认值都是false</strong>,如果调用Object.defineProperty()方法是修改已定义属性的特性，则无此限制。</p>
<p><strong>访问器属性</strong>（常用方法：设置一个属性的值会导致其他属性发生变化）</p>
<p>访问器属性不包含数据值，它包含一对getter函数和setter函数（不过这两个函数都不是必需的）。在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值，在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性：</p>
<p>[[Configurable]]:表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。</p>
<p>[[Enumerable]]：表示能否通过for-in循环返回属性。</p>
<p>[[Get]]：在读取属性时调用的函数。默认值为undefined。</p>
<p>[[Set]]：在写入属性时调用的函数。默认值为undefined。</p>
<p><strong>访问器属性不能直接定义，必须使用</strong>Object.defineProperty()来定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book=&#123;</span><br><span class="line">    _year:<span class="number">2004</span>,</span><br><span class="line">    edition:<span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book,<span class="string">"year"</span>,&#123;</span><br><span class="line">    <span class="keyword">get</span>:function()&#123;</span><br><span class="line">        <span class="keyword">return</span> book._year;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>:function(newValue)&#123;</span><br><span class="line">        <span class="keyword">if</span>(newValue&gt;<span class="number">2004</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>._year=newValue;</span><br><span class="line">            <span class="keyword">this</span>.edition=newValue<span class="number">-2004</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">book.year=<span class="number">2005</span>;</span><br><span class="line">alert(book.edition);<span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h4 id="6-1-2-定义多个属性"><a href="#6-1-2-定义多个属性" class="headerlink" title="6.1.2 定义多个属性"></a>6.1.2 定义多个属性</h4><p>Object.defineProperties()方法:可以一次性定义多个属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperties(book,&#123;</span><br><span class="line">    _year:&#123;</span><br><span class="line">        writable:<span class="literal">true</span>,</span><br><span class="line">        value:<span class="number">2004</span></span><br><span class="line">    &#125;,</span><br><span class="line">    edition:&#123;</span><br><span class="line">        writable:<span class="literal">true</span>;</span><br><span class="line">        value:<span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    year:&#123;</span><br><span class="line">        <span class="keyword">get</span>:function()&#123;</span><br><span class="line">            <span class="keyword">return</span> book._year;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>:function(newValue)&#123;</span><br><span class="line">            <span class="keyword">if</span>(newValue&gt;<span class="number">2004</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>._year=newValue;</span><br><span class="line">                <span class="keyword">this</span>.edition=newValue<span class="number">-2004</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="6-1-3-读取属性的特性"><a href="#6-1-3-读取属性的特性" class="headerlink" title="6.1.3 读取属性的特性"></a>6.1.3 读取属性的特性</h4><p><strong>Object.getOwnPropertyDescriptor()</strong>方法：取得给定属性的描述符。接收两个参数：属性所在的对象和要读取其描述符的属性名称，如：(接上段代码)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> descriptor=<span class="built_in">Object</span>.getOwnPropertyDescriptor(book,<span class="string">"_year"</span>);</span><br><span class="line">alert(descriptor.value);<span class="comment">//2004</span></span><br><span class="line">alert(descriptor.configurable);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p><strong>ES5的Object.getOwnPropertyDescriptor（）方法只能用于实例属性，要取得原型属性的描述符，必须直接在原型对象上调用该方法。</strong></p>
<h3 id="6-2创建对象"><a href="#6-2创建对象" class="headerlink" title="6.2创建对象"></a>6.2创建对象</h3><h4 id="6-2-1-工厂模式："><a href="#6-2-1-工厂模式：" class="headerlink" title="6.2.1 工厂模式："></a>6.2.1 工厂模式：</h4><p>用函数来封装以特定接口创建对象的细节（虽然解决了创建多个相似对象的问题，但没有解决对象识别的问题）</p>
<h4 id="6-2-2-构造函数模式"><a href="#6-2-2-构造函数模式" class="headerlink" title="6.2.2 构造函数模式"></a>6.2.2 构造函数模式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.job=job;</span><br><span class="line">    <span class="keyword">this</span>.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>,<span class="number">29</span>,<span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2=<span class="keyword">new</span> Person(<span class="string">"Greg"</span>,<span class="number">23</span>,<span class="string">"Doctor"</span>);</span><br><span class="line">alert(person1.constructor==Person);<span class="comment">//true</span></span><br><span class="line">alert(person1 <span class="keyword">instanceof</span> Person);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>调用构造函数实际会经历以下4个步骤：</p>
<p>（1）创建一个新对象</p>
<p>（2）将构造函数的作用域赋给新对象（因此this就指向了这个对象）</p>
<p>（3）执行构造函数中的代码（为这个新对象添加属性）</p>
<p>（4）返回新对象</p>
<p><strong>构造函数模式存在的问题</strong>：每个方法都要在每个实例重新创建一遍</p>
<h4 id="6-2-3-原型模式"><a href="#6-2-3-原型模式" class="headerlink" title="6.2.3 原型模式"></a>6.2.3 原型模式</h4><p><strong>构造函数，原型和实例的关系：</strong></p>
<p>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。</p>
<p><strong>（1）理解原型对象</strong>：prototype是通过调用构造函数而创建的那个对象实例的原型对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name=<span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age=<span class="number">29</span>;</span><br><span class="line">Person.prototype.job=<span class="string">"Software Engineer"</span>;</span><br><span class="line">Person.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName();<span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>

<p>在默认情况下，所有原型对象都会自动获得一个constructor(构造函数)属性，这个属性是一个指向prototype属性所在函数的指针。Person.prototype.constructor指向Person</p>
<p>明确一点：<strong>这个连接存在于实例与构造函数的原型对象之间</strong>，而不是存在于实例与构造函数之间（即person1与Person.prototype之间的联系）person1内部有一个指向Person.prototype的指针</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(Person.prototype.isPrototypeOf(person1));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>Object.getPrototypeOf():</strong>可以方便地获取一个对象的原型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">Object</span>.getPrototypeOf(person1)==Person.prototype);<span class="comment">//true</span></span><br><span class="line">alert(<span class="built_in">Object</span>.getPrototypeOf(person1).name);<span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>

<p>当代码要取得某个对象的某个属性时，会先从对象实例本身开始搜索，如果没有找到属性名，则继续搜索指针指向的原型对象。</p>
<p>当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性，也就是说，添加这个属性值会阻止我们访问原型中的那个属性，但不会修改那个属性;不过使用delete操作符可以完全删除实例属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">person1.name=<span class="string">"Greg"</span>;</span><br><span class="line">alert(person1.name);<span class="comment">//Greg</span></span><br><span class="line">alert(person1.hasOwnProperty(<span class="string">"name"</span>));<span class="comment">//true</span></span><br><span class="line"><span class="keyword">delete</span> person1.name;</span><br><span class="line">alert(person1.hasOwnProperty(<span class="string">"name"</span>));<span class="comment">//false</span></span><br><span class="line">alert(person1.name);<span class="comment">//Nicholas</span></span><br></pre></td></tr></table></figure>

<p><strong>hasOwnProperty()</strong>方法：检测一个属性是存在于实例中还是原型中</p>
<p><strong>（2）原型与in操作符</strong></p>
<p><strong>单独使用</strong>：in操作符只要通过对象能访问到属性就返回true,hasOwnProperty()只在属性存在于实例中时才返回true,因此当in操作符返回true，而hasOwnProperty()返回false时,就说明该属性存在于原型中</p>
<p><strong>for-in循环</strong>时：返回的是所有能够通过对象访问的，可枚举的属性，其中既包括存在于实例中的属性，也包括在原型中的属性。（<strong>屏蔽了原型中不可枚举属性（即将[[Enumerable]]标记为false属性）的实例属性也会在for-in循环中返回，因为根据规定，所有开发人员定义的属性都是可枚举的——只有在IE8及更早版本中例外</strong>）</p>
<p><strong>Object.keys()</strong>方法：接收一个对象作为参数，返回一个包含所有<strong>可枚举</strong>属性的<strong>字符串</strong>数组</p>
<p><strong>Object.getOwnPropertyNames():</strong>接收一个对象作为参数，返回一个包含<strong>所有实例属性</strong>的<strong>字符串</strong>数组</p>
<p><strong>（3）更简单的原型语法</strong>：用字面量法重写原型对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype=&#123;</span><br><span class="line">    <span class="keyword">constructor</span>:Person,</span><br><span class="line">    name:"Nicholas",</span><br><span class="line">    age:29,</span><br><span class="line">    job:"Software Engineer",</span><br><span class="line">    sayName:function()&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype,<span class="string">"constructor"</span>,&#123;</span><br><span class="line">    enumerable:<span class="literal">false</span>,</span><br><span class="line">    value:Person</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName();<span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>

<p>但此时，constructor属性不再指向Person函数，而是<strong>指向Object</strong>,但由于此时constructor属性为自定义的，<strong>可枚举</strong>，因此可以通过Object.defineProperty()将其[[Enumerable]]属性特性改为false。</p>
<p><strong>（4）原型的动态性</strong></p>
<p>重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系，他们引用的仍然是最初的原型。</p>
<p><strong>所以只能修改</strong></p>
<p><strong>（5）原生对象的原型</strong></p>
<p>可以修改如Array,Object,String等原生引用类型的原型，如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.startsWith=<span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.indexof(text)==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（6）原型对象的问题</strong></p>
<p>原型对象中的引用类型值会被共享</p>
<h4 id="6-2-4-组合使用构造函数模式和原型模式（最广泛、认同度最高）"><a href="#6-2-4-组合使用构造函数模式和原型模式（最广泛、认同度最高）" class="headerlink" title="6.2.4 组合使用构造函数模式和原型模式（最广泛、认同度最高）"></a>6.2.4 组合使用构造函数模式和原型模式（最广泛、认同度最高）</h4><p>构造函数用于定义实例属性，而原型模式用于定义方法和共享的属性。</p>
<h4 id="6-2-5-动态原型模式（可以把所有信息都封装在构造函数中）"><a href="#6-2-5-动态原型模式（可以把所有信息都封装在构造函数中）" class="headerlink" title="6.2.5 动态原型模式（可以把所有信息都封装在构造函数中）"></a>6.2.5 动态原型模式（可以把所有信息都封装在构造函数中）</h4><p>通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型，如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.job=job;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName!=<span class="string">"function"</span>)</span><br><span class="line">        <span class="comment">//此时sayName若是不存在或者不是函数类型，都会对原型初始化，而且检查一个属性或方法就可以</span></span><br><span class="line">    &#123;</span><br><span class="line">        Person.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-6-寄生（parasitic）构造函数模式（不建议使用）"><a href="#6-2-6-寄生（parasitic）构造函数模式（不建议使用）" class="headerlink" title="6.2.6 寄生（parasitic）构造函数模式（不建议使用）"></a>6.2.6 寄生（parasitic）构造函数模式（不建议使用）</h4><p>假如我们想创建一个具有额外方法的特殊数组，由于不能直接修改Array函数，因此可以使用这个模式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">values.push.apply(values,<span class="built_in">arguments</span>);<span class="comment">//arguments是个类数组对象，不能直接push到数组中</span></span><br></pre></td></tr></table></figure>

<p>构造函数在没有返回值的情况下，默认返回新对象实例，而该模式下的构造函数形式类似于工厂模式，在末尾有return语句，可以重写调用构造函数时返回的值，因此，<strong>返回的对象与构造函数以及构造函数的原型属性之间没有关系</strong>，也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。使用instanceof 没有意义。</p>
<h4 id="6-2-7-稳妥构造函数模式"><a href="#6-2-7-稳妥构造函数模式" class="headerlink" title="6.2.7 稳妥构造函数模式"></a>6.2.7 稳妥构造函数模式</h4><p>指的是没有公共属性，最适合在一些安全环境中使用，也与工厂模式很像</p>
<p>与寄生构造函数模式的区别：（1）不引用this对象（寄生模式在声明方法时使用）；（2）不使用new操作符</p>
<p>这种模式下创建的对象除了使用方法，没有其他办法访问属性值。</p>
<h3 id="6-3-继承"><a href="#6-3-继承" class="headerlink" title="6.3 继承"></a>6.3 继承</h3><p>ES只支持实现继承，而且主要依靠原型链</p>
<p>方法签名：</p>
<h4 id="6-3-1-原型链"><a href="#6-3-1-原型链" class="headerlink" title="6.3.1 原型链"></a>6.3.1 原型链</h4><p>基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法</p>
<p>实现本质是重写原型对象，代之以另一个新类型的实例</p>
<p><strong>（1）别忘记默认的原型</strong></p>
<p>所有函数的默认原型都是Object的实例</p>
<p><strong>（2）确定原型和实例的关系</strong></p>
<p>instanceof操作符：+构造函数：只要用这个操作符测试实例与原型链中出现过的构造函数，就会返回true</p>
<p>isPrototypeOf()方法:只要是原型链中出现过的原型对象，都可以说是该原型链所派生的实例的原型</p>
<p><strong>（3）谨慎的定义方法</strong></p>
<p>给原型添加方法的代码一定要放在替换原型的语句之后，且不能使用字面量方法创建原型方法</p>
<p><strong>（4）原型链的问题</strong></p>
<p>第一个问题：包含引用类型值的原型属性会被所有实例共享</p>
<p>第二个问题：在创建子类型的实例时，不能向超类型的构造函数中传递参数</p>
<h4 id="6-3-2-借用构造函数"><a href="#6-3-2-借用构造函数" class="headerlink" title="6.3.2 借用构造函数"></a>6.3.2 借用构造函数</h4><p>基本思想：在子类型构造函数的内部调用超类型构造函数（使用call()方法或apply()方法）</p>
<p>好处：可以传递参数</p>
<p>问题：无法避免构造函数模式存在的问题——方法都在构造函数中定义，无法复用</p>
<h4 id="6-3-3-组合继承（JS中最常用的继承模式）"><a href="#6-3-3-组合继承（JS中最常用的继承模式）" class="headerlink" title="6.3.3 组合继承（JS中最常用的继承模式）"></a>6.3.3 组合继承（JS中最常用的继承模式）</h4><p>指的是将原型链和借用构造函数的技术组合到一起，使用原型链实现对原型属性和方法的继承，而使用借用构造函数来实现对实例属性的继承。</p>
<p>而且instanceof()和isPrototypeOf()也能够用于识别基于组合继承创建的对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.colors=[<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//继承属性</span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>,name);<span class="comment">//第二次调用构造函数，SubType实例中传入了第二组name和colors</span></span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承方法</span></span><br><span class="line">SubType.prototype=<span class="keyword">new</span> SuperType();<span class="comment">//第一次调用构造函数，SubType原型中传入了name和colors</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">function inheriPrototype(subType,superType)&#123;</span></span><br><span class="line"><span class="comment">    var prototype=object(superType.prototype);//构建超类型原型的一个副本</span></span><br><span class="line"><span class="comment">    prototype.constructer=subType;</span></span><br><span class="line"><span class="comment">    subType.prototype=prototype;//将新创建的对象（即副本）赋值给子类型的原型</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">inheriPrototype(SubType,SuperType);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">SubType.prototype.constructor=SubType;</span><br><span class="line">SubType.prototype.sayAge=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 =<span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>,<span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"yellow"</span>);</span><br><span class="line">alert(instance1.colors);<span class="comment">//"red","green","blue","yellow"</span></span><br><span class="line">instance1.sayName();<span class="comment">//"Nicholas"</span></span><br><span class="line">instance1.sayAge();<span class="comment">//29</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 =<span class="keyword">new</span> SubType(<span class="string">"Greg"</span>,<span class="number">27</span>);</span><br><span class="line">alert(instance2.colors);<span class="comment">//"red","green","blue"</span></span><br><span class="line">instance2.sayName();<span class="comment">//"Greg"</span></span><br><span class="line">instance2.sayAge();<span class="comment">//27</span></span><br></pre></td></tr></table></figure>

<p><u>问题：会调用两次超类型构造函数</u></p>
<h4 id="6-3-4-原型式继承"><a href="#6-3-4-原型式继承" class="headerlink" title="6.3.4 原型式继承"></a>6.3.4 原型式继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype=o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思想是基于对象o，创建一个实例，该实例的原型对象o,在包含引用类型属性值方面该方法与原型模式是一样的</p>
<p>ES5新增了Object.create()方法：接受两个参数：一个是用作新对象原型的对象和（可选的）一个新对象定义额外的对象，该对象中每个属性都是通过自己的描述符定义的.</p>
<h4 id="6-3-5-寄生式继承"><a href="#6-3-5-寄生式继承" class="headerlink" title="6.3.5 寄生式继承"></a>6.3.5 寄生式继承</h4><p>思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象（即在内部通过构造函数创建一个实例，再为该对象增加方法，最后返回该对象）</p>
<h4 id="6-3-6-寄生组合式继承（最理想）"><a href="#6-3-6-寄生组合式继承（最理想）" class="headerlink" title="6.3.6 寄生组合式继承（最理想）"></a>6.3.6 寄生组合式继承（最理想）</h4><p>用于解决组合继承两次调用构造函数的问题，方法见上方代码，该方法只调用一次SuperType构造函数,且原型链保持不变。</p>
<blockquote>
<p><strong>ES6中对象的扩展和新增方法</strong></p>
</blockquote>
<h2 id="7-函数表达式"><a href="#7-函数表达式" class="headerlink" title="7.函数表达式"></a>7.函数表达式</h2>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/12/JavaScript%E7%AC%94%E8%AE%B0/" rel="prev" title="JavaScript笔记">
      <i class="fa fa-chevron-left"></i> JavaScript笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/03/12/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="next" title="你不知道的JavaScript读书笔记">
      你不知道的JavaScript读书笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-JavaScript简介"><span class="nav-number">1.</span> <span class="nav-text">1.JavaScript简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-ECMA-262："><span class="nav-number">1.0.1.</span> <span class="nav-text">1.1 ECMA-262：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-一个完整的JavaScript实现应该由下列三个不同的部分组成："><span class="nav-number">1.0.2.</span> <span class="nav-text">1.2 一个完整的JavaScript实现应该由下列三个不同的部分组成：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-在HTML中使用JavaScript"><span class="nav-number">2.</span> <span class="nav-text">2 .在HTML中使用JavaScript</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-lt-script-gt-元素"><span class="nav-number">2.0.1.</span> <span class="nav-text">2.1 &lt; script &gt;元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-嵌入代码与外部文件"><span class="nav-number">2.0.2.</span> <span class="nav-text">2.2 嵌入代码与外部文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-文档模式："><span class="nav-number">2.0.3.</span> <span class="nav-text">2.3 文档模式：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-基本概念"><span class="nav-number">3.</span> <span class="nav-text">3.基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-数据类型"><span class="nav-number">3.0.1.</span> <span class="nav-text">3.4 数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-操作符"><span class="nav-number">3.0.2.</span> <span class="nav-text">3.5 操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6语句"><span class="nav-number">3.0.3.</span> <span class="nav-text">3.6语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-函数"><span class="nav-number">3.0.4.</span> <span class="nav-text">3.7 函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-变量、作用域和内存问题"><span class="nav-number">4.</span> <span class="nav-text">4 变量、作用域和内存问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-基本类型和引用类型的值"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 基本类型和引用类型的值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-执行环境及作用域"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 执行环境及作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3垃圾收集：JS有自动垃圾收集机制"><span class="nav-number">4.3.</span> <span class="nav-text">4.3垃圾收集：JS有自动垃圾收集机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-引用类型"><span class="nav-number">5.</span> <span class="nav-text">5.引用类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-Object类型"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 Object类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-Array类型"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 Array类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1数组转化为字符串："><span class="nav-number">5.2.1.</span> <span class="nav-text">5.2.1数组转化为字符串：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2-栈方法：后进先出"><span class="nav-number">5.2.2.</span> <span class="nav-text">5.2.2 栈方法：后进先出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-3-队列方法：先进先出："><span class="nav-number">5.2.3.</span> <span class="nav-text">5.2.3 队列方法：先进先出：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-4重排序方法"><span class="nav-number">5.2.4.</span> <span class="nav-text">5.2.4重排序方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-5操作方法"><span class="nav-number">5.2.5.</span> <span class="nav-text">5.2.5操作方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-6-位置方法："><span class="nav-number">5.2.6.</span> <span class="nav-text">5.2.6 位置方法：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-7-迭代方法："><span class="nav-number">5.2.7.</span> <span class="nav-text">5.2.7 迭代方法：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-8-归并方法："><span class="nav-number">5.2.8.</span> <span class="nav-text">5.2.8 归并方法：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-RegExp类型"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 RegExp类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-1-模式："><span class="nav-number">5.3.1.</span> <span class="nav-text">5.3.1 模式：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-2-创建：注意双重转义"><span class="nav-number">5.3.2.</span> <span class="nav-text">5.3.2 创建：注意双重转义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-3-符号：https-www-w3school-com-cn-jsref-jsref-obj-regexp-asp"><span class="nav-number">5.3.3.</span> <span class="nav-text">5.3.3 符号：https:&#x2F;&#x2F;www.w3school.com.cn&#x2F;jsref&#x2F;jsref_obj_regexp.asp</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-4实例方法："><span class="nav-number">5.3.4.</span> <span class="nav-text">5.3.4实例方法：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-5-RegExp实例继承的方法："><span class="nav-number">5.3.5.</span> <span class="nav-text">5.3.5 RegExp实例继承的方法：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-6-支持正则表达式的String对象的方法"><span class="nav-number">5.3.6.</span> <span class="nav-text">5.3.6 支持正则表达式的String对象的方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-Date类型"><span class="nav-number">5.4.</span> <span class="nav-text">5.4 Date类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-Function类型"><span class="nav-number">5.5.</span> <span class="nav-text">5.5 Function类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-1-函数提升："><span class="nav-number">5.5.1.</span> <span class="nav-text">5.5.1 函数提升：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-2-函数内部属性：arguments-和this"><span class="nav-number">5.5.2.</span> <span class="nav-text">5.5.2 函数内部属性：arguments 和this</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-3-函数属性和方法："><span class="nav-number">5.5.3.</span> <span class="nav-text">5.5.3 函数属性和方法：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6基本包装类型"><span class="nav-number">5.6.</span> <span class="nav-text">5.6基本包装类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-6-1-Boolean类型"><span class="nav-number">5.6.1.</span> <span class="nav-text">5.6.1 Boolean类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-6-2-Number类型"><span class="nav-number">5.6.2.</span> <span class="nav-text">5.6.2 Number类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-6-3-String类型"><span class="nav-number">5.6.3.</span> <span class="nav-text">5.6.3 String类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-7-单体内置对象"><span class="nav-number">5.7.</span> <span class="nav-text">5.7 单体内置对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-理解对象"><span class="nav-number">6.</span> <span class="nav-text">6.理解对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-理解对象"><span class="nav-number">6.1.</span> <span class="nav-text">6.1 理解对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-1-属性类型"><span class="nav-number">6.1.1.</span> <span class="nav-text">6.1.1 属性类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-2-定义多个属性"><span class="nav-number">6.1.2.</span> <span class="nav-text">6.1.2 定义多个属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-3-读取属性的特性"><span class="nav-number">6.1.3.</span> <span class="nav-text">6.1.3 读取属性的特性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2创建对象"><span class="nav-number">6.2.</span> <span class="nav-text">6.2创建对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-1-工厂模式："><span class="nav-number">6.2.1.</span> <span class="nav-text">6.2.1 工厂模式：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-2-构造函数模式"><span class="nav-number">6.2.2.</span> <span class="nav-text">6.2.2 构造函数模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-3-原型模式"><span class="nav-number">6.2.3.</span> <span class="nav-text">6.2.3 原型模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-4-组合使用构造函数模式和原型模式（最广泛、认同度最高）"><span class="nav-number">6.2.4.</span> <span class="nav-text">6.2.4 组合使用构造函数模式和原型模式（最广泛、认同度最高）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-5-动态原型模式（可以把所有信息都封装在构造函数中）"><span class="nav-number">6.2.5.</span> <span class="nav-text">6.2.5 动态原型模式（可以把所有信息都封装在构造函数中）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-6-寄生（parasitic）构造函数模式（不建议使用）"><span class="nav-number">6.2.6.</span> <span class="nav-text">6.2.6 寄生（parasitic）构造函数模式（不建议使用）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-7-稳妥构造函数模式"><span class="nav-number">6.2.7.</span> <span class="nav-text">6.2.7 稳妥构造函数模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-继承"><span class="nav-number">6.3.</span> <span class="nav-text">6.3 继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-1-原型链"><span class="nav-number">6.3.1.</span> <span class="nav-text">6.3.1 原型链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-2-借用构造函数"><span class="nav-number">6.3.2.</span> <span class="nav-text">6.3.2 借用构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-3-组合继承（JS中最常用的继承模式）"><span class="nav-number">6.3.3.</span> <span class="nav-text">6.3.3 组合继承（JS中最常用的继承模式）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-4-原型式继承"><span class="nav-number">6.3.4.</span> <span class="nav-text">6.3.4 原型式继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-5-寄生式继承"><span class="nav-number">6.3.5.</span> <span class="nav-text">6.3.5 寄生式继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-6-寄生组合式继承（最理想）"><span class="nav-number">6.3.6.</span> <span class="nav-text">6.3.6 寄生组合式继承（最理想）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-函数表达式"><span class="nav-number">7.</span> <span class="nav-text">7.函数表达式</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="柴郡猫"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">柴郡猫</p>
  <div class="site-description" itemprop="description">向死而生的生命都在热烈地生长</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/holichang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;holichang" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1185381333@qq.com" title="E-Mail → mailto:1185381333@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">柴郡猫</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
