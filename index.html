<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"holichang.github.io","root":"/","scheme":"Muse","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="向死而生的生命都在热烈地生长">
<meta property="og:type" content="website">
<meta property="og:title" content="Cheshire Cat">
<meta property="og:url" content="https://holichang.github.io/index.html">
<meta property="og:site_name" content="Cheshire Cat">
<meta property="og:description" content="向死而生的生命都在热烈地生长">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="柴郡猫">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://holichang.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>Cheshire Cat</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Cheshire Cat</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://holichang.github.io/2020/03/12/JavaScript%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="柴郡猫">
      <meta itemprop="description" content="向死而生的生命都在热烈地生长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cheshire Cat">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/12/JavaScript%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">JavaScript笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-12 13:28:21 / 修改时间：13:50:48" itemprop="dateCreated datePublished" datetime="2020-03-12T13:28:21+08:00">2020-03-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h4 id="1-全角和半角："><a href="#1-全角和半角：" class="headerlink" title="1.全角和半角："></a>1.全角和半角：</h4><p>全角：是一种电脑字符，是指一个全角字符占用两个标准字符(或两个半角字符)的位置。全角占两个字节。</p>
<p>半角：是指一个字符占用一个标准的字符位置。半角占一个字节。</p>
<p>全角和半角主要是针对标点符号来说的，全角标点占两个字节，半角占一个字节。不管是半角还是全角，汉字都要占两个字节。</p>
<p><strong>JS判断输入的文字是全角还是半角</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str=<span class="string">"中文；;a"</span>;</span><br><span class="line">alert(str.match(<span class="regexp">/[\u0000-\u00ff]/g</span>));   <span class="comment">//半角 </span></span><br><span class="line">alert(str.match(<span class="regexp">/[\u4e00-\u9fa5]/g</span>));   <span class="comment">//中文 </span></span><br><span class="line">alert(str.match(<span class="regexp">/[\uff00-\uffff]/g</span>));   <span class="comment">//全角</span></span><br></pre></td></tr></table></figure>

<p><strong>JS找到全角空格和半角空格</strong></p>
<p>str.charCodeAt()==32 ||str.charCodeAt()==12288</p>
<p><strong>JS对全角与半角的相互转化：charCodeAt()  fromCharCode()</strong></p>
<p>全角空格为12288，半角空格为32</p>
<p>其他字符半角(33-126)与全角(65281-65374)的对应关系是：均相差65248</p>
<p>全角空格：/\u3000/g    </p>
<p>半角空格：/\u0020/g</p>
<h4 id="2-JSON："><a href="#2-JSON：" class="headerlink" title="2.JSON："></a>2.JSON：</h4><p><code>JSON.stringfy()</code>:将对象转为JSON字符串</p>
<p><code>JSON.parse</code>：将JSON字符串转为对象</p>
<h4 id="3-回调函数"><a href="#3-回调函数" class="headerlink" title="3.回调函数"></a>3.回调函数</h4><h4 id="4-文本框提示："><a href="#4-文本框提示：" class="headerlink" title="4.文本框提示："></a>4.文本框提示：</h4><p>用keyup, keypress, keydown以及oninput四个事件分别来测试对于用户输入的事件监听，并在事件响应函数中增加console.log(‘event handle’)。并尝试以下输入方式，观察提示框内容变化的情况，以及console的输出情况：</p>
<ul>
<li><p>一个字母一个字母的输入</p>
</li>
<li><p>一个字母一个字母输入，同时加上按回车键，ESC键，上下左右键</p>
</li>
<li><p>按住某个字母键不动</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">keyup</th>
<th align="center">keypress</th>
<th align="center">keydown</th>
<th align="center">oninput</th>
</tr>
</thead>
<tbody><tr>
<td align="center">一个字母一个字母输入</td>
<td align="center">响应一次</td>
<td align="center">响应一次</td>
<td align="center">响应一次</td>
<td align="center">响应一次</td>
</tr>
<tr>
<td align="center">加上回车键</td>
<td align="center">响应一次</td>
<td align="center">响应一次</td>
<td align="center">响应一次</td>
<td align="center">没有响应</td>
</tr>
<tr>
<td align="center">加上ESC键</td>
<td align="center">响应一次</td>
<td align="center">没有响应</td>
<td align="center">响应一次</td>
<td align="center">没有响应</td>
</tr>
<tr>
<td align="center">加上下左右键</td>
<td align="center">响应一次</td>
<td align="center">没有响应</td>
<td align="center">响应一次</td>
<td align="center">没有响应</td>
</tr>
<tr>
<td align="center">按住某个字母键不动</td>
<td align="center">响应一次</td>
<td align="center">持续响应</td>
<td align="center">持续响应</td>
<td align="center">持续响应</td>
</tr>
</tbody></table>
</li>
</ul>
<p>keypress和keydown显示的文本有延迟，不显示最后一个按键</p>
<p>（1）KeyDown触发后，不一定触发KeyUp，当KeyDown 按下后，拖动鼠标，那么将不会触发KeyUp事件。</p>
<p>（2）KeyPress主要用来捕获数字(<strong>注意：包括Shift+数字的符号</strong>)、字母（<strong>注意：包括大小写</strong>）、小键盘等除了F1-12、SHIFT、Alt、Ctrl、Insert、Home、PgUp、Delete、End、PgDn、ScrollLock、Pause、NumLock、{菜单键}、{开始键}和方向键外的ANSI字符</p>
<p>（3）KeyDown 和KeyUp 通常可以捕获键盘除了PrScrn所有按键(这里不讨论特殊键盘的特殊键）</p>
<p>（4）KeyPress 只能捕获单个字符</p>
<p>（5）KeyDown 和KeyUp 可以捕获组合键。</p>
<p>（6）KeyPress 可以捕获单个字符的大小写</p>
<p>（7）KeyDown和KeyUp 对于单个字符捕获的KeyValue 都是一个值，也就是不能判断单个字符的大小写。</p>
<p>（8）KeyPress 不区分小键盘和主键盘的数字字符。</p>
<p>（9）KeyDown 和KeyUp 区分小键盘和主键盘的数字字符。</p>
<p>（10）其中PrScrn 按键KeyPress、KeyDown和KeyUp 都不能捕获。</p>
<p>（11）在使用键盘的时候，通常会使用到CTRL+SHIFT+ALT 类似的组合键功能。对于此，我们如何来判定？</p>
<p>​     通过KeyUp 事件能够来处理（这里说明一下为什么不用KeyDown，因为在判定KeyDown的时候，CTRL、SHIFT和ALT 属于一直按下状态，然后再加另外一个键是不能准确捕获组合键，所以使用KeyDown 是不能准确判断出的，要通过KeyUp 事件来判定 ）</p>
<h4 id="5-Web安全之XSS攻防"><a href="#5-Web安全之XSS攻防" class="headerlink" title="5.Web安全之XSS攻防"></a>5.Web安全之XSS攻防</h4><p><strong>跨站脚本攻击(Cross Site Scripting)</strong>，缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。</p>
<p><a href="https://blog.csdn.net/ganyingxie123456/article/details/70230486" target="_blank" rel="noopener">原文</a></p>
<h4 id="6-innerText和innerHTML之间的转义"><a href="#6-innerText和innerHTML之间的转义" class="headerlink" title="6.innerText和innerHTML之间的转义"></a>6.innerText和innerHTML之间的转义</h4><p>innerText:包含子结点的所有文本内容</p>
<p>innerHTML：不只是文本内容，还包含子节点的标签</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(temp.textContent != <span class="literal">undefined</span> ) ? (temp.textContent = html) : (temp.innerText = html);</span><br></pre></td></tr></table></figure>

<p>textContent：谷歌,火狐支持,IE8不支持；innerText：谷歌,火狐,IE8都支持<br>判断这个属性的类型 是不是undefined,就知道浏览器是否支持</p>
<p>innerHTML在左边时，字符串会被自动编码如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">innerHTML=&amp;lt;b&amp;gt;<span class="comment">//会被转为&lt;b&gt;</span></span><br><span class="line">str=innerHTML;<span class="comment">//innerHTML中的&lt;b&gt;标签被转为&amp;lt;b&amp;gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="7-相关方法"><a href="#7-相关方法" class="headerlink" title="7.相关方法"></a>7.相关方法</h4><p>select() 方法用于选取input密码域或文本域中的文本</p>
<p>focus()方法用于使输入框获得焦点</p>
<p>对于<select>标签：</p>
<p>selectedIndex:设置或返回下拉列表中被选项目的索引号。</p>
<p><strong>方法：</strong></p>
<p>add():向下拉列表添加一个选项。</p>
<p>blur():从下拉列表移开焦点。</p>
<p>focus():在下拉列表上设置焦点。</p>
<p>remove():从下拉列表中删除一个选项。</p>
<h4 id="8-获取上一个节点和下一个节点"><a href="#8-获取上一个节点和下一个节点" class="headerlink" title="8.获取上一个节点和下一个节点"></a>8.获取上一个节点和下一个节点</h4><p>previousSibling 属性返回元素节点之前的兄弟节点（包括文本节点、注释节点）；</p>
<p>previousElementSibling 属性只返回元素节点之前的兄弟元素节点（不包括文本节点、注释节点）；</p>
<p>nextSibling 属性返回元素节点之后的兄弟节点（包括文本节点、注释节点）；</p>
<p>nextElementSibling 属性只返回元素节点之后的兄弟元素节点（不包括文本节点、注释节点）；</p>
<h4 id="9-innerHTML和outerHTML"><a href="#9-innerHTML和outerHTML" class="headerlink" title="9.innerHTML和outerHTML"></a>9.innerHTML和outerHTML</h4><p>innerHTML 设置或获取位于对象起始和结束标签内的HTML</p>
<p>outerHTML设置或获取对象及其内容的HTML形式</p>
<h4 id="10-html中的name，id和value"><a href="#10-html中的name，id和value" class="headerlink" title="10.html中的name，id和value"></a>10.html中的name，id和value</h4><p><strong>value 和 name</strong></p>
<p>1.name是控件的名称（多个控件可以取同一个名称），value是控件的值</p>
<p>2.并不是所有控件的value都会显示出来，比如 checkbox, radio, hidden；</p>
<p>3.定义控件的 name和value 就可以在服务器上获取这个控件和它的值;</p>
<p>4.你没看到 submit 的name，并不表示浏览器忽略了它的 name，在提交之前它也被浏览器定义了 name，在服务器上一样可以得到它的 name 和 value；</p>
<p>5.控件不定义name/value也可以显示，只是为了方便在服务器接收和区别，才定义它的 name/value，当然按钮的 value 不光是存放它的值，也用来显示</p>
<p><a href="https://www.cnblogs.com/jamesf/p/4751722.html" target="_blank" rel="noopener">name 和id</a></p>
<h4 id="11-SVG"><a href="#11-SVG" class="headerlink" title="11.SVG"></a>11.SVG</h4><h5 id="11-1-XML：是独立于软件和硬件的信息传输工具。"><a href="#11-1-XML：是独立于软件和硬件的信息传输工具。" class="headerlink" title="11.1 XML：是独立于软件和硬件的信息传输工具。"></a>11.1 XML：是独立于软件和硬件的信息传输工具。</h5><p><strong>(1)XML和HTML：</strong></p>
<p>XML 被设计用来传输和存储数据。HTML 被设计用来显示数据</p>
<p>XML没有任何行为</p>
<p>XML仅仅是纯文本</p>
<p>XML的标签是没有预定义的，可以发明自己的标签</p>
<p><strong>（2）XML的用途</strong></p>
<p>XML把数据从HTML分离；XML简化数据共享，简化数据传输，简化平台变更，使数据更有用，用于创建新的Internet语言</p>
<p><strong>（3）XML验证：DTD</strong>（document type definition）</p>
<p>DTD 的作用是定义 XML 文档的结构。它使用一系列合法的元素来定义文档结构：</p>
<p><strong>（4）如何通过JS读写XML</strong></p>
<h5 id="11-2-SVG"><a href="#11-2-SVG" class="headerlink" title="11.2 SVG"></a>11.2 SVG</h5><p>SVG 是使用 XML 来描述二维图形和绘图程序的语言。</p>
<p>SVG 文件可通过以下标签嵌入 HTML 文档：<embed>、<object> 或者 <iframe>。</p>
<p><embed>标签定义嵌入的内容，比如插件，使H5中的新标签</p>
<p>SVG的代码可以直接嵌入到HTML页面中，或您可以直接链接到SVG文件。</p>
<h5 id="11-3-JS动态写入SVG："><a href="#11-3-JS动态写入SVG：" class="headerlink" title="11.3 JS动态写入SVG："></a>11.3 JS动态写入SVG：</h5><p><strong>外部SVG：</strong></p>
<p>（1）通过object、embed或者iframe标签将SVG文件引入到HTML页面:其中的内容会有完全属于自己的document对象，可以用<strong>getSVGDocument()</strong>方法获取SVG文档对象</p>
<p>（2）如果使用object或iframe引入SVG文档，除了<code>getSVGDocument()</code>，还可以使用<code>contentDocument</code>属性来获取其引入文档对应的document对象。区别在于如果是引入的不是SVG文件，而是XML或者HTML等等，<code>contentDocuement</code>依然会返回对象，而<code>getSVGDocument()</code>则返回<code>null</code>。</p>
<p>（3）SVG元素对象都需要通过调用<a href="https://developer.mozilla.org/en-US/docs/Web/API/element.setAttribute" target="_blank" rel="noopener"><code>setAttribute()</code></a>方法来设定属性值</p>
<p><strong>要求：满足同源策略（Same-origin-policy）</strong></p>
<p>同源策略指的是三个相同</p>
<ul>
<li>协议相同</li>
<li>域名相同</li>
<li>端口相同</li>
</ul>
<p>如果非同源，那么以下的行为将会受到限制；1，<strong>cookie，localStorage</strong>     2，<strong>ajax</strong> </p>
<h4 id="12-AJAX"><a href="#12-AJAX" class="headerlink" title="12.AJAX"></a>12.AJAX</h4><h5 id="XMLHttpRequest对象的三个属性："><a href="#XMLHttpRequest对象的三个属性：" class="headerlink" title="XMLHttpRequest对象的三个属性："></a>XMLHttpRequest对象的三个属性：</h5><p>onreadystatechange:存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。</p>
<p>readyState:存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。</p>
<p>0: 请求未初始化</p>
<p>1: 服务器连接已建立</p>
<p>2: 请求已接收</p>
<p>3: 请求处理中</p>
<p>4: 请求已完成，且响应已就绪</p>
<p>status:200: “OK”;404: 未找到页面</p>
<p>xmlhttp.responseText:返回的文本文件</p>
<p>xmlhttp.open()</p>
<p>xmlhttp.send()</p>
<h4 id="13-HTML5-本地存储五种方案"><a href="#13-HTML5-本地存储五种方案" class="headerlink" title="13 HTML5 本地存储五种方案"></a>13 HTML5 本地存储五种方案</h4><h5 id="13-1-Web-Storage-API"><a href="#13-1-Web-Storage-API" class="headerlink" title="13.1 Web Storage API"></a>13.1 Web Storage API</h5><p>源：origin，同源策略</p>
<p><strong>（1）localStorage：</strong></p>
<p><code>localStorage</code> 中的键值对总是以字符串的形式存储。</p>
<p><code>localStorage.setItem()</code></p>
<p><code>localStorage.getItem()</code></p>
<p><code>localStorage.removeItem()</code></p>
<p><code>localStorage.clear()</code></p>
<p><strong>（2）sessionStorage：</strong></p>
<p><strong>（3）通过StorageEvent响应存储的变化</strong></p>
<p>无论何时，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Storage" target="_blank" rel="noopener"><code>Storage</code></a> 对象发生变化时（即创建/更新/删除数据项时，重复设置相同的键值不会触发该事件，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Storage/clear" target="_blank" rel="noopener"><code>Storage.clear()</code></a> 方法至多触发一次该事件），<code>StorageEvent</code> 事件会触发。在同一个页面内发生的改变不会起作用——在<strong>相同域名</strong>下的<strong>其他</strong>页面（如一个新标签或 iframe）发生的改变才会起作用。在其他域名下的页面不能访问相同的 Storage 对象。</p>
<p>当前页面使用的storage被其他页面修改时会触发StorageEvent事件. </p>
<p>**[事件在同一个域下的不同页面之间触发，即在A页面注册了storge的监听处理，只有在跟A同域名下的B页面操作storage对象，A页面才会被触发storage事件] **</p>
<p>事件属性：</p>
<p><img src="E:%5CFront-End-Note%5Cimage%5C1570695196(1).png" alt="1570695196(1)"></p>
<h5 id="13-2-Cookie-曾一度用于客户端存储，逐渐被淘汰"><a href="#13-2-Cookie-曾一度用于客户端存储，逐渐被淘汰" class="headerlink" title="13.2 Cookie(曾一度用于客户端存储，逐渐被淘汰)"></a>13.2 Cookie(曾一度用于客户端存储，逐渐被淘汰)</h5><p><strong>（1）HTTP Cookie（也叫Web Cookie或浏览器Cookie）</strong></p>
<p>Cookie主要用于以下三个方面：</p>
<p><strong>会话状态管理</strong>（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</p>
<p><strong>个性化设置</strong>（如用户自定义设置、主题等）</p>
<p><strong>浏览器行为跟踪</strong>（如跟踪分析用户行为等）</p>
<p><strong>HttpOnly</strong>:为避免跨域脚本 (XSS) 攻击，通过JavaScript的 Document.cookie API无法访问带有 HttpOnly 标记的Cookie，它们<strong>只应该发送给服务端</strong>。如果包含服务端 Session 信息的 Cookie 不想被客户端 JavaScript 脚本调用，那么就应该为其设置 HttpOnly 标记。</p>
<p>JavaScript可以通过跨站脚本攻击（XSS）的方式来窃取Cookie。</p>
<p><strong>安全：</strong></p>
<p>会话劫持和XSS；跨站请求伪造（CSRF）</p>
<p><strong>（2）document.cookie</strong></p>
<p><code>docCookies.setItem(name, value[, end[, path[, domain[, secure]]]])</code></p>
<p><code>docCookies.getItem(name)</code></p>
<p><code>docCookies.removeItem(name[, path],domain)</code></p>
<p><code>docCookies.hasItem(name)</code></p>
<p><code>docCookies.keys()</code></p>
<p>路径限制并<strong>不能</strong>阻止从其他路径访问cookie. 使用简单的DOM即可轻易地绕过限制(比如创建一个指向限制路径的, 隐藏的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe" target="_blank" rel="noopener">iframe</a>, 然后访问其 <code>contentDocument.cookie</code> 属性). 保护cookie不被非法访问的唯一方法是将它放在另一个域名/子域名之下, 利用<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener">同源策略</a>保护其不被读取.</p>
<p>document.cookie的键和值中不能使用；，=以及空格，要用escape()函数进行编码，取出值后用unescape()解码</p>
<h5 id="13-3-IndexedDB"><a href="#13-3-IndexedDB" class="headerlink" title="13.3 IndexedDB"></a>13.3 IndexedDB</h5><h4 id="14-event-preventDefault"><a href="#14-event-preventDefault" class="headerlink" title="14.event.preventDefault()"></a>14.event.preventDefault()</h4><p>告诉<a href="https://developer.mozilla.org/en-US/docs/Glossary/user_agent" target="_blank" rel="noopener">user agent</a>：如果此事件没有被显式处理，那么它默认的动作也不要做（因为默认是要做的）。</p>
<p><code>event.stopPropagation()</code>:阻止捕获和冒泡阶段中当前事件的进一步传播</p>
<h4 id="15-进程与线程"><a href="#15-进程与线程" class="headerlink" title="15.进程与线程"></a>15.进程与线程</h4><p><strong>进程：</strong>CPU资源分配的最小单位，是能拥有资源和独立运行的最小单位（任一时刻，CPU总是运行一个进程，其他进程处于非运行状态）</p>
<p><strong>线程：</strong>CPU调度的最小单位，是建立在进程基础上的一次程序运行单位，属于单个的程序执行流，是一个进程中代码的不同执行路线</p>
<p>一个进程中可以拥有多个线程，同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）及一些进程级的资源。虽然不同进程之间也可以通信，不过代价较大。（可以在电脑的任务管理器中查看进程）</p>
<p><strong>浏览器是多进程的</strong></p>
<p><strong>概述：</strong></p>
<p>（1）浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu和内存）</p>
<p>（2）每打开一个tab页，就创建了一个独立的浏览器进程，每个进程相互独立</p>
<p><strong>多进程的好处：</strong></p>
<p>（1）不会因为一个tab页崩溃，导致其他tab页也被影响</p>
<p>（2）相对于线程，进程之间是不共享资源和地址空间的，所以也不会存在太多的安全问题</p>
<p><strong>浏览器包含的进程种类：</strong></p>
<p>（1）Browser进程——浏览器的主进程，负责协调、主控，只有一个</p>
<p>（2）第三方插件进程——每种类型的插件对应一个进程，仅当使用该插件时才创建</p>
<p>（3）GPU进程——最多一个，用于3D绘制等</p>
<p>（4）浏览器渲染进程——也就是浏览器内核</p>
<p><strong>浏览器内核是多线程的：</strong></p>
<p><strong>常驻线程：</strong></p>
<p>（1）GUI 渲染线程——负责渲染浏览器界面，解析HTML，CSS，当界面需要重排、重绘或由于某种操作引发回流时,该线程就会执行。<strong>但需要注意 GUI渲染线程与JS引擎是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</strong></p>
<p>（2）JavaScript引擎线程——负责处理Javascript脚本程序：是基于事件驱动单线程执行的，JS引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个JS线程在运行JS程序。</p>
<p>（3）定时触发器线程——处理setInterval与setTimeout任务</p>
<p>（4）事件触发线程——处理事件消息，控制事件循环：当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可来自JavaScript引擎当前执行的代码块如setTimeOut、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。</p>
<p>（5）异步http请求线程——处理XMLHttpRequest异步请求</p>
<p><strong>js为什么会阻塞页面加载</strong></p>
<p>（1）由于GUI渲染线程与JavaScript执行线程是互斥的关系，当浏览器在执行JavaScript程序的时候，GUI渲染线程会被保存在一个队列中，直到JS程序执行完成，才会接着执行。</p>
<p>（2）因此如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉</p>
<p><strong>JS是单线程的</strong></p>
<p>引用阮一峰老师的回答 —&gt;  JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p>
<p>所以，为了避免复杂性，从一诞生，JavaScript就是单线程。</p>
<p><strong>单线程和异步</strong> </p>
<p>看过很多关于 JavaScript 单线程与异步的介绍，大多数都引用这一类例子来说明：单线程就是排队，前一个任务不完成后一个就不能开始，也就是常说的串行。 饭店点餐，所有人排队，A顾客点完之后，厨房开始做，做完后A领到餐后，B再开始点餐，厨房又开始做…周而复始，这就是同步，点餐的时候厨房是闲着的，做菜的时候前台是闲着的。即单线程。所有人都能够很好的理解，这样做效率太低了！</p>
<p>　　换个思路，A点完餐后，到一旁等着，服务员将菜单递给厨房，厨房开始做，然后继续服务B顾客，当A顾客的餐做好之后，A来队伍里插个队，把餐领走。 听到这里，效率高了很多嘛，整个餐厅没有浪费一点工作力，大家都各司其事。然后作者就下了结论，这就是 JavaScript 的单线程与异步。</p>
<p><strong>JS中的异步操作：</strong></p>
<p>（1）定时器都是异步操作</p>
<p>（2）事件绑定都是异步操作</p>
<p>（3）AJAX中一般我们都采用异步操作（也可以同步）</p>
<p>（4）回掉函数可以理解为异步（不是严谨的异步操作）</p>
<h4 id="17-Flash和JS通过什么类如何交互？"><a href="#17-Flash和JS通过什么类如何交互？" class="headerlink" title="17.Flash和JS通过什么类如何交互？"></a>17.Flash和JS通过什么类如何交互？</h4><p>Flash提供了<strong>ExternalInterface</strong>接口与JavaScript通信，ExternalInterface有两个方法，<strong>call和addCallback</strong>：</p>
<ul>
<li><strong>ExternalInterface.addCallback</strong>(“在js里可调用的flash方法名”,flash内方法) //在flash中通过这个方法公开 在js中可调用的flash内的方法;</li>
<li><strong>ExternalInterface.call</strong>(“js方法”,传给js的参数) //在flash里调用js里的方法</li>
</ul>
<h4 id="18-apply和call：提供参数的方式不同"><a href="#18-apply和call：提供参数的方式不同" class="headerlink" title="18. apply和call：提供参数的方式不同"></a>18. apply和call：提供参数的方式不同</h4><p>（1）基本使用方法：可以只写一次这个方法然后在另一个对象中继承它，而不用在新对象中重复写该方法。</p>
<p><code>Function.apply(obj,argu)</code></p>
<p>obj:这个对象将代替Function类里的this对象，即调用这个函数的对象（非严格模式下如果用null或undefined则会替代为全局环境）</p>
<p>argu:要传入函数的参数数组，也可以是类数组</p>
<p><code>Function.call(obj,[param1[,param2[,…[,paramN]]]])</code></p>
<p>后面是要传入函数的参数列表</p>
<p><strong>（2）apply的一些巧妙用法</strong></p>
<blockquote>
<p><strong>用apply将数组添加到另一个数组</strong></p>
<p>不同于concat(另建了一个副本，并没有改变原数组)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> arr1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">&gt;<span class="keyword">var</span> arr2=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">&gt;arr1.push.apply(arr1,arr2);</span><br></pre></td></tr></table></figure>

<p><strong>使用apply和内置函数</strong></p>
<p>如：<code>Math.max()</code>,<code>Math.min()</code></p>
<p><strong>使用apply来链接构造器：</strong></p>
</blockquote>
<h4 id="19-bind"><a href="#19-bind" class="headerlink" title="19.bind"></a>19.bind</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://holichang.github.io/2020/03/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="柴郡猫">
      <meta itemprop="description" content="向死而生的生命都在热烈地生长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cheshire Cat">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">计算机网络</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-12 13:27:46 / 修改时间：13:30:30" itemprop="dateCreated datePublished" datetime="2020-03-12T13:27:46+08:00">2020-03-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h3 id="笔记："><a href="#笔记：" class="headerlink" title="笔记："></a>笔记：</h3><h4 id="1-端口"><a href="#1-端口" class="headerlink" title="1.端口"></a>1.端口</h4><p><strong>什么是端口：</strong></p>
<p>本地操作系统会给那些有需求的进程分配协议端口 （protocal port，即我们常说的端口），每个协议端口由一个正整数标识，如：80，139，445，等等。当目的主机接收到数据报后，将根据报文首部的目的端口 号，把数据发送到相应端口，而与此端口相对应的那个进程将会领取数据并等待下一组数据的到来。</p>
<p><strong>端口分类：</strong></p>
<p>  在Internet上，按照协议类型分类，端口被分为TCP端口和UDP端口两类，虽然他们都用正整数标识，但这并不会引起歧义，比如TCP的80端口和UDP的80端口，因为数据报在标明端口的同时，还将标明端口的类型。 </p>
<p>（TCP：传输控制协议：是基于连接的协议，也就是说在正式收发数据前，必须和对方建立可靠的连接，进行“三次握手”</p>
<p>   UDP：用户数据报协议，是面向非连接的协议i，不与对方建立连接，而是直接就把数据包发送过去，适用于一次只传送少量数据，对可靠性要求不高的应用环境，如“ping”命令和QQ）</p>
<p>　　从端口的分配来看，端口被分为固定端口和动态端口两大类（一些教程还将极少被用到的高端口划分为第三类：私有端口）：<br>　　固定端口（0－1023）：<br>　 　使用集中式管理机制，即服从一个管理机构对端口的指派，这个机构负责发布这些指派。由于这些端口紧绑于一些服务，所以我们会经常扫描这些端口来判断对方 是否开启了这些服务，如TCP的21（ftp），80（http），139（netbios），UDP的7（echo），69（tftp）等等一些大家熟 知的端口；<br>　　动态端口（1024－49151）：<br>　　这些端口并不被固定的捆绑于某一服务，操作系统将这些端口动态的分配给各个进程， 同一进程两次分配有可能分配到不同的端口。不过一些应用程序并不愿意使用操作系统分配的动态端口，他们有其自己的‘商标性’端口，如oicq客户端的 4000端口，木马冰河的7626端口等都是固定而出名的。</p>
<h4 id="2-127-0-0-1与0-0-0-0"><a href="#2-127-0-0-1与0-0-0-0" class="headerlink" title="2.127.0.0.1与0.0.0.0"></a>2.127.0.0.1与0.0.0.0</h4><p><strong>IP地址表示：</strong></p>
<p>IP地址由两个部分组成，net-id和host-id，即网络号和主机号。<br>net-id:表示ip地址所在的网络号。<br>host-id：表示ip地址所在网络中的某个主机号码。<br>即：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IP-address ::= &#123; <span class="tag">&lt;<span class="name">Network-number</span>&gt;</span>, <span class="tag">&lt;<span class="name">Host-number</span>&gt;</span> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>IP地址分类</strong></p>
<p>IP地址一共分为5类，即A～E，它们分类的依据是其net-id所占的字节长度以及网络号前几位。 </p>
<p>A类地址:网络号占1个字节。网络号的第一位固定为0。 </p>
<p>B类地址：网络号占2个字节。网络号的前两位固定为10。 </p>
<p>C类地址：网络号占3个字节。网络号的前三位固定位110。 </p>
<p>D类地址：前四位是1110，用于多播(multicast)，即一对多通信。 </p>
<p>E类地址：前四位是1111，保留为以后使用。 </p>
<p>其中，ABC三类地址为单播地址（unicast),用于一对一通信，是最常用的。</p>
<p><img src="D:%5CFront-End-Note%5Cimage%5C1571194707(1).png" alt="1571194707(1)"></p>
<p><strong>特殊IP地址</strong></p>
<p>特殊IP地址就是用来做一些特殊的事情。RFC1700中定义了以下特殊IP地址。 </p>
<p>{0,0}:网络号和主机号都全部为0，表示“本网络上的本主机”，只能用作源地址。 </p>
<p>{0，host-id}:本网络上的某台主机。只能用作源地址。 </p>
<p>{-1,-1}：表示网络号和主机号的所有位上都是1（二进制），用于本网络上的广播，只能用作目的地址，发到该地址的数据包不能转发到源地址所在网络之外。 </p>
<p>{net-id,-1}:直接广播到指定的网络上。只能用作目的地址。 </p>
<p>{net-id,subnet-id,-1}:直接广播到指定网络的指定子网络上。只用作目的地址。 </p>
<p>{net-id,-1,-1}:直接广播到指定网络的所有子网络上。只能用作目的地址。 </p>
<p>{127，}:即网络号为127的任意ip地址。都是内部主机回环地址(loopback),永远都不能出现在主机外部的网络中。</p>
<p><strong>127.0.0.1与0.0.0.0的共同点：</strong></p>
<ol>
<li>都属于特殊地址。 </li>
<li>都属于A类地址。 </li>
<li>都是IPV4地址。</li>
</ol>
<p><strong>127.0.0.1：</strong>本地loopback(回环)地址，代表本地主机（在window和linux上等价于localhost）</p>
<p><strong>0.0.0.0:</strong>IPV4中，0.0.0.0地址被用于表示一个无效的，未知的或者不可用的目标。 </p>
<ul>
<li><p>在服务器中，0.0.0.0指的是本机上的所有IPV4地址，如果一个主机有两个IP地址，192.168.1.1 和 10.1.2.1，并且该主机上的一个服务监听的地址是0.0.0.0,那么通过两个ip地址都能够访问该服务。 </p>
</li>
<li><p>在路由中，0.0.0.0表示的是默认路由，即当路由表中没有找到完全匹配的路由的时候所对应的路由。</p>
</li>
<li><p>用途：</p>
<ul>
<li>当一台主机还没有被分配一个IP地址的时候，用于表示主机本身。（DHCP分配IP地址的时候）</li>
<li>用作默认路由，表示”任意IPV4主机”。</li>
<li>用来表示目标机器不可用。</li>
<li>用作服务端，表示本机上的任意IPV4地址。</li>
</ul>
</li>
</ul>
<p>0.0.0.0是最特殊的一个ip地址，代表的是本机所有ip地址，不管你有多少个网口，多少个ip，如果监听本机的0.0.0.0上的端口，就等于监听机器上的所有ip端口。换句话说，就是只要数据报目的地址是你机器上的一个ip地址，那么就能被接受。</p>
<p>IPv4的回路地址为: 127.0.0.1</p>
<p>IPv6的回路地址为 : 000:0000:0000:0000:0000:0000:0000:0001 可以简写为 ::1。 　</p>
<p>（<a href="https://www.cnblogs.com/lsgxeva/p/9209266.html" target="_blank" rel="noopener">IPV6格式</a> ）</p>
<h4 id="3-Http与Https"><a href="#3-Http与Https" class="headerlink" title="3.Http与Https"></a>3.Http与Https</h4><p><strong>Https:</strong></p>
<p>Https设计目标：</p>
<p>(1)数据保密性：保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么  。</p>
<p>(2)数据完整性：及时发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收 。</p>
<p>(3)身份校验安全性：保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方  。</p>
<p>Https原理：</p>
<p>① 客户端将它所支持的算法列表和一个用作产生密钥的随机数发送给服务器；</p>
<p>② 服务器从算法列表中选择一种加密算法，并将它和一份包含服务器公用密钥的证书发送给客户端；该证书还包含了用于认证目的的服务器标识，服务器同时还提供了一个用作产生密钥的随机数；</p>
<p>③ 客户端对服务器的证书进行验证（有关验证证书，可以参考数字签名），并抽取服务器的公用密钥；然后，再产生一个称作 pre_master_secret 的随机密码串，并使用服务器的公用密钥对其进行加密（参考非对称加 / 解密），并将加密后的信息发送给服务器；</p>
<p>④ 客户端与服务器端根据 pre_master_secret 以及客户端与服务器的随机数值独立计算出加密和 MAC密钥（参考 DH密钥交换算法） ；</p>
<p>⑤ 客户端将所有握手消息的 MAC 值发送给服务器；</p>
<p>⑥ 服务器将所有握手消息的 MAC 值发送给客户端。</p>
<h5 id="3-1-区别"><a href="#3-1-区别" class="headerlink" title="3.1 区别"></a>3.1 区别</h5><p>（1）https协议需要到CA  （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。(原来网易官网是http，而网易邮箱是https。)</p>
<p>（2）http是超文本传输协议，信息是<strong>明文传输</strong>，https则是具有安全性的<strong>ssl加密传输</strong>协议。</p>
<p>（3）http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
<p>（4）http的连接很简单，是无状态的。Https协议是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)</p>
<p><strong>3.2 Https相对于Http的改进：</strong></p>
<p>（1）双向身份认证：客户端和服务端在传输数据之前，会通过基于X.509证书对双方进行身份认证</p>
<p>3次握手：</p>
<p>第一次：客户端发起 SSL 握手消息给服务端要求连接。</p>
<p>第二次：服务端将证书发送给客户端。</p>
<p>客户端检查服务端证书，确认是否由自己信任的证书签发机构签发。 如果不是，将是否继续通讯的决定权交给用户选择 ( 注意，这里将是一个安全缺陷 )。如果检查无误或者用户选择继续，则客户端认可服务端的身份。</p>
<p>第三次：服务端要求客户端发送证书，并检查是否通过验证。失败则关闭连接，认证成功则从客户端证书中获得客户端的公钥，一般为1024位或者 2048位。到此，服务器客户端双方的身份认证结束，双方确保身份都是真实可靠的。</p>
<p>（2）数据传输的机密性：客户端和服务端在开始传输数据之前，会协商传输过程需要使用的加密算法</p>
<p>（3）防止重放攻击</p>
<p><strong>3.2 加密算法和SSL协议</strong></p>
<p>SSL协议：Https的安全基础</p>
<p>SSL协议位于<a href="https://baike.baidu.com/item/TCP/IP协议" target="_blank" rel="noopener">TCP/IP协议</a>与各种应用层协议之间，为<a href="https://baike.baidu.com/item/数据通讯" target="_blank" rel="noopener">数据通讯</a>提供安全支持。SSL协议可分为两层：SSL记录协议（SSL Record Protocol），它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。SSL握手协议（SSL Handshake Protocol），它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p>
<p><strong>SSL提供服务</strong><br>(1)认证用户和服务器，确保数据发送到正确的客户机和服务器；</p>
<p>(2)加密数据以防止数据中途被窃取；</p>
<p>(3)维护数据的完整性，确保数据在传输过程中不被改变。</p>
<p><strong>SSL工作流程</strong><br><strong>服务器认证阶段：</strong></p>
<p>(1)客户端向服务器发送一个开始信息“Hello”以便开始一个新的会话连接；</p>
<p>(2)服务器根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的“Hello”信息时将包含生成主密钥所需的信息；</p>
<p>(3)客户根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器；</p>
<p>(4)服务器回复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。</p>
<p><strong>用户认证阶段：</strong>在此之前，服务器已经通过了客户认证，这一阶段主要完成对客户的认证。经认证的服务器发送一个提问给客户，客户则返回（数字）签名后的提问和其公开密钥，从而向服务器提供认证。</p>
<p><strong>SSL协议提供的安全通道有以下三个特性：</strong></p>
<p>机密性：SSL协议使用密钥加密通信数据。</p>
<p>可靠性：服务器和客户都会被认证，客户的认证是可选的。</p>
<p>完整性：SSL协议会对传送的数据进行完整性检查。</p>
<p><strong>服务器证书</strong>(server certificates)是SSL数字证书的一种形式，意指通过提交数字证书来证明您的身份或表明您有权访问在线服务。再者简单来说，通过使用服务器证书可为不同站点提供身份鉴定并保证该站点拥有高强度加密安全。是组成Web服务器的SSL安全功能的唯一的数字标识。通过相互信任的第三方组织获得，并为用户 提供验证您Web站点身份的手段。服务器证书包含详细的身份验证信息，如服务器内容附属的组织、颁发证书的组织以及称为公开密钥的唯一的身份验证文件。</p>
<h5 id="3-3Https的优缺点"><a href="#3-3Https的优缺点" class="headerlink" title="3.3Https的优缺点"></a>3.3Https的优缺点</h5><p><strong>优点：</strong></p>
<p>（1）使用Https协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。</p>
<p>（2）Https协议是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中被窃取、修改，确保数据的完整性。</p>
<p>（3）Https是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。<br><strong>缺点：</strong></p>
<p>（1）Https协议握手阶段比较费时，会使页面的加载时间延长近。</p>
<p>（2）Https连接缓存不如Http高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响。</p>
<p>（3）Https协议的安全是有范围的，在黑客攻击、拒绝服务攻击和服务器劫持等方面几乎起不到什么作用。</p>
<p>（4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</p>
<p>（5）成本增加。部署 Https后，因为 Https协议的工作要增加额外的计算资源消耗，例如 SSL 协议加密算法和 SSL 交互次数将占用一定的计算资源和服务器成本。</p>
<p>（6）Https协议的加密范围也比较有限。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。<br><strong>3.4 Https的连接过程</strong></p>
<p><img src="D:%5CFront-End-Note%5Cimage%5Chttps%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B.jpg" alt="https连接过程"></p>
<p>过程讲解：</p>
<p>图片中的过程是按8个步骤分的，但是网上有更详细的步骤，所以我把详细的过程和这个图片配在一起。</p>
<p>①客户端的浏览器向服务器发送请求，并传送客户端SSL 协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。</p>
<p>②服务器向客户端传送SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。</p>
<p>③客户端利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，发行服务器证书的CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行第四步。</p>
<p>④用户端随机产生一个用于通讯的“对称密码”，然后用服务器的公钥（服务器的公钥从步骤②中的服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。</p>
<p>⑤如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的“预主密码”一起传给服务器。</p>
<p>⑥如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的CA 是否可靠，发行CA 的公钥能否正确解开客户证书的发行CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的“预主密码”，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。</p>
<p>⑦服务器和客户端用相同的主密码即“通话密码”，一个对称密钥用于SSL 协议的安全数据通讯的加解密通讯。同时在SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。</p>
<p>⑧客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知服务器客户端的握手过程结束。</p>
<p>⑨服务器向客户端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。</p>
<p>⑩SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。</p>
<h4 id="4-WebSocket-基于HTML5规范"><a href="#4-WebSocket-基于HTML5规范" class="headerlink" title="4.WebSocket(基于HTML5规范)"></a>4.WebSocket(基于HTML5规范)</h4><p>http和https的机制缺陷：</p>
<p>（1）不适用于实时要求高、海量并发的应用</p>
<p>（2）服务器不能主动向客户端推送数据，只能使用轮询，在特定的时间间隔，浏览器自动发出请求将服务器的消息主动拉回来。</p>
<p>（3）http请求header</p>
<h4 id="5-session-记录一系列状态"><a href="#5-session-记录一系列状态" class="headerlink" title="5.session:记录一系列状态"></a>5.session:记录一系列状态</h4><p>session:记录在服务器端</p>
<p>cookie:记录在浏览器端</p>
<p>解释：当访问服务器否个网页的时候，会在服务器端的内存里开辟一块内存，这块内存就叫做session，而这个内存是跟浏览器关联在一起的。这个浏览器指的是浏览器窗口，或者是浏览器的子窗口，意思就是，只允许当前这个session对应的浏览器访问，就算是在同一个机器上新启的浏览器也是无法访问的。而另外一个浏览器也需要记录session的话，就会再启一个属于自己的session</p>
<p>原理：http的非连接性</p>
<p>浏览器与服务器session的一一对应：通过赋予相同的sessionID</p>
<p><strong>session两种实现方式：</strong></p>
<p>（1）放在cookie（临时cookie会在浏览器关闭时消失）里面：当浏览器允许使用cookie时可以通过这种方式</p>
<p>（2）编程使用URL重写：通过<code>response.encodeURL()</code>方法，转码后加上sessionID：当cookie被浏览器禁用时使用</p>
<h4 id="6-关于浏览器中使用JS跨域获取数据"><a href="#6-关于浏览器中使用JS跨域获取数据" class="headerlink" title="6.关于浏览器中使用JS跨域获取数据"></a>6.关于浏览器中使用JS跨域获取数据</h4><p><strong>1.CORS</strong></p>
<p>CORS（Cross-Origin Resource Sharing,跨资源共享），基本思想是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应的成功或失败。即给请求附加一个额外的Origin头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部决定是否给予响应。</p>
<p>完全一致的意思是，域名要相同（<a href="http://www.example.com和example.com不同），协议要相同（http和https不同），端口号要相同（默认是:80端口，它和:8080就不同）。有的浏览器口子松一点，允许端口不同，大多数浏览器都会严格遵守这个限制。">www.example.com和example.com不同），协议要相同（http和https不同），端口号要相同（默认是:80端口，它和:8080就不同）。有的浏览器口子松一点，允许端口不同，大多数浏览器都会严格遵守这个限制。</a></p>
<p><strong>只要 协议 、 域名 、 端口 有任何一个 不同, 都被当作是 不同 的域。</strong></p>
<p><strong>2.document.domain</strong></p>
<p>将页面的 <code>document.domain</code> 设置为相同的值，页面间可以互相访问对方的JavaScript对象。</p>
<p>注意：</p>
<p>不能将值设置为URL中不包含的域；</p>
<p>松散的域名不能再设置为紧绷的域名。</p>
<p><strong>3.图像Ping</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img=<span class="keyword">new</span> Image();</span><br><span class="line"></span><br><span class="line">img.onload=img.onerror=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">img.src=<span class="string">"url?name=value"</span>;</span><br></pre></td></tr></table></figure>

<p>请求数据通过查询字符串的形式发送，响应可以是任意内容，通常是像素图或204响应。</p>
<p>图像Ping最常用于跟踪用户点击页面或动态广告曝光次数。</p>
<p>缺点：</p>
<p>只能发送GET请求；</p>
<p>无法访问服务器的响应文本，只能用于浏览器与服务器间的单向通信。</p>
<p><strong>4.Jsonp</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script=<span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line"></span><br><span class="line">script.src=<span class="string">"url?callback=handleResponse"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(script,<span class="built_in">document</span>.body.firstChild);</span><br></pre></td></tr></table></figure>

<p>JSONP由两部分组成：回调函数和数据</p>
<p>回调函数是接收到响应时应该在页面中调用的函数，其名字一般在请求中指定。</p>
<p>数据是传入回调函数中的JSON数据。</p>
<p>优点：</p>
<p>能够直接访问响应文本，可用于浏览器与服务器间的双向通信。</p>
<p>缺点：</p>
<p>JSONP从其他域中加载代码执行，其他域可能不安全；</p>
<p>难以确定JSONP请求是否失败。</p>
<p><strong>5.Comet</strong></p>
<p>Comet可实现服务器向浏览器推送数据。</p>
<p>Comet是实现方式：长轮询和流</p>
<p>短轮询即浏览器定时向服务器发送请求，看有没有数据更新。</p>
<p>长轮询即浏览器向服务器发送一个请求，然后服务器一直保持连接打开，直到有数据可发送。发送完数据后，浏览器关闭连接，随即又向服务器发起一个新请求。其优点是所有浏览器都支持，使用XHR对象和setTimeout()即可实现。</p>
<p>流即浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性地向浏览器发送数据，页面的整个生命周期内只使用一个HTTP连接。</p>
<p><strong>6.WebSocket</strong></p>
<p>WebSocket可在一个单独的持久连接上提供全双工、双向通信。</p>
<p>WebSocket使用自定义协议，未加密的连接时ws://；加密的链接是wss://。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webSocket=<span class="keyword">new</span> WebSocket(<span class="string">"ws://"</span>);</span><br><span class="line"></span><br><span class="line">webSocket.send(message);</span><br><span class="line"></span><br><span class="line">webSocket.onmessage=<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data=event.data;</span><br><span class="line"></span><br><span class="line">... ....</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>必须给WebSocket构造函数传入绝对URL；</p>
<p>WebSocket可以打开任何站点的连接，是否会与某个域中的页面通信，完全取决于服务器；</p>
<p>WebSocket只能发送纯文本数据，对于复杂的数据结构，在发送之前必须进行序列化JSON.stringify(message))。</p>
<p>优点：</p>
<p>在客户端和服务器之间发送非常少的数据，减少字节开销。</p>
<h4 id="7-文档类型和浏览器模式"><a href="#7-文档类型和浏览器模式" class="headerlink" title="7.文档类型和浏览器模式"></a>7.文档类型和浏览器模式</h4><p><strong>文档类型</strong></p>
<p>  DTD（文档类型定义）是一组机器可读的规则，他们定义 XML 或 HTML 的特定版本中允许有什么，不允许有什么。在解析网页时，浏览器将使用这些规则检查页面的有效性并且采取相应的措施。浏览器通过分析页面的 DOCTYPE 声明来了解要使用哪个 DTD ，由此知道要使用 HTML 的哪个版本。</p>
<p> DOCTYPE 当前有两种风格，严格（ strict ）和过渡（ transitional ）。过渡 DOCTYPE 的目的是帮助开发人员从老版本迁移到新版本。</p>
<p>如果发送具有正确的 MIME 类型的 XHTML 文档，理解 XML 的浏览器将不显示无效的页面。</p>
<p><strong>浏览器模式</strong></p>
<p>  浏览器有两种呈现模式：标准模式和混杂模式（quirks mode）。在标准模式中，浏览器根据规范呈现页面；在混杂模式中，页面以一种比较宽松的向后兼容的方式显示。</p>
<p><strong>DOCTYPE 切换</strong></p>
<p>对于 HTML 4.01 文档，</p>
<ul>
<li>包含严格 DTD 的 DOCTYPE 常常导致页面以标准模式呈现。</li>
<li>包含过度 DTD 和 URI 的 DOCTYPE 也导致页面以标准模式呈现。</li>
<li>但是有过度 DTD 而没有 URI 会导致页面以混杂模式呈现。</li>
<li>DOCTYPE 不存在或形式不正确会导致 HTML 和 XHTML 文档以混杂模式呈现。</li>
</ul>
<h4 id="8-五大主流浏览器及四大内核"><a href="#8-五大主流浏览器及四大内核" class="headerlink" title="8.五大主流浏览器及四大内核"></a>8.五大主流浏览器及四大内核</h4><p>浏览器最重要的部分是浏览器的内核。浏览器内核是浏览器的核心，也称“渲染引擎”，用来解释网页语法并渲染到网页上。浏览器内核决定了浏览器该如何显示网页内容以及页面的格式信息。不同的浏览器内核对网页的语法解释也不同，因此网页开发者需要在不同内核的浏览器中测试网页的渲染效果。</p>
<p>浏览器内核又可以分为两部分：渲染引擎和JS引擎（随着JS引擎越来越独立，内核就倾向于只指渲染引擎）<strong>常见的浏览器内核可以分为四种：Trident,Gecko,Blink,Webkit</strong></p>
<p>（1）IE浏览器内核：Trident内核，也是俗称的IE内核；<br>（2）Chrome浏览器内核：统称为Chromium内核或Chrome内核，以前是Webkit内核，现在是Blink内核；<br>（3）Firefox浏览器内核：Gecko内核，俗称Firefox内核；<br>（4）Safari浏览器内核：Webkit内核；<br>（5）Opera浏览器内核：最初是自己的Presto内核，后来是Webkit，现在是Blink内核；<br>（6）360浏览器、猎豹浏览器内核：IE+Chrome双内核；<br>（7）搜狗、遨游、QQ浏览器内核：Trident（兼容模式）+Webkit（高速模式）；<br>（8）百度浏览器、世界之窗内核：IE内核；<br>（9）2345浏览器内核：以前是IE内核，现在也是IE+Chrome双内核；</p>
<hr>
<h3 id="图解HTTP"><a href="#图解HTTP" class="headerlink" title="图解HTTP"></a>图解HTTP</h3><h4 id="1-了解web及网络基础"><a href="#1-了解web及网络基础" class="headerlink" title="1. 了解web及网络基础"></a>1. 了解web及网络基础</h4><p><strong>1.1 与http关系密切的协议：ip、tcp、dns</strong></p>
<p>IP协议：位于网络层：作用是把各种数据包传送给对方，两个重要条件是IP地址和MAC（Media Access Control Address）地址，IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址，IP地址可以和MAC地址进行配对，IP地址可变换，但MAC地址基本不会更改（ARP协议：Address Resolution Protocol:用于解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址）</p>
<p><strong>1.2 确保可靠性的TCP协议：位于传输层，提供可靠的字节流服务</strong></p>
<p>（1）字节流服务：即将大块数据分割成以报文段为单位的数据包进行管理；</p>
<p>（2）可靠的传输服务是指：能够把数据准确可靠的传给对方，依靠三次握手（发送端首先发送一个带SYN（同步序列编号）标志的数据包给对方，接收端收到后回传一个带有SYN+ACK（确认字符）标志的数据包以示传达确认信息，最后发送端再回传一个带ACK标志的数据包，代表”握手“结束）</p>
<p><strong>1.3 负责域名解析的DNS服务：位于应用层，提供域名到IP地址之间的解析服务</strong></p>
<h4 id="2-简单的HTTP协议"><a href="#2-简单的HTTP协议" class="headerlink" title="2. 简单的HTTP协议"></a>2. 简单的HTTP协议</h4><p><strong>2.1 通过请求和响应的交换达成通信</strong></p>
<p>请求报文：由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成</p>
<p>响应报文：由协议版本、状态码、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成</p>
<p><strong>2.2 HTTP是不保存状态的协议，即无状态协议</strong></p>
<p>即HTTP协议自身不具备保存之前发送过的请求或响应的功能，是为了更快处理大量事务，确保协议的可伸缩性 。（<strong>因此引入cookie</strong>）</p>
<p><strong>2.3 告知服务器意图的HTTP方法</strong>(1.1)</p>
<p>（1）GET：获取资源</p>
<p>（2）POST：传输实体主体</p>
<p>（3）PUT：传输文件：就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求URI指定的位置。但是鉴于HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的Web网站不使用该方法。</p>
<p>（4）HEAD：获得报文首部：用于确认URI的有效性及资源更新的日期时间等</p>
<p>（5）DELETE：删除文件：按照请求URI删除指定的资源（不带验证机制，一般不使用）</p>
<p>（6）OPTIONS：询问支持的方法：用来查询针对请求URI指定的资源支持的方法</p>
<p>（7）TRACE：追踪路径：让Web服务器端将之前的请求通信环回给客户端，客户端通过TRACE方法可以查询发送出去的请求是怎样被加工/篡改的，但是该方法 不常用，易引发XST（Cross-Site Tracing,跨站追踪）攻击</p>
<p>（8）CONNECT：要求用隧道协议连接代理：要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer,安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输</p>
<p><strong>2.4 持久连接节省通信量</strong></p>
<p><img src="C:%5CUsers%5CLihang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200221232507221.png" alt="image-20200221232507221"></p>
<p><strong>持久连接（keep-alive）：</strong>好处在于<strong>减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器的负载，使Web页面显示速度相应提高</strong>，在HTTP 1.1中默认都是持久连接</p>
<p><strong>管线化：</strong>不用等待响应即可发送下一个请求</p>
<p><img src="C:%5CUsers%5CLihang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200221232944521.png" alt="image-20200221232944521"></p>
<h4 id="3-HTTP报文内的HTTP信息"><a href="#3-HTTP报文内的HTTP信息" class="headerlink" title="3. HTTP报文内的HTTP信息"></a>3. HTTP报文内的HTTP信息</h4><p><strong>3.1 请求报文和响应报文的结构：</strong></p>
<p>请求报文：报文首部（请求行+请求首部字段+通用首部字段+实体首部字段+其他）+空行+报文主体</p>
<p>响应报文：报文首部（状态行+响应首部字段+通用首部字段+实体首部字段+其他）+空行+报文主体</p>
<p><strong>3.2 编码提升传输速率</strong></p>
<p><strong>报文主体</strong>和<strong>实体主体</strong>：HTTP报文的主体用于传输请求或响应的实体主体。通常，报文主体等于实体主体，只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。</p>
<p><strong>压缩传输的内容编码</strong></p>
<p><strong>分块传输编码：</strong>在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面</p>
<p><strong>3.3 发送多种数据的多部分对象集合</strong></p>
<p><strong>3.4 获取部分内容的范围请求</strong></p>
<p><strong>3.5 内容协商返回最合适的内容：</strong>内容协商机制：指客户端和服务器端就响应得资源内容进行交涉，然后提供给客户端最为合适的资源（内容协商技术有以下3种类型：服务器驱动协商；客户端驱动协商；透明协商）</p>
<h4 id="4-返回结果的http状态码（常用14种）"><a href="#4-返回结果的http状态码（常用14种）" class="headerlink" title="4. 返回结果的http状态码（常用14种）"></a>4. 返回结果的http状态码（常用14种）</h4><p><strong>状态码类别：</strong></p>
<p>1XX：Information（信息性状态码）：接收的请求正在处理</p>
<p><strong>2XX：Success（成功状态码）：请求正常处理完毕</strong></p>
<p>200 OK：表示从客户端发来的请求在服务器端被正常处理了</p>
<p>204 No Content：表示服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分</p>
<p>206 Partial Content：表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求</p>
<p><strong>3XX：Redirection（重定向状态码）：需要进行附加操作以完成请求</strong></p>
<p>301 Moved Permanently：永久性重定向，该状态码表示请求的资源已被分配了新的URI，<strong>以后</strong>应使用资源现在所指的URI</p>
<p>302 Found：临时性重定向，该状态码表示请求的资源已被分配了新的URI，希望用户<strong>本次</strong>能使用新的URI访问</p>
<p>303 See Other：与302状态码有着相同功能，但303状态码明确表示客户端应当采用GET方法获取资源，这点与302有区别</p>
<p>304 Not Modified（与重定向无关）：表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况，不包含任何响应的主体部分(<strong>如协商缓存机制中的：If-Modified-Since和If-None-Match</strong>)</p>
<p>307 Temporary Redirect（临时重定向）：与302有着相同含义，遵守浏览器标准，不会从POST变为GET</p>
<p><strong>4XX：Client Error（客户端错误状态码）：服务器无法处理请求</strong></p>
<p>400 Bad Request：表示请求报文中存在语法错误</p>
<p>401 Unauthorized：表示发送的请求需要有通过HTTP认证的认证信息，另外若之前已进行过一次HTTP请求，则表示用户认证失败</p>
<p>403 Forbidden：表明对请求资源的访问被服务器拒绝了</p>
<p>404 Not Found：表明服务器上无法找到请求的资源（也可以在服务器端拒绝请求且不想说明理由时使用）</p>
<p>412 Precondition Failed :先决条件失败</p>
<p><strong>5XX：Server Error（服务器错误状态码）：服务器处理请求出错</strong></p>
<p>500 Internal Server Error：该状态码表示服务器端在执行请求时发生了错误</p>
<p>503 Service Unavailable：表明服务器端暂时处于超负载或正在进行停机维护，现在无法处理请求</p>
<h4 id="5-与http协作的web服务器"><a href="#5-与http协作的web服务器" class="headerlink" title="5. 与http协作的web服务器"></a>5. 与http协作的web服务器</h4><p>一台Web服务器可搭建多个独立域名的Web网站，也可作为通信路径上的中转服务器提升传输效率</p>
<p><strong>5.1 通信数据转发程序：代理、网关、隧道：</strong></p>
<p><strong>代理：</strong>是一种有转发功能的应用程序（每次通过代理服务器转发请求或响应时，会追加写入Via首部信息）</p>
<p>使用代理服务器的理由：利用缓存技术减少网络带宽流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的（<strong>透明代理和非透明代理（如缓存代理）</strong>）</p>
<p><strong>网关：</strong>网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。网关的工作机制与代理十分相似，而网关能使通信线路上的服务器提供非HTTP协议服务（<strong>利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保传输安全</strong>）</p>
<p><strong>隧道：</strong>可按要求建立起一条与其他服务器通信的通信线路，届时使用SSL等加密手段进行通信。（<strong>目的是确保客户端和服务器端能进行安全的通信</strong>）通过隧道的传输，可以和远距离的服务器安全通信，隧道本身是透明的，客户端不用在意隧道的存在</p>
<p><strong>5.2 缓存资源</strong> </p>
<p>（1）缓存在缓存服务器上</p>
<p>（2）缓存在客户端浏览器中</p>
<blockquote>
<p>http缓存机制：</p>
<p>HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，可将其分为两大类（强制缓存，对比缓存），可同时存在。</p>
<p>区别:强制缓存如果生效，不需要和服务器进行交互，而对比缓存无论是否生效都要与服务器发生交互，且强制缓存优先级高于对比缓存。</p>
<blockquote>
<p>强制缓存：</p>
<p>问题：怎么判断缓存数据是否失效？</p>
<p>在没有缓存数据的时候，浏览器向服务器请求数据时，服务器会将数据和缓存规则一并返回，缓存规则包含在响应首部中。在强制缓存中，响应header会有两个字段来标明失效规则<strong>Expires **（http1.0）/</strong>Cache-Control**(http1.1)</p>
<blockquote>
<p>Cache-Control常见取值：</p>
<p>private:客户端可以缓存</p>
<p>public:客户端和代理服务器都可以缓存</p>
<p>max-age=xxx: xxx秒后失效</p>
<p>no-cache:需要使用对比缓存来验证缓存数据</p>
<p>no-store：所有内容都不会缓存，强制缓存，对比缓存都不会触发</p>
</blockquote>
</blockquote>
<blockquote>
<p>对比缓存：浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回<strong>304</strong>状态码，通知客户端比较成功，可以使用缓存数据。</p>
<p>对比缓存的缓存标识：</p>
<blockquote>
<p>Last-Modified:第一次请求时，服务器端响应首部包含该字段，表示该资源上一次被修改的时间</p>
<p>If-Modified-Since：再次请求时，客户端的请求报文中包含该字段，表示该请求资源上次请求时返回的资源最后修改时间，服务器端收到后与最后一次资源被修改的时间进行对比，若大于该时间，则返回200状态码并响应整个资源实体，否则返回304状态码，不含实体主体，告知客户端可以继续使用缓存数据，</p>
<p>Etag / If-None-Match（优先级高于Last Modified/If-Modified-Since）</p>
<blockquote>
<p>Etag :第一次请求资源时，服务器返回当前资源的唯一标识</p>
<p>If-None-Match：再次请求服务器时，通过此字段通知服务器客户端缓存数据的唯一标识。服务器收到请求后则将If-None-Match 与被请求资源的唯一标识进行比对，<br>不同，说明资源又被改动过，则响应整片资源内容，返回状态码200；<br>相同，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的Etag。</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h4 id="6-http首部"><a href="#6-http首部" class="headerlink" title="6. http首部"></a>6. http首部</h4><p><strong>6.1 http报文首部</strong></p>
<p><strong>6.2 http首部字段</strong></p>
<p>End-to-end Header：端到端首部：分在此类别中的首部会转发给请求/响应对应的最终接受目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。</p>
<p>Hop-by-hop Header：逐跳首部：分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。（HTTP/1.1中的8个逐跳首部字段：Connection，Keep-Alive,Proxy-Authenticate,Proxy-Authorization,Trailer,TE,Transfer-Encoding,Upgrade）</p>
<p><strong>6.3 HTTP/1.1 通用首部字段</strong></p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th>解释</th>
<th>补充</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Cache-Control</td>
<td>操作缓存的工作机制</td>
<td></td>
</tr>
<tr>
<td align="left">Connection</td>
<td>控制不再转发给代理的首部字段；管理持久连接</td>
<td></td>
</tr>
<tr>
<td align="left">Date</td>
<td>表明创建HTTP报文的日期和时间</td>
<td></td>
</tr>
<tr>
<td align="left">Trailer</td>
<td>事先说明在报文主体后记录了哪些首部字段</td>
<td></td>
</tr>
<tr>
<td align="left">Transfer-Encoding</td>
<td>规定了传输报文主体时采用的编码方式</td>
<td>chunked</td>
</tr>
<tr>
<td align="left">Upgrade</td>
<td>用于检测HTTP协议及其他协议是否可使用更高版本进行通信</td>
<td></td>
</tr>
<tr>
<td align="left">Via</td>
<td>为了追踪客户端与服务器之间的请求和响应报文的传输路径</td>
<td></td>
</tr>
<tr>
<td align="left">Warning</td>
<td>[警告码] [警告的主机：端口号] [“警告内容”] ([日期时间])</td>
<td></td>
</tr>
</tbody></table>
<p><strong>6.4 请求首部字段</strong></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>解释</th>
<th>补充</th>
</tr>
</thead>
<tbody><tr>
<td>Accept</td>
<td>告知服务器用户代理能够处理的媒体类型及相对优先级</td>
<td>q=来表示权重</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>通知服务器用户代理支持的字符集及相对优先级</td>
<td>服务器驱动协商/q=</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>告知服务器用户代理支持的内容编码及相对优先级</td>
<td>q=</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>告知服务器用户代理能够处理的自然语言集及相对优先级</td>
<td>q=</td>
</tr>
<tr>
<td>Authorization</td>
<td>在接收到401状态码响应后，告知用户代理的认证信息</td>
<td>响应：WWW-Authenticate</td>
</tr>
<tr>
<td>Expect</td>
<td>告知服务器客户端期望出现的某种特定行为</td>
<td>发生错误：417（Expectation Failed）</td>
</tr>
<tr>
<td>From</td>
<td>用于告知服务器使用用户代理的用户的电子邮件地址</td>
<td>也可能记录在User-Agent字段内</td>
</tr>
<tr>
<td>Host</td>
<td>告知服务器请求资源所处的互联网主机名和端口号</td>
<td>必须存在</td>
</tr>
<tr>
<td>If-Match</td>
<td>服务器会对比If-Match的字段值和资源的ETag值，仅当两者一致的时候才会执行请求</td>
<td>否则返回412（Precondition Failed）</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>只有资源在指定时间后发生更新的情况下才进行处理，用于确认资源的有效性</td>
<td>否则返回304</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>与If-Match相反，用于确认资源有效性</td>
<td></td>
</tr>
<tr>
<td>If-Range</td>
<td>告知服务器若指定的If-Range字段值（Etag值或时间）和请求资源的ETag值或时间相一致时，则作为范围请求处理。否则返回全体资源</td>
<td></td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>与If-Modified-Since相反</td>
<td>否则返回412</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>指定可经过的服务器最大数目</td>
<td>逐个减1，=0时响应</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>接收到从代理服务器发来的认证质询时，客户端会发送包含该字段的请求</td>
<td></td>
</tr>
<tr>
<td>Range</td>
<td>告知服务器资源的请求范围</td>
<td>206/200</td>
</tr>
<tr>
<td>Referer</td>
<td>告知服务器请求的原始资源的URI，即来源信息</td>
<td></td>
</tr>
<tr>
<td>TE</td>
<td>1.告知服务器客户端能够处理响应的传输编码方式及相对优先级 2.指定伴随trailer字段的分块传输编码方式</td>
<td></td>
</tr>
<tr>
<td>User-Agent</td>
<td>将创建请求的浏览器和用户代理名称等信息传达给服务器</td>
<td></td>
</tr>
</tbody></table>
<p><strong>6.5 响应首部字段</strong></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>解释</th>
<th>补充</th>
</tr>
</thead>
<tbody><tr>
<td>Accept-Ranges</td>
<td>告知客户端服务器是否能处理范围请求</td>
<td>值为bytes/none</td>
</tr>
<tr>
<td>Age</td>
<td>1.告知客户端服务器在多久前创建了响应；2.若创建该响应的是缓存服务器，Age值是指缓存后的响应再次发起认证到认证完成的时间值</td>
<td>代理创建响应必须加Age</td>
</tr>
<tr>
<td>ETag</td>
<td>分为强ETag（无论实体发生多么细微的变化都会改变其值）和弱ETag（在字段值前加W：只有资源发生了根本改变，产生差异时才会改变ETag）</td>
<td></td>
</tr>
<tr>
<td>Location</td>
<td>配合3XX重定向状态码，可以将响应接收方引导至某个与请求URI位置不同的资源</td>
<td></td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>把代理服务器所要求的认证信息发送给客户端</td>
<td>客户端与代理服务器之间</td>
</tr>
<tr>
<td>Retry-After</td>
<td>主要配合状态码503 Service Unavailable或3XX Redirect响应一起使用</td>
<td></td>
</tr>
<tr>
<td>Server</td>
<td>告知客户端当前服务器上安装的HTTP服务器应用程序的信息</td>
<td></td>
</tr>
<tr>
<td>Vary</td>
<td>对缓存进行控制，源服务器响应报文中Vary字段指定的首部字段相同时，才能返回缓存，否则要从源服务器重新获取资源</td>
<td></td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>用于HTTP访问认证</td>
<td>401中一定包含</td>
</tr>
</tbody></table>
<p><strong>6.6 实体首部字段</strong>：用于 补充内容的更新时间等于实体相关的信息</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>解释</th>
<th>补充</th>
</tr>
</thead>
<tbody><tr>
<td>Allow</td>
<td>通知客户端能够支持制定资源的所有HTTP方法</td>
<td>405（Method Not Allowed）</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>告知客户端服务器对实体主体选用的编码方式</td>
<td>gzip;conpress;deflate;identity</td>
</tr>
<tr>
<td>Content-Language</td>
<td>告知客户端实体主体使用的自然语言</td>
<td></td>
</tr>
<tr>
<td>Content-length</td>
<td>表明实体主体部分的大小</td>
<td></td>
</tr>
<tr>
<td>Content-Location</td>
<td>给出与报文主体部分相对应的URI</td>
<td>与Location相比无需再进行内容协商</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>该字段是一串由MD5算法生成的值，目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达</td>
<td>无法查证内容的偶发性改变</td>
</tr>
<tr>
<td>Content-Range</td>
<td>实体主体的范围</td>
<td></td>
</tr>
<tr>
<td>Content-Type</td>
<td>实体主体内对象的媒体类型</td>
<td></td>
</tr>
<tr>
<td>Expires</td>
<td>缓存资源的有效期</td>
<td>max-age优先级更高</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>资源最后被修改的时间</td>
<td></td>
</tr>
</tbody></table>
<p><strong>6.7 为cookie服务的首部字段</strong></p>
<p>cookie工作机制：用户识别及状态管理</p>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
<th>首部类型</th>
</tr>
</thead>
<tbody><tr>
<td>Set-Cookie</td>
<td>开始状态管理所使用的Cookie信息</td>
<td>响应首部字段</td>
</tr>
<tr>
<td>Cookie</td>
<td>服务器接收到的Cookie信息</td>
<td>请求首部字段</td>
</tr>
</tbody></table>
<p><strong>6.8 其他首部字段</strong></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>首部类型</th>
<th>字段值</th>
</tr>
</thead>
<tbody><tr>
<td>X-Frame-Options</td>
<td>控制网站内容在其他Web网站的Frame标签内的显示问题：防止点击劫持（clickjacking）攻击</td>
<td>响应首部字段</td>
<td>DENY/SAMEORIGIN（仅同源域名下的页面匹配时许可）</td>
</tr>
<tr>
<td>X-XSS-Protection</td>
<td>针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器XSS防护机制的开关</td>
<td>响应首部字段</td>
<td>0：将XSS过滤设置成无效状态；1：将XSS过滤设置成有效状态</td>
</tr>
<tr>
<td>DNT</td>
<td>Do Not Track：拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法</td>
<td>请求首部字段</td>
<td>0：同意被追踪；1：拒绝被追踪</td>
</tr>
<tr>
<td>P3P</td>
<td>The Platform Privacy Preferences：在线隐私偏好平台，用于保护用户隐私</td>
<td>响应首部</td>
<td></td>
</tr>
</tbody></table>
<p>同源：同域名，同端口，同协议</p>
<p>跨域：跨域名，跨端口，跨协议</p>
<h4 id="7-确保web安全的https"><a href="#7-确保web安全的https" class="headerlink" title="7. 确保web安全的https"></a>7. 确保web安全的https</h4><p><strong>7.1 http的缺点</strong></p>
<p>（1）通信使用明文（不加密），可能遭窃听；</p>
<p><strong>通信的加密：通过和SSL（Secure Socket Layer,安全套接层）或TLS（Transport Layer Security,安全层传输协议）的组合使用，加密HTTP的通信内容</strong>：https</p>
<p><strong>内容的加密：对报文主体进行加密，但该方法仍有内容被篡改的风险</strong></p>
<p>（2）不验证通信方身份，可能遭遇伪装；</p>
<p><strong>查明对手的证书：SSL</strong></p>
<p>（3）无法验证报文的完整性，可能遭遇篡改</p>
<p><strong>像这样，请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击（Man-in-the-Middle attack,MITM）</strong></p>
<p>如何防止篡改？</p>
<p><strong>常用的是MD5和SHA-1等散列值校验的方法，以及用来确认文件的数字签名方法</strong></p>
<p><strong>7.2 http+加密+认证+完整性保护=https</strong></p>
<p>https只是http套了一层SSL，http先和SSL通信，再由SSL和TCP通信（TSL是以SSL为原型开发的协议，有时会统一称该协议为SSL，当前主流版本是SSL3.0和TSL1.0）</p>
<p><strong>https采用的是混合加密机制</strong></p>
<p>（1）SSL采用一种叫做公开密钥加密的加密处理方式</p>
<p><strong>共享密钥加密：加密和解密同用一个密钥的方式，也叫做对称密钥加密（不安全）</strong></p>
<p><strong>公开密钥加密：使用一对非对称的密钥，一把叫做私有密钥，另一把叫做公开密钥（处理速度慢）</strong></p>
<blockquote>
<p>即发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。</p>
</blockquote>
<p><strong>混合加密：使用公开密钥加密方式传送后续共享密钥加密中要使用的密钥</strong></p>
<p>（2）如何证明公开密钥的正确性？</p>
<p>可以使用由数字证书认证机构（CA）和其他机关颁发的公开密钥证书</p>
<p>流程：</p>
<p><img src="C:%5CUsers%5CLihang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200228155417210.png" alt="image-20200228155417210"></p>
<p>https通信过程：</p>
<p><img src="C:%5CUsers%5CLihang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200310230631141.png" alt="image-20200310230631141"></p>
<p>（3）https的缺点：</p>
<p>通信时间延长；消耗大量CPU和内存，处理速度变慢；购买证书等导致成本变高</p>
<h4 id="8-确认访问用户身份的认证"><a href="#8-确认访问用户身份的认证" class="headerlink" title="8. 确认访问用户身份的认证"></a>8. 确认访问用户身份的认证</h4><p><strong>8.1 HTTP/1.1使用的认证方式：</strong></p>
<p>（1）BASIC认证（基本认证）</p>
<p>（2）DIGEST认证（摘要认证）</p>
<p>（3）SSL客户端认证</p>
<p>（4）FormBase认证（基于表单认证）</p>
<p><strong>8.2 BASIC认证</strong></p>
<p>采用Base64编码方式，但不是加密处理；</p>
<p>想再进行一次BASIC认证时，一般的浏览器无法实现认证注销操作</p>
<p><strong>缺点：认证使用上不够灵活，且达不到多数网站期望的安全性等级，不常用</strong></p>
<p><strong>8.3 DIGEST认证</strong></p>
<p>客户端发送请求——服务器发送临时质询码（401）——客户端用MD5算法对质询码进行运算，并把密码字符串发给服务器端（认证成功：200；认证失败：401）</p>
<p><strong>DIGEST认证提供防止密码被窃听的保护机制，但并不存在防止用户伪装的保护机制</strong></p>
<p><strong>8.4 SSL客户端认证</strong></p>
<p>认证步骤：</p>
<p>（1）接收到需要认证资源的请求，服务器会发送Certificate Request报文，要求客户端提供客户端证书；</p>
<p>（2）用户选择要发送的客户端证书后，客户端会把客户端证书以Client Certificate报文方式发给服务器；</p>
<p>（3）服务器验证客户端证书通过后可领取证书中的公开密钥，然后开始HTTPS加密通信</p>
<p><strong>SSL客户端认证采用SSL客户端认证（用于认证客户端计算机）和基于表单认证双因素认证（用于认证用户本人身份）</strong></p>
<p><strong>8.5 基于表单认证</strong></p>
<p>session管理和cookie应用：</p>
<p>使用HTTPS通信来进行HTML表单画面的显示和用户输入数据的发送；</p>
<p>cookie中的Session ID用于识别用户</p>
<p><strong>服务器端如何保存客户端发来的用户名和密码？</strong></p>
<p>一种安全的保存方式是：先利用给密码加盐（salt:加随机生成的字符串）的方式增加额外信息（避免密码相同），再使用散列（hash）函数计算出散列值后保存</p>
<p><strong>8.6 session（会话）管理及cookie应用</strong></p>
<p><img src="C:%5CUsers%5CLihang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200310234233723.png" alt="image-20200310234233723"></p>
<h4 id="9-基于http的功能追加协议"><a href="#9-基于http的功能追加协议" class="headerlink" title="9. 基于http的功能追加协议"></a>9. 基于http的功能追加协议</h4><p><strong>9.1 消除HTTP瓶颈的SPDY：旨在解决HTTP的性能瓶颈，缩短Web页面的加载时间</strong></p>
<blockquote>
<p>HTTP瓶颈：</p>
<p>（1）一条连接上只可发送一个请求</p>
<p>（2）请求只能从客户端开始。客户端不可以接收除响应以外的指令</p>
<p>（3）请求/响应首部未经压缩就发送。首部信息越多延迟越大</p>
<p>（4）发送冗长的首部。每次互相发送相同的首部造成的浪费较多</p>
<p>（5）可任意选择数据压缩格式。非强制压缩发送</p>
</blockquote>
<p><strong>9.1.1 Ajax的解决方法：局部Web页面替换加载的异步通信手段</strong></p>
<p>核心技术：XMLHttpRequest:可以从已加载完毕的Web页面上发起请求，只更新局部页面</p>
<p><strong>9.1.2 Comet的解决方法：对于客户端发送的确认更新情况的请求，服务器端会将响应保留到有内容更新</strong></p>
<blockquote>
<p>但Ajax和Comet方法都没有解决http协议本身存在的问题：每次都互相发送相同的首部，有时不压缩数据直接发送。</p>
</blockquote>
<p><strong>9.1.3 SPDY：</strong></p>
<p>目标：为了对http进行从根本上的改善，需要有一些协议层面上的改动</p>
<p>SPDY以会话层的形式加入，控制对数据的流动，但还是采用HTTP建立通信连接。</p>
<p><img src="C:%5CUsers%5CLihang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200312105726881.png" alt="image-20200312105726881"></p>
<p><strong>使用SPDY后，HTTP协议额外获得以下功能：</strong></p>
<blockquote>
<p>（1）多路复用流：通过单一的TCP连接，可以无限制处理多个HTTP请求</p>
<p>（2）赋予请求优先级：为了在发送多个请求时，解决因带宽低而导致响应变慢的问题</p>
<p>（3）压缩HTTP首部：</p>
<p>（4）推送功能：支持服务器主动向客户端推送数据的功能</p>
<p>（5）服务器提示功能：服务器可以主动提示客户端请求所需的资源</p>
</blockquote>
<p><strong>9.2 使用浏览器进行全双工通信的WebSocket</strong></p>
<p>主要特点：</p>
<blockquote>
<p>（1）推送功能</p>
<p>（2）减少通信量：只要建立起WebSocket通信，就希望一直保持连接状态，和HTTP相比，不但每次连接时的总开销减少，而且由于WebSocket的首部信息很小，通信量也相应减少了</p>
</blockquote>
<p><strong>为了实现WebSocket通信，在HTTP连接建立以后，需要完成一次“握手”的步骤</strong></p>
<blockquote>
<p>握手_请求：</p>
<p>Upgrade: websocket</p>
<p>Connection: Upgrade</p>
<p>Sec-WebSocket-Key: 记录握手过程中必不可少的键值</p>
<p>Sec-WebSocket-Protocol: 记录使用的子协议</p>
<p>握手_响应：</p>
<p>状态行： HTTP/1.1 101 Switching Protocols</p>
<p>Upgrade: websocket</p>
<p>Connection: Upgrade</p>
<p>Sec-WebSocket-Accept: 由握手请求中的Sec-WebSocket-Key的字段值生成</p>
<p>Sec-WebSocket-Protocol: </p>
</blockquote>
<p><img src="C:%5CUsers%5CLihang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200312122312572.png" alt="image-20200312122312572"></p>
<p><strong>9.3 HTTP/2.0:目标是改善用户在使用Web时的速度体验</strong></p>
<p>以以下协议为基础：</p>
<blockquote>
<p>SPDY:</p>
<p>HTTP Speed + Mobility：用于改善并提高移动端通信时的通信速度和性能</p>
<p>Network-Friendly HTTP Upgrade：在移动端通信时改善HTTP性能</p>
</blockquote>
<p>HTTP/2.0 的7项技术和讨论</p>
<p><img src="C:%5CUsers%5CLihang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200312124716664.png" alt="image-20200312124716664"></p>
<p><strong>9.4 Web服务器管理文件的WebDAV：</strong></p>
<p>一个可对服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统，除了创建、删除文件等基本功能，它还具备文件创建者管理、文件编辑过程中禁止其他用户内容覆盖的加锁功能，以及对文件内容修改的版本控制功能</p>
<h4 id="10-构建web内容的技术"><a href="#10-构建web内容的技术" class="headerlink" title="10. 构建web内容的技术"></a>10. 构建web内容的技术</h4><p><strong>10.1 web应用</strong></p>
<p>CGI：通用网关接口：是指Web服务器在接收到客户端发来的请求后转发给程序的一组机制</p>
<p><img src="C:%5CUsers%5CLihang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200312130504383.png" alt="image-20200312130504383"></p>
<h4 id="11-web的攻击技术"><a href="#11-web的攻击技术" class="headerlink" title="11. web的攻击技术"></a>11. web的攻击技术</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="柴郡猫"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">柴郡猫</p>
  <div class="site-description" itemprop="description">向死而生的生命都在热烈地生长</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/holichang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;holichang" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1185381333@qq.com" title="E-Mail → mailto:1185381333@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">柴郡猫</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
