<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"holichang.github.io","root":"/","scheme":"Muse","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1. 闭包无论通过何种手段将内部函数传递到所在的词法作用域以外，它持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包  思考：通过使用闭包，在作用域之外也可以调用函数，同时该函数还可以访问本身词法作用域中的变量  在定时器、事件监听器、AJAX请求、跨窗口通信、Web Workers或者任何其他的异步（或同步）任务中，只要使用了回调函数，实际上就是在使用闭包 1.1 循环和闭包IIFE">
<meta property="og:type" content="article">
<meta property="og:title" content="面经——JavaScript">
<meta property="og:url" content="https://holichang.github.io/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/index.html">
<meta property="og:site_name" content="Cheshire Cat">
<meta property="og:description" content="1. 闭包无论通过何种手段将内部函数传递到所在的词法作用域以外，它持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包  思考：通过使用闭包，在作用域之外也可以调用函数，同时该函数还可以访问本身词法作用域中的变量  在定时器、事件监听器、AJAX请求、跨窗口通信、Web Workers或者任何其他的异步（或同步）任务中，只要使用了回调函数，实际上就是在使用闭包 1.1 循环和闭包IIFE">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://holichang.github.io/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/%E5%8E%9F%E5%9E%8B.png">
<meta property="og:image" content="https://holichang.github.io/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/%E5%8E%9F%E5%9E%8B%E9%93%BE.png">
<meta property="og:image" content="https://holichang.github.io/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.png">
<meta property="og:image" content="https://holichang.github.io/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.png">
<meta property="og:image" content="https://holichang.github.io/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%AE%8F%E4%BB%BB%E5%8A%A1.jpg">
<meta property="og:image" content="https://holichang.github.io/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E6%A1%86%E6%9E%B6.png">
<meta property="og:image" content="https://holichang.github.io/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/before.png">
<meta property="og:image" content="https://holichang.github.io/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/now.png">
<meta property="og:image" content="https://holichang.github.io/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="https://holichang.github.io/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/%E5%89%8D%E5%90%8E%E7%AB%AF%E6%A8%A1%E6%9D%BF%E6%9E%84%E5%BB%BA.png">
<meta property="article:published_time" content="2020-03-25T13:30:05.000Z">
<meta property="article:modified_time" content="2020-04-11T14:49:54.668Z">
<meta property="article:author" content="柴郡猫">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://holichang.github.io/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/%E5%8E%9F%E5%9E%8B.png">

<link rel="canonical" href="https://holichang.github.io/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>面经——JavaScript | Cheshire Cat</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Cheshire Cat</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://holichang.github.io/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="柴郡猫">
      <meta itemprop="description" content="向死而生的生命都在热烈地生长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cheshire Cat">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面经——JavaScript
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-25 21:30:05" itemprop="dateCreated datePublished" datetime="2020-03-25T21:30:05+08:00">2020-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-11 22:49:54" itemprop="dateModified" datetime="2020-04-11T22:49:54+08:00">2020-04-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="1-闭包"><a href="#1-闭包" class="headerlink" title="1. 闭包"></a>1. 闭包</h3><p><strong>无论通过何种手段将内部函数传递到所在的词法作用域以外，它持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包</strong></p>
<blockquote>
<p>思考：通过使用闭包，在作用域之外也可以调用函数，同时该函数还可以访问本身词法作用域中的变量</p>
</blockquote>
<p>在定时器、事件监听器、AJAX请求、跨窗口通信、Web Workers或者任何其他的异步（或同步）任务中，只要使用了<strong>回调函数</strong>，实际上就是在使用闭包</p>
<h5 id="1-1-循环和闭包"><a href="#1-1-循环和闭包" class="headerlink" title="1.1 循环和闭包"></a>1.1 循环和闭包</h5><p>IIFE：立即执行函数表达式，相当于将块转为了一个可以被关闭的作用域（var）</p>
<p>先看下面这个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;,<span class="number">1000</span>*i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//预期：分别输出数字1-5，每秒一次，每次一个</span></span><br><span class="line"><span class="comment">//该段代码会以每秒一次的频率输出五次6</span></span><br></pre></td></tr></table></figure>

<p>缺陷是我们试图假设循环中的每个迭代在运行时都会给自己捕获一个i的副本，但是根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被<strong>封闭在一个共享的全局作用域中，</strong>因此事实上只有一个i。</p>
<p>如何修改？</p>
<p><strong>方法一：使用IIFE</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(j)</span><br><span class="line">        &#125;,<span class="number">1000</span>*j)</span><br><span class="line">    &#125;(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：使用setTimeout第三个参数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;,i*<span class="number">1000</span>,i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//setTimeout的第三个参数为传给执行函数的其他参数（IE9 及其更早版本不支持该参数）。</span></span><br></pre></td></tr></table></figure>

<p><strong>方法三：使用let：块级作用域</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> j=i;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;,j*<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line">或：</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;=<span class="number">5</span>;i++)</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;,i*<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每次迭代都会创建一个i的副本</span></span><br></pre></td></tr></table></figure>

<h5 id="1-2-模块"><a href="#1-2-模块" class="headerlink" title="1.2 模块"></a>1.2 模块</h5><p>模块模式需要具备两个必要条件：</p>
<p>（1）必须有外部的封闭函数，该函数必须至少被调用一次，（<strong>每次调用都会创建一个新的模块实例？</strong>）</p>
<p>（2）封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态</p>
<p><strong>现代的模块机制：</strong></p>
<p>大多数模块依赖加载器/管理器本质上都是将这种模块定义封装进一个友好的API。这里并不会研究某个具体的库，为了宏观了解会简单介绍一些核心概念：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyModules=(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">module</span>=&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">define</span>(<span class="params">name,deps,impl</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;deps.length;i++)&#123;</span><br><span class="line">            deps[i]=<span class="built_in">module</span>[deps[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        modules[name]=impl.apply(impl,deps)</span><br><span class="line">        <span class="comment">//引入需要的依赖</span></span><br><span class="line">    &#125;<span class="comment">//该函数用于向管理中添加模块</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">module</span>[name];</span><br><span class="line">    &#125;<span class="comment">//通过名称获取模块</span></span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        define:define,</span><br><span class="line">        <span class="keyword">get</span>:<span class="keyword">get</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">//下面为使用方法：[]为新定义的模块需要引入的依赖模块列表</span><br><span class="line">MyModules.define("bar",[],function()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">who</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'let me introduce:'</span>+who;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        hello:hello</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">MyModules.define(<span class="string">"foo"</span>,[<span class="string">"bar"</span>],<span class="function"><span class="keyword">function</span>(<span class="params">bar</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hungry=<span class="string">"hippo"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">awesome</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(bar.hello(hungry).toUpperCase());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>&#123;</span><br><span class="line">        awesome:awesome</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> bar=MyModules.get(<span class="string">"bar"</span>);</span><br><span class="line"><span class="keyword">var</span> foo=MyModules.get(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	bar.hello(<span class="string">"hippo"</span>)</span><br><span class="line">);<span class="comment">//let me introduce: hippo</span></span><br><span class="line">foo.awesome();<span class="comment">//LET ME INTRODUCE:HIPPO</span></span><br></pre></td></tr></table></figure>

<p><strong>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包</strong></p>
<h3 id="2-对象"><a href="#2-对象" class="headerlink" title="2. 对象"></a>2. 对象</h3><h4 id="对象深度克隆的简单实现"><a href="#对象深度克隆的简单实现" class="headerlink" title="对象深度克隆的简单实现"></a>对象深度克隆的简单实现</h4><h4 id="js监听对象属性的改变"><a href="#js监听对象属性的改变" class="headerlink" title="js监听对象属性的改变"></a>js监听对象属性的改变</h4><h4 id="2-1-理解对象"><a href="#2-1-理解对象" class="headerlink" title="2.1 理解对象"></a>2.1 理解对象</h4><h5 id="2-1-1-属性类型"><a href="#2-1-1-属性类型" class="headerlink" title="2.1.1 属性类型"></a>2.1.1 属性类型</h5><p>ES5中有两种属性：数据属性和访问器属性</p>
<p><strong>数据属性</strong>：数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性：</p>
<p>[[Configurable]]:表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。</p>
<p>[[Enumerable]]：表示能否通过for-in循环返回属性。</p>
<p>[[Writable]]：表示能否修改属性的值。</p>
<p>[[Value]]：包含这个属性的值。</p>
<p><strong>要修改属性默认的特性：</strong>ES5的<strong>Object.defineProperty()</strong>方法（三个参数：属性所在的对象、属性的名字、描述符对象）使用如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">"name"</span>,&#123;</span><br><span class="line">    writable:<span class="literal">false</span>;</span><br><span class="line">    value:<span class="string">"Nicholas"</span>;</span><br><span class="line">&#125;)</span><br><span class="line">alert(person.name);<span class="comment">//"Nicholas"</span></span><br><span class="line">person.name=<span class="string">"Greg"</span>;</span><br><span class="line">alert(person.name);<span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>

<p>可以多次调用Object.defineProperty()方法修改同一个属性，但在把configurable特性设置为false之后就会有限制了。同时，<strong>在调用Object.defineProperty()方法创建一个新属性时，如果不指定，configurable，enumerable和writable特性的默认值都是false</strong>,如果调用Object.defineProperty()方法是修改已定义属性的特性，则无此限制。</p>
<p><strong>访问器属性</strong>（常用方法：设置一个属性的值会导致其他属性发生变化）</p>
<p>访问器属性不包含数据值，它包含一对getter函数和setter函数（不过这两个函数都不是必需的）。在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值，在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性：</p>
<p>[[Configurable]]:表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。</p>
<p>[[Enumerable]]：表示能否通过for-in循环返回属性。</p>
<p>[[Get]]：在读取属性时调用的函数。默认值为undefined。</p>
<p>[[Set]]：在写入属性时调用的函数。默认值为undefined。</p>
<p><strong>访问器属性不能直接定义，必须使用</strong>Object.defineProperty()来定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book=&#123;</span><br><span class="line">    _year:<span class="number">2004</span>,</span><br><span class="line">    edition:<span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book,<span class="string">"year"</span>,&#123;</span><br><span class="line">    <span class="keyword">get</span>:function()&#123;</span><br><span class="line">        <span class="keyword">return</span> book._year;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>:function(newValue)&#123;</span><br><span class="line">        <span class="keyword">if</span>(newValue&gt;<span class="number">2004</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>._year=newValue;</span><br><span class="line">            <span class="keyword">this</span>.edition=newValue<span class="number">-2004</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">book.year=<span class="number">2005</span>;</span><br><span class="line">alert(book.edition);<span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h5 id="2-1-2-定义多个属性"><a href="#2-1-2-定义多个属性" class="headerlink" title="2.1.2 定义多个属性"></a>2.1.2 定义多个属性</h5><p>Object.defineProperties()方法:可以一次性定义多个属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperties(book,&#123;</span><br><span class="line">    _year:&#123;</span><br><span class="line">        writable:<span class="literal">true</span>,</span><br><span class="line">        value:<span class="number">2004</span></span><br><span class="line">    &#125;,</span><br><span class="line">    edition:&#123;</span><br><span class="line">        writable:<span class="literal">true</span>;</span><br><span class="line">        value:<span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    year:&#123;</span><br><span class="line">        <span class="keyword">get</span>:function()&#123;</span><br><span class="line">            <span class="keyword">return</span> book._year;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>:function(newValue)&#123;</span><br><span class="line">            <span class="keyword">if</span>(newValue&gt;<span class="number">2004</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>._year=newValue;</span><br><span class="line">                <span class="keyword">this</span>.edition=newValue<span class="number">-2004</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="2-1-3-读取属性的特性"><a href="#2-1-3-读取属性的特性" class="headerlink" title="2.1.3 读取属性的特性"></a>2.1.3 读取属性的特性</h5><p><strong>Object.getOwnPropertyDescriptor()</strong>方法：取得给定属性的描述符。接收两个参数：属性所在的对象和要读取其描述符的属性名称，如：(接上段代码)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> descriptor=<span class="built_in">Object</span>.getOwnPropertyDescriptor(book,<span class="string">"_year"</span>);</span><br><span class="line">alert(descriptor.value);<span class="comment">//2004</span></span><br><span class="line">alert(descriptor.configurable);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p><strong>ES5的Object.getOwnPropertyDescriptor（）方法只能用于实例属性，要取得原型属性的描述符，必须直接在原型对象上调用该方法。</strong></p>
<p>在JavaScript 中，可以针对任何对象——包括 DOM 和BOM 对象，使用Object.getOwnProperty-Descriptor()方法。支持这个方法的浏览器有IE9+、Firefox 4+、Safari 5+、Opera 12+和Chrome。</p>
<h4 id="2-2创建对象"><a href="#2-2创建对象" class="headerlink" title="2.2创建对象"></a>2.2创建对象</h4><h5 id="2-2-1-工厂模式："><a href="#2-2-1-工厂模式：" class="headerlink" title="2.2.1 工厂模式："></a>2.2.1 工厂模式：</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> person=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">   person.name=name;</span><br><span class="line">   person.age=age;</span><br><span class="line">   person.job=job;</span><br><span class="line">   person.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'my name is'</span>+<span class="keyword">this</span>.name)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1=createPerson(<span class="string">"Nicholas"</span>,<span class="number">29</span>,<span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2=createPerson(<span class="string">"Greg"</span>,<span class="number">27</span>,<span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure>

<p>用函数来封装以特定接口创建对象的细节（虽然解决了创建多个相似对象的问题，但没有解决对象识别的问题,即怎么知道一个对象的类型）</p>
<h5 id="2-2-2-构造函数模式"><a href="#2-2-2-构造函数模式" class="headerlink" title="2.2.2 构造函数模式"></a>2.2.2 构造函数模式</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.job=job;</span><br><span class="line">    <span class="keyword">this</span>.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>,<span class="number">29</span>,<span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2=<span class="keyword">new</span> Person(<span class="string">"Greg"</span>,<span class="number">23</span>,<span class="string">"Doctor"</span>);</span><br><span class="line">alert(person1.constructor==Person);<span class="comment">//true</span></span><br><span class="line">alert(person1 <span class="keyword">instanceof</span> Person);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>构造函数模式和工厂模式的区别：</strong></p>
<p>（1）没有显式地创建一个新对象</p>
<p>（2）直接将属性和方法赋给了新对象</p>
<p>（3）没有return语句</p>
<p><strong>使用new操作符调用构造函数实际会经历以下步骤：</strong></p>
<p>（1）创建一个新对象</p>
<p>（2）这个新对象会被执行[[Prototype]]连接；</p>
<p>（3）将构造函数的作用域赋给新对象（因此this就指向了这个对象）</p>
<p>（4）执行构造函数中的代码（为这个新对象添加属性）</p>
<p>（5）返回新对象</p>
<p><strong>创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式胜过工厂模式的地方。</strong>在这个例子中，person1 和person2 之所以同时是Object 的实例，是因为所有对象均继承自Object</p>
<p><strong>构造函数模式存在的问题</strong>：每个方法都要在每个实例重新创建一遍</p>
<h5 id="2-2-3-原型模式"><a href="#2-2-3-原型模式" class="headerlink" title="2.2.3 原型模式"></a>2.2.3 原型模式</h5><blockquote>
<p>在所有实现中都无法访问[[prototype]]或<em>proto</em></p>
</blockquote>
<p><strong>构造函数，原型和实例的关系：</strong></p>
<p>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。</p>
<p><strong>（1）理解原型对象</strong>：prototype是通过调用构造函数而创建的那个对象实例的原型对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name=<span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age=<span class="number">29</span>;</span><br><span class="line">Person.prototype.job=<span class="string">"Software Engineer"</span>;</span><br><span class="line">Person.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName();<span class="comment">//"Nicholas"</span></span><br><span class="line"><span class="comment">//person1._proto_为Person.prototype</span></span><br></pre></td></tr></table></figure>

<p>在默认情况下，所有原型对象都会自动获得一个constructor(构造函数)属性，这个属性是一个指向prototype属性所在函数的指针。Person.prototype.constructor指向Person</p>
<p><img src="/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/%E5%8E%9F%E5%9E%8B.png" alt="原型"></p>
<p>明确一点：<strong>这个连接存在于实例与构造函数的原型对象之间</strong>，而不是存在于实例与构造函数之间（即person1与Person.prototype之间的联系）person1内部有一个指向Person.prototype的指针（<code>[[prototype]]</code>或<code>_proto_</code>：虽然在所有实现中都无法访问到，但可以通过<code>isprototypeOf()</code>来确定是否是某实例的原型对象）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(Person.prototype.isPrototypeOf(person1));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>Object.getPrototypeOf():</strong>可以方便地获取一个对象的原型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">Object</span>.getPrototypeOf(person1)==Person.prototype);<span class="comment">//true</span></span><br><span class="line">alert(<span class="built_in">Object</span>.getPrototypeOf(person1).name);<span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>

<p>当代码要取得某个对象的某个属性时，会先从对象实例本身开始搜索，如果没有找到属性名，则继续搜索指针指向的原型对象。</p>
<p>当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性，也就是说，添加这个属性值会阻止我们访问原型中的那个属性，但不会修改那个属性;不过<strong>使用delete操作符可以完全删除实例属性</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">person1.name=<span class="string">"Greg"</span>;</span><br><span class="line">alert(person1.name);<span class="comment">//Greg</span></span><br><span class="line">alert(person1.hasOwnProperty(<span class="string">"name"</span>));<span class="comment">//true</span></span><br><span class="line"><span class="keyword">delete</span> person1.name;</span><br><span class="line">alert(person1.hasOwnProperty(<span class="string">"name"</span>));<span class="comment">//false</span></span><br><span class="line">alert(person1.name);<span class="comment">//Nicholas</span></span><br></pre></td></tr></table></figure>

<p><strong>hasOwnProperty()</strong>方法：检测一个属性是存在于实例中还是原型中</p>
<p><em>Object.getOwnPropertyDescriptor()方法只能用于实例属性，要取得原型属性的描述符，必须直接在原型对象上调用Object.getOwnPropertyDescriptor()方法</em></p>
<p><strong>（2）原型与in操作符</strong></p>
<p><strong>单独使用</strong>：in操作符只要通过对象能访问到属性就返回true,hasOwnProperty()只在属性存在于实例中时才返回true,因此当in操作符返回true，而hasOwnProperty()返回false时,就说明该属性存在于原型中</p>
<p><strong>for-in循环</strong>时：返回的是所有能够通过对象访问的，可枚举的属性，其中既包括存在于实例中的属性，也包括在原型中的属性。（<strong>屏蔽了原型中不可枚举属性（即将[[Enumerable]]标记为false属性）的实例属性也会在for-in循环中返回，因为根据规定，所有开发人员定义的属性都是可枚举的——只有在IE8及更早版本中例外</strong>）</p>
<p><strong>Object.keys()</strong>方法：接收一个对象作为参数，返回一个包含所有<strong>可枚举</strong>属性的<strong>字符串</strong>数组</p>
<p><strong>Object.getOwnPropertyNames():</strong>接收一个对象作为参数，返回一个包含<strong>所有实例属性</strong>的<strong>字符串</strong>数组</p>
<p><strong>（3）更简单的原型语法</strong>：用字面量法重写原型对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype=&#123;</span><br><span class="line">    <span class="keyword">constructor</span>:Person,</span><br><span class="line">    name:"Nicholas",</span><br><span class="line">    age:29,</span><br><span class="line">    job:"Software Engineer",</span><br><span class="line">    sayName:function()&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype,<span class="string">"constructor"</span>,&#123;</span><br><span class="line">    enumerable:<span class="literal">false</span>,</span><br><span class="line">    value:Person</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName();<span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>

<p>但此时，constructor属性不再指向Person函数，而是<strong>指向Object</strong>,但由于此时constructor属性为自定义的，<strong>可枚举</strong>，因此可以通过Object.defineProperty()将其[[Enumerable]]属性特性改为false。</p>
<p><strong>（4）原型的动态性</strong></p>
<p>重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系，他们引用的仍然是最初的原型。</p>
<p><strong>所以只能修改</strong></p>
<p><strong>（5）原生对象的原型</strong></p>
<p>可以修改如Array,Object,String等原生引用类型的原型，如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.startsWith=<span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.indexof(text)==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（6）原型对象的问题</strong></p>
<p><strong>原型对象中的引用类型值会被共享</strong></p>
<h5 id="2-2-4-组合使用构造函数模式和原型模式（最广泛、认同度最高）"><a href="#2-2-4-组合使用构造函数模式和原型模式（最广泛、认同度最高）" class="headerlink" title="2.2.4 组合使用构造函数模式和原型模式（最广泛、认同度最高）"></a>2.2.4 组合使用构造函数模式和原型模式（最广泛、认同度最高）</h5><p>构造函数用于定义实例属性，而原型模式用于定义方法和共享的属性。</p>
<h5 id="2-2-5-动态原型模式（可以把所有信息都封装在构造函数中）"><a href="#2-2-5-动态原型模式（可以把所有信息都封装在构造函数中）" class="headerlink" title="2.2.5 动态原型模式（可以把所有信息都封装在构造函数中）"></a>2.2.5 动态原型模式（可以把所有信息都封装在构造函数中）</h5><p>通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型，如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.job=job;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName!=<span class="string">"function"</span>)</span><br><span class="line">        <span class="comment">//此时sayName若是不存在或者不是函数类型，都会对原型初始化，而且检查一个属性或方法就可以</span></span><br><span class="line">    &#123;</span><br><span class="line">        Person.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-6-寄生（parasitic）构造函数模式（不建议使用）"><a href="#2-2-6-寄生（parasitic）构造函数模式（不建议使用）" class="headerlink" title="2.2.6 寄生（parasitic）构造函数模式（不建议使用）"></a>2.2.6 寄生（parasitic）构造函数模式（不建议使用）</h5><p>假如我们想创建一个具有额外方法的特殊数组，由于不能直接修改Array函数，因此可以使用这个模式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">values.push.apply(values,<span class="built_in">arguments</span>);<span class="comment">//arguments是个类数组对象，不能直接push到数组中</span></span><br></pre></td></tr></table></figure>

<p>构造函数在没有返回值的情况下，默认返回新对象实例，而该模式下的构造函数形式类似于工厂模式，在末尾有return语句，可以重写调用构造函数时返回的值，因此，<strong>返回的对象与构造函数以及构造函数的原型属性之间没有关系</strong>，也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。使用instanceof 没有意义。</p>
<h5 id="2-2-7-稳妥构造函数模式"><a href="#2-2-7-稳妥构造函数模式" class="headerlink" title="2.2.7 稳妥构造函数模式"></a>2.2.7 稳妥构造函数模式</h5><p>指的是没有公共属性，最适合在一些安全环境中使用，也与工厂模式很像</p>
<p>与寄生构造函数模式的区别：（1）不引用this对象（寄生模式在声明方法时使用）；（2）不使用new操作符</p>
<p>这种模式下创建的对象除了使用方法，没有其他办法访问属性值。</p>
<h4 id="2-3-继承"><a href="#2-3-继承" class="headerlink" title="2.3 继承"></a>2.3 继承</h4><p>ES只支持实现继承，而且主要依靠原型链</p>
<p>方法签名：</p>
<h5 id="2-3-1-原型链继承"><a href="#2-3-1-原型链继承" class="headerlink" title="2.3.1 原型链继承"></a>2.3.1 原型链继承</h5><p>基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法</p>
<p>实现本质是重写原型对象，代之以另一个新类型的实例</p>
<p><strong>（1）别忘记默认的原型</strong></p>
<p>所有函数的默认原型都是Object的实例</p>
<p><img src="/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="原型链"></p>
<p><strong>（2）确定原型和实例的关系</strong></p>
<p>instanceof操作符：+构造函数：只要用这个操作符测试实例与原型链中出现过的构造函数，就会返回true</p>
<p>isPrototypeOf()方法:只要是原型链中出现过的原型对象，都可以说是该原型链所派生的实例的原型</p>
<p><strong>（3）谨慎的定义方法</strong></p>
<p>给原型添加方法的代码一定要放在替换原型的语句之后，且不能使用字面量方法创建原型方法</p>
<p><strong>（4）原型链的问题</strong></p>
<p>第一个问题：包含引用类型值的原型属性会被所有实例共享</p>
<p>第二个问题：在创建子类型的实例时，不能向超类型的构造函数中传递参数</p>
<h5 id="2-3-2-借用构造函数（伪造对象或经典继承）"><a href="#2-3-2-借用构造函数（伪造对象或经典继承）" class="headerlink" title="2.3.2 借用构造函数（伪造对象或经典继承）"></a>2.3.2 借用构造函数（伪造对象或经典继承）</h5><p>基本思想：在子类型构造函数的内部调用超类型构造函数（使用call()方法或apply()方法）<strong>屏蔽掉超类型中的引用类型值</strong></p>
<p>好处：可以传递参数</p>
<p>问题：无法避免构造函数模式存在的问题——方法都在构造函数中定义，无法复用</p>
<h5 id="2-3-3-组合继承（JS中最常用的继承模式，也称伪经典继承）"><a href="#2-3-3-组合继承（JS中最常用的继承模式，也称伪经典继承）" class="headerlink" title="2.3.3 组合继承（JS中最常用的继承模式，也称伪经典继承）"></a>2.3.3 组合继承（JS中最常用的继承模式，也称伪经典继承）</h5><p>指的是将原型链和借用构造函数的技术组合到一起，使用原型链实现对原型属性和方法的继承，而使用借用构造函数来实现对实例属性的继承。</p>
<p>而且instanceof()和isPrototypeOf()也能够用于识别基于组合继承创建的对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.colors=[<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//继承属性</span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>,name);<span class="comment">//第二次调用构造函数，SubType实例中传入了第二组name和colors</span></span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承方法</span></span><br><span class="line">SubType.prototype=<span class="keyword">new</span> SuperType();<span class="comment">//第一次调用构造函数，SubType原型中传入了name和colors</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用寄生式组合继承方法：</span></span><br><span class="line"><span class="comment">function inheriPrototype(subType,superType)&#123;</span></span><br><span class="line"><span class="comment">    var prototype=object(superType.prototype);//创建对象：构建超类型原型的一个副本</span></span><br><span class="line"><span class="comment">    prototype.constructer=subType;//增强对象</span></span><br><span class="line"><span class="comment">    subType.prototype=prototype;//指定对象：将新创建的对象（即副本）赋值给子类型的原型</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">inheriPrototype(SubType,SuperType);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">SubType.prototype.constructor=SubType;</span><br><span class="line">SubType.prototype.sayAge=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 =<span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>,<span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"yellow"</span>);</span><br><span class="line">alert(instance1.colors);<span class="comment">//"red","green","blue","yellow"</span></span><br><span class="line">instance1.sayName();<span class="comment">//"Nicholas"</span></span><br><span class="line">instance1.sayAge();<span class="comment">//29</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 =<span class="keyword">new</span> SubType(<span class="string">"Greg"</span>,<span class="number">27</span>);</span><br><span class="line">alert(instance2.colors);<span class="comment">//"red","green","blue"</span></span><br><span class="line">instance2.sayName();<span class="comment">//"Greg"</span></span><br><span class="line">instance2.sayAge();<span class="comment">//27</span></span><br></pre></td></tr></table></figure>

<p><u>问题：会调用两次超类型构造函数</u></p>
<h5 id="2-3-4-原型式继承-ES5通过Object-create-方法规范化了原型式继承"><a href="#2-3-4-原型式继承-ES5通过Object-create-方法规范化了原型式继承" class="headerlink" title="2.3.4 原型式继承:ES5通过Object.create()方法规范化了原型式继承"></a>2.3.4 原型式继承:ES5通过Object.create()方法规范化了原型式继承</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype=o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;<span class="comment">//相当于利用一个构造函数做桥接，</span></span><br></pre></td></tr></table></figure>

<p>思想是基于对象o，创建一个实例，该实例的原型对象o,在包含引用类型属性值方面该方法与原型模式是一样的</p>
<p>ES5新增了Object.create()方法：接受两个参数：一个是用作新对象原型的对象和（可选的）一个新对象定义额外的对象，该对象中每个属性都是通过自己的描述符定义的.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">     name:<span class="string">'Nicholas'</span>,</span><br><span class="line">     friends:[<span class="string">'Shelby'</span>,<span class="string">'Court'</span>,;Van]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1=<span class="built_in">Object</span>.create(person,&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        value:<span class="string">'Greg'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(person1.name);<span class="comment">//'Greg'</span></span><br></pre></td></tr></table></figure>

<p>支持Object.create()方法的浏览器有IE9+、Firefox 4+、Safari 5+、Opera 12+ 和Chrome。<strong>在没有必要兴师动众地创建构造函数</strong>，而只想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的。不过别忘了，包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。</p>
<h5 id="2-3-5-寄生式继承"><a href="#2-3-5-寄生式继承" class="headerlink" title="2.3.5 寄生式继承"></a>2.3.5 寄生式继承</h5><p>思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象（即在内部通过构造函数创建一个实例，再为该对象增加方法，最后返回该对象）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone=<span class="built_in">Object</span>.create(o);</span><br><span class="line">    clone.sayHi=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"Hi!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">    name:<span class="string">'Nichlas'</span>,</span><br><span class="line">    friends:[<span class="string">'Tom'</span>,<span class="string">'Bob'</span>,<span class="string">'Greg'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> another=createAnother(person);</span><br><span class="line">another.sayHi();<span class="comment">//'Hi!'</span></span><br></pre></td></tr></table></figure>

<p>在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示范继承模式时使用的Object.create()函数不是必需的；任何能够返回新对象的函数都适用于此模式。</p>
<h5 id="2-3-6-寄生组合式继承（最理想）"><a href="#2-3-6-寄生组合式继承（最理想）" class="headerlink" title="2.3.6 寄生组合式继承（最理想）"></a>2.3.6 寄生组合式继承（最理想）</h5><p>用于解决组合继承两次调用构造函数的问题，方法见上方代码，该方法只调用一次SuperType构造函数,且原型链保持不变。</p>
<p><strong>基本思路：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的不过是超类型原型的一个副本而已，方法同原型式继承</strong></p>
<h3 id="3-混合对象“类”"><a href="#3-混合对象“类”" class="headerlink" title="3. 混合对象“类”"></a>3. 混合对象“类”</h3><h3 id="4-this"><a href="#4-this" class="headerlink" title="4. this"></a>4. this</h3><h4 id="4-1-调用位置：函数在代码中被调用的位置（而不是被声明的位置）"><a href="#4-1-调用位置：函数在代码中被调用的位置（而不是被声明的位置）" class="headerlink" title="4.1 调用位置：函数在代码中被调用的位置（而不是被声明的位置）"></a>4.1 调用位置：函数在代码中被调用的位置（而不是被声明的位置）</h4><p>调用栈：为了到达当前执行位置所调用的所有函数</p>
<h4 id="4-2-绑定规则："><a href="#4-2-绑定规则：" class="headerlink" title="4.2 绑定规则："></a>4.2 绑定规则：</h4><h5 id="4-2-1-默认绑定：独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则；"><a href="#4-2-1-默认绑定：独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则；" class="headerlink" title="4.2.1 默认绑定：独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则；"></a>4.2.1 默认绑定：独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则；</h5><p>回调函数相当于隐式的传参</p>
<p>非严格模式下，将全局对象用于默认绑定，而严格模式下，this会绑定到undefined</p>
<p><em>对于默认绑定来说，决定this绑定对象的并不是调用位置是否是严格模式，而是函数体是否处于严格模式</em></p>
<h5 id="4-2-2-隐式绑定：在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把this间接（隐式）绑定到这个对象上"><a href="#4-2-2-隐式绑定：在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把this间接（隐式）绑定到这个对象上" class="headerlink" title="4.2.2 隐式绑定：在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把this间接（隐式）绑定到这个对象上"></a>4.2.2 隐式绑定：在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把this间接（隐式）绑定到这个对象上</h5><p>考虑调用位置是否有上下文对象（对象属性引用链中只有上一层或者说是最后一层在调用位置中起作用），参数传递其实就是一种隐式赋值；可能会发生隐式丢失</p>
<h5 id="4-2-3-显式绑定：使用call-和apply"><a href="#4-2-3-显式绑定：使用call-和apply" class="headerlink" title="4.2.3 显式绑定：使用call()和apply()"></a>4.2.3 显式绑定：使用call()和apply()</h5><p><strong>硬绑定：</strong>典型应用场景就是创建一个包裹函数，负责接收参数并返回值</p>
<p>ES5提供了内置方法：Function.prototype.bind:会返回一个硬编码的新函数，它会把你指定的参数设置为this的上下文并调用原始函数。</p>
<blockquote>
<p>怎么原生JS实现bind?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">if</span>(!<span class="built_in">Function</span>.prototype.myBind)&#123;</span><br><span class="line">&gt;<span class="built_in">Function</span>.prototype.myBind=<span class="function"><span class="keyword">function</span>(<span class="params">oThis</span>)</span>&#123;</span><br><span class="line">&gt;<span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>!==<span class="string">'function'</span>)&#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Function.prototype.myBind-what is trying '</span>+<span class="string">'to be found is not callable'</span>);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">var</span> aArgs=<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>);</span><br><span class="line">&gt;<span class="keyword">var</span> fToBind=<span class="keyword">this</span>;<span class="comment">//要绑定的函数</span></span><br><span class="line">&gt;<span class="keyword">var</span> fNOP=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&gt;<span class="comment">//</span></span><br><span class="line">&gt;<span class="keyword">var</span> fBound=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> fToBind.apply((<span class="keyword">this</span> <span class="keyword">instanceof</span> fNOP &amp;&amp; oThis? <span class="keyword">this</span>:oThis),aArgs.concat.apply(aArgs,<span class="built_in">arguments</span>));</span><br><span class="line"> <span class="comment">//不是被new调用的时候this绑定到全局对象或者undefined,被new调用的时候this绑定到fBound</span></span><br><span class="line">&gt;&#125;;   </span><br><span class="line">&gt;fNOP.prototype=<span class="keyword">this</span>.prototype;</span><br><span class="line">&gt;fBound.prototype=<span class="keyword">new</span> fNOP();</span><br><span class="line">&gt;<span class="comment">//</span></span><br><span class="line">&gt;<span class="comment">//这段代码会判断硬绑定是否是被new调用，如果是的话就会用新创建的this替换硬绑定的this</span></span><br><span class="line">&gt;<span class="keyword">return</span> fBound;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如何判断一个函数是否是被new调用？new 的实现原理：</p>
</blockquote>
</blockquote>
<p><strong>API调用的“上下文”：</strong>如arr.forEach(function,可选参数，指定this)</p>
<h5 id="4-2-4-new绑定-实际上并不存在所谓的“构造函数”，只有对于函数的构造调用"><a href="#4-2-4-new绑定-实际上并不存在所谓的“构造函数”，只有对于函数的构造调用" class="headerlink" title="4.2.4 new绑定:实际上并不存在所谓的“构造函数”，只有对于函数的构造调用"></a>4.2.4 new绑定:实际上并不存在所谓的“构造函数”，只有对于函数的构造调用</h5><p>使用new来调用函数，会自动执行下面的操作：</p>
<p>a.创建（或者说是构造）一个全新的对象；</p>
<p>b.这个新对象会被执行[[Prototype]]连接；</p>
<p>c.这个新对象会绑定到函数调用的this；</p>
<p>d.如果函数没有其他返回对象，那么new表达式中的函数调用会自动返回这个新对象</p>
<h4 id="4-3-优先级：new绑定-gt-显式绑定-gt-隐式绑定-gt-默认绑定"><a href="#4-3-优先级：new绑定-gt-显式绑定-gt-隐式绑定-gt-默认绑定" class="headerlink" title="4.3 优先级：new绑定&gt;显式绑定&gt;隐式绑定&gt;默认绑定"></a>4.3 优先级：new绑定&gt;显式绑定&gt;隐式绑定&gt;默认绑定</h4><blockquote>
<p><strong>判断this：</strong></p>
<p>1.函数是否在new中调用（new绑定）？如果是的话this绑定的是新创建的对象</p>
<p>2.函数是否通过apply,call(显式绑定)？如果是的话，this绑定的是指定的对象</p>
<p>3.函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this绑定的就是这个上下文对象</p>
<p>4.如果上述都不是的话就是默认绑定，严格模式下this 绑定到undefined，非严格模式下绑定到全局对象</p>
</blockquote>
<h4 id="4-4-绑定例外"><a href="#4-4-绑定例外" class="headerlink" title="4.4 绑定例外"></a>4.4 绑定例外</h4><p>（1）被忽略的this</p>
<p>如<code>foo.apply(null,arguments)</code>或<code>foo.bind(null,可预设参数)</code>，当函数并不关心this时，可以用null占位，默认规则下会把this绑定到全局对象，这种方式可能会导致许多问题（比如修改了全局对象），可以通过<code>Object.Create(null)</code>创建一个空对象，该对象与{}很像，<strong>但并不会创建Object.prototype这个委托，所以它比{}更空</strong>.</p>
<p>（2）间接引用</p>
<p>容易在赋值的时候发生，传递的是原函数的引用</p>
<p>（3）软绑定:在绑定之后还保留隐式绑定和显式绑定对this值得修改（重点：考虑this不绑定全局对象和undefined时，可修改为其他对象）</p>
<blockquote>
<p>原生JS实现软绑定：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.softBind)&#123;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.softBind=<span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> fn=<span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">//捕获所有curried参数</span></span><br><span class="line">        <span class="keyword">var</span> curried=[].slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">var</span> bound=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply(</span><br><span class="line">                (!<span class="keyword">this</span>||<span class="keyword">this</span>===global)?obj:<span class="keyword">this</span>,curried.concat.apply(curried,<span class="built_in">arguments</span>))</span><br><span class="line">        &#125;;</span><br><span class="line">        bound.prototype=<span class="built_in">Object</span>.create(fn.prototype);<span class="comment">//使fn成为bound的原型</span></span><br><span class="line">        <span class="keyword">return</span> bound;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"name:"</span>+<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;<span class="attr">name</span>:<span class="string">"obj"</span>&#125;,obj1=&#123;<span class="attr">name</span>:<span class="string">"obj1"</span>&#125;,obj2=&#123;<span class="attr">name</span>:<span class="string">"obj2"</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> fooOBJ=foo.softBind(obj);</span><br><span class="line">fooOBJ();<span class="comment">//"obj"</span></span><br><span class="line"><span class="comment">//此处调用采用默认绑定，this绑定到undefined 或全局对象</span></span><br><span class="line"><span class="comment">//在强绑定中这之后this绑定不会再更换，而在软绑定中可通过隐式绑定或显示绑定修改内部this绑定</span></span><br><span class="line">obj2.foo=fooOBJ;</span><br><span class="line">obj2.foo();<span class="comment">//"obj2"</span></span><br><span class="line">fooOBJ.apply(obj1,<span class="built_in">arguments</span>);<span class="comment">//"obj3"</span></span><br></pre></td></tr></table></figure>

<h4 id="4-5-this词法"><a href="#4-5-this词法" class="headerlink" title="4.5 this词法"></a>4.5 this词法</h4><p>ES6中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定this,具体来说，箭头函数会继承外层函数调用的this绑定（无论this绑定到什么），这其实和ES6之前的self=this机制一样</p>
<h3 id="5-事件循环：EventLoop"><a href="#5-事件循环：EventLoop" class="headerlink" title="5. 事件循环：EventLoop"></a>5. 事件循环：EventLoop</h3><h4 id="5-1-浏览器的进程与线程："><a href="#5-1-浏览器的进程与线程：" class="headerlink" title="5.1 浏览器的进程与线程："></a>5.1 浏览器的进程与线程：</h4><p><strong>5.1.1 进程：</strong></p>
<p>进程是cpu的资源分配的最小单位。</p>
<p><strong>多进程</strong>：多进程指的是在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如你可以听歌的同时，打开编辑器敲代码，编辑器和听歌软件的进程之间丝毫不会相互干扰。</p>
<p><strong>浏览器是多进程的，浏览器的进程主要包括以下几种：</strong></p>
<ol>
<li>Browser进程：浏览器的主进程（负责协调，主控）</li>
<li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</li>
<li>GPU进程：最多一个，用于3D绘制</li>
<li><strong>浏览器渲染进程（内核）</strong>：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）</li>
</ol>
<p>在浏览网页时，同时打开几个新的页面， 这就要打开几个浏览窗口，但一旦开启十几个窗口，整个计算机就会越来越慢。</p>
<p><strong>多进程浏览器的优点</strong></p>
<ul>
<li><p>避免页面渲染影响整个浏览器</p>
</li>
<li><p>避免第三方插件影响整个浏览器</p>
</li>
<li><p>多进程充分利用多核优势</p>
</li>
<li><p>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性</p>
<blockquote>
<p><strong>沙盒模型：</strong></p>
</blockquote>
</li>
</ul>
<p>通俗的讲，就是用户打开多个窗口，如果其中一个窗口崩掉了，也不会影响整个浏览器，其他的界面照样正常运行</p>
<p><strong>5.1.2 线程：</strong></p>
<p>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；</p>
<p>进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)。</p>
<p><strong>浏览器的渲染进程（浏览器内核）是多线程的，主要为以下几大类：</strong></p>
<ol>
<li><p><strong>GUI线程</strong></p>
<p>负责渲染浏览器界面HTML元素,当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时,该线程就会执行。在Javascript引擎运行脚本期间,GUI渲染线程都是处于挂起状态的,也就是说被”冻结”了.</p>
</li>
<li><p><strong>Javascript引擎线程</strong></p>
<p>也可以称为JS内核，主要负责处理Javascript脚本程序，例如V8引擎。Javascript引擎线程理所当然是负责解析Javascript脚本，运行代码。</p>
<p><strong>Javascript是单线程的</strong></p>
<p>这是因为Javascript这门脚本语言诞生的使命所致：JavaScript为处理页面中用户的交互，以及操作DOM树、CSS样式树来给用户呈现一份动态而丰富的交互体验和服务器逻辑的交互处理。如果JavaScript是多线程的方式来操作这些UI DOM，则可能出现UI操作的冲突； 如果Javascript是多线程的话，在多线程的交互下，处于UI中的DOM节点就可能成为一个临界资源，假设存在两个线程同时操作一个DOM，一个负责修改一个负责删除，那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果。当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性，Javascript在最初就选择了单线程执行。</p>
<p><strong>GUI 渲染线程 与 JavaScript引擎线程互斥！</strong></p>
<p>由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JavaScript线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JavaScript引擎为互斥的关系，当JavaScript引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到引擎线程空闲时立即被执行。</p>
<p><strong>JS阻塞页面加载</strong></p>
<p>由于GUI渲染线程与JavaScript执行线程是互斥的关系，当浏览器在执行JavaScript程序的时候，GUI渲染线程会被保存在一个队列中，直到JS程序执行完成，才会接着执行。因此如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p>
</li>
<li><p><strong>事件触发线程</strong></p>
<p>当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。</p>
</li>
<li><p><strong>定时器线程</strong></p>
<p>浏览器定时计数器并不是由JavaScript引擎计数的, 因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。</p>
</li>
<li><p><strong>网络请求线程</strong></p>
<p>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript引擎的处理队列中等</p>
<p>待处理。</p>
</li>
</ol>
<h4 id="5-2-EventLoop：事件循环"><a href="#5-2-EventLoop：事件循环" class="headerlink" title="5.2 EventLoop：事件循环"></a>5.2 EventLoop：事件循环</h4><p><strong>在ES6之前：</strong>所有JS的执行环境都有事件循环的内置机制，它随着时间的推移每次都调用JS引擎处理程序中多个代码块的执行。也就是说，是JS周围的环境来调度这些事情的。</p>
<p><img src="/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.png" alt="事件循环"></p>
<p>事件循环有一个简单的任务 —— 去监控执行栈和任务队列。如果执行栈是空的，它就会取出任务队列中的第一个事件，然后将它压入到任务中，然后运行它。</p>
<p>这样的迭代在事件循环中被称作一个 <strong>tick</strong>。每一个事件就是一个回调函数。</p>
<p><strong>5.2.1 执行栈和任务队列</strong></p>
<p><strong>栈（stack）</strong></p>
<p>栈在javascript中又称执行栈，调用栈，是一种后进先出的数组结构，<br> <code>Javascript</code> 有一个 主线程（<code>main thread</code>）和 调用栈(或执行栈<code>call-stack</code>)，主线各所有的任务都会被放到调用栈等待主线程执行。<br> JS调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空。</p>
<p><strong>队列（Queue）</strong></p>
<p>队列即任务队列<code>Task Queue</code>，是一种先进先出的一种数据结构。在队尾添加新元素，从队头移除元素。</p>
<p><strong>5.2.2 同步任务和异步任务</strong></p>
<p>javascript是单线程。单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。<br>于是js所有任务分为两种：同步任务，异步任务<br><strong>同步任务</strong>是调用立即得到结果的任务，同步任务在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；</p>
<p><strong>异步任务</strong>是调用无法立即得到结果，需要额外的操作才能预期结果的任务，异步任务不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p>
<p> JS引擎遇到异步任务（DOM事件监听、网络请求、setTimeout计时器等），会交给<strong>相应的线程</strong>单独去维护异步任务，等待某个时机（计时器结束、网络请求成功、用户点击DOM），然后由 事件触发线程 将异步对应的 回调函数 加入到消息队列中，消息队列中的回调函数等待被执行。</p>
<p><strong>具体来说，异步运行机制如下：</strong></p>
<ul>
<li>（1）所有同步任务都在主线程上执行，形成一个[执行栈]</li>
<li>（2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li>
<li>（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li>
<li>（4）主线程不断重复上面的第三步。</li>
</ul>
<p>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）</p>
<p><img src="/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.png" alt="事件循环"></p>
<p><strong>5.2.3 宏任务与微任务</strong></p>
<p>在挂起任务时，JS 引擎会将所有任务按照类别分到这两个队列中，首先在 宏任务 的队列中取出第一个任务，执行完毕后取出 微任务 队列中的所有任务顺序执行；之后再取 宏任务，周而复始，直至两个队列的任务都取完。</p>
<p>在事件循环中，每进行一次循环操作称为tick，通过阅读规范可知，每一次 tick 的任务处理模型是比较复杂的，其关键的步骤可以总结如下：</p>
<ol>
<li>在此次 tick 中选择最先进入队列的任务( oldest task )，如果有则执行(一次)</li>
<li>检查是否存在 Microtasks ，如果存在则不停地执行，直至清空Microtask Queue</li>
<li>更新 render</li>
<li>主线程重复执行上述步骤</li>
</ol>
<p>可以用一张图来说明下流程：</p>
<p><img src="/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%AE%8F%E4%BB%BB%E5%8A%A1.jpg" alt="微任务与宏任务"></p>
<p>规范中规定，task分为两大类, 分别是 Macro Task （宏任务）和 Micro Task（微任务）, 并且每个宏任务结束后, 都要清空所有的微任务,这里的 Macro Task也是我们常说的 task ，有些文章并没有对其做区分，后面文章中所提及的task皆看做宏任务( macro task)。</p>
<p>(macro)task 主要包含：script( 整体代码)、setTimeout、setInterval、I/O、UI 交互事件、setImmediate(Node.js 环境)</p>
<p>microtask主要包含：Promise、MutaionObserver、process.nextTick(Node.js 环境)</p>
<p>setTimeout/Promise 等API便是任务源，而进入任务队列的是由他们指定的具体执行任务。来自不同任务源的任务会进入到不同的任务队列。其中 setTimeout 与 setInterval 是同源的。</p>
<blockquote>
<p><strong>思考：为什么要区分宏任务和微任务？</strong></p>
<p>便于紧急任务插队？</p>
</blockquote>
<h3 id="6-异步编程的几种方法"><a href="#6-异步编程的几种方法" class="headerlink" title="6. 异步编程的几种方法"></a>6. 异步编程的几种方法</h3><h4 id="6-1-回调函数"><a href="#6-1-回调函数" class="headerlink" title="6.1 回调函数"></a>6.1 回调函数</h4><p><strong>6.1.1 回调函数的优缺点：</strong></p>
<p>回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而回调函数有一个致命的弱点，就是容易写出回调地狱</p>
<p><strong>6.1.2 多层回调会导致回掉地狱，那么如何解决这种问题呢？</strong></p>
<p>（1）promise</p>
<p>（2）generater</p>
<p>（3）async/await</p>
<h4 id="6-2-事件监听"><a href="#6-2-事件监听" class="headerlink" title="6.2 事件监听"></a>6.2 事件监听</h4><p>采用事件驱动模式，任务的执行不取决于代码的顺序，而取决于某个事件是否发生，如：<code>func.trigger(&#39;done&#39;)</code>：通过trigger函数触发某个事件。</p>
<p>这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合”（Decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。</p>
<h4 id="6-3-发布-订阅"><a href="#6-3-发布-订阅" class="headerlink" title="6.3 发布/订阅"></a>6.3 发布/订阅</h4><h4 id="6-4-Promise"><a href="#6-4-Promise" class="headerlink" title="6.4 Promise:"></a>6.4 Promise:</h4><p><strong>6.4.1 Promise的含义</strong></p>
<p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<p><strong><code>Promise</code>对象有以下两个特点。</strong></p>
<p>（1）<strong>对象的状态不受外界影响：</strong><code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>
<p>（2）<strong>一旦状态改变，就不会再变，任何时候都可以得到这个结果：</strong><code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>
<p><strong>6.4.2 Promise基本用法</strong></p>
<p>以Ajax异步请求为例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getJson=<span class="function"><span class="keyword">function</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> promise=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> handler=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.readyState!=<span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status===<span class="number">200</span>)&#123;</span><br><span class="line">                resolve(<span class="keyword">this</span>.response);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">const</span> client=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        client.open(<span class="string">"GET"</span>,url);</span><br><span class="line">        client.onreadystatechange=handler;</span><br><span class="line">        client.responseType=<span class="string">"json"</span>;</span><br><span class="line">        client.setRequestHeader(<span class="string">"Accept"</span>,<span class="string">"application/json"</span>);</span><br><span class="line">        client.send();</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line">getJson(<span class="string">"./posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Contents:'</span>+result);<span class="comment">//result为resolve()函数的参数，此处为返回的repsonse</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'出错率！'</span>+err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>6.4.3 Promise.prototype.then()</strong></p>
<p>它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，<code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数（可选）是<code>rejected</code>状态的回调函数。</p>
<p>可以采用链式写法：then方法后面再调用另一个then方法</p>
<p><strong>6.4.4  Promise.prototype.catch()</strong></p>
<p><code>Promise.prototype.catch</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。</p>
<p><strong>Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。</strong></p>
<p><strong>6.4.5 Promise.prototype.finally</strong></p>
<p><code>finally</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p>
<p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p>
<p><strong>6.4.6 Promise.all()</strong></p>
<p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p=<span class="built_in">Promise</span>.all([p1,p2,p3]);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Promise.all()</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例，如果不是，就会先调用下面讲到的<strong><code>Promise.resolve</code></strong>方法，将参数转为 Promise 实例，再进一步处理。另外，<code>Promise.all()</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</p>
<p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p>
<p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p>
<p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p>
<p><strong>6.4.7 Promise.race()</strong></p>
<p>Promise.race()方法同样是将多个Promise实例，包装成一个新的Promise实例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p>
<p><strong>6.4.8 Promise.allsettled()</strong></p>
<p><code>Promise.allSettled()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束。该方法由 <a href="https://github.com/tc39/proposal-promise-allSettled" target="_blank" rel="noopener">ES2020</a> 引入。</p>
<p><strong>6.4.9 Promise.any()</strong></p>
<p><code>Promise.any()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。该方法目前是一个第三阶段的<a href="https://github.com/tc39/proposal-promise-any" target="_blank" rel="noopener">提案</a> 。</p>
<p><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是不会因为某个 Promise 变成<code>rejected</code>状态而结束</p>
<h4 id="6-5-Generator-生成器"><a href="#6-5-Generator-生成器" class="headerlink" title="6.5 Generator:生成器"></a>6.5 Generator:生成器</h4><h4 id="6-6-async-await"><a href="#6-6-async-await" class="headerlink" title="6.6 async/await"></a>6.6 async/await</h4><h3 id="7-前端中的事件流"><a href="#7-前端中的事件流" class="headerlink" title="7. 前端中的事件流"></a>7. 前端中的事件流</h3><h4 id="7-1-事件"><a href="#7-1-事件" class="headerlink" title="7.1 事件"></a>7.1 事件</h4><h4 id="7-2-冒泡"><a href="#7-2-冒泡" class="headerlink" title="7.2 冒泡"></a>7.2 冒泡</h4><h4 id="7-3-捕获"><a href="#7-3-捕获" class="headerlink" title="7.3 捕获"></a>7.3 捕获</h4><h4 id="7-4-如何让事件先冒泡后捕获？"><a href="#7-4-如何让事件先冒泡后捕获？" class="headerlink" title="7.4 如何让事件先冒泡后捕获？"></a>7.4 如何让事件先冒泡后捕获？</h4><h4 id="7-5-事件委托"><a href="#7-5-事件委托" class="headerlink" title="7.5 事件委托"></a>7.5 事件委托</h4><h4 id="7-6-mouseover-和mouseenter的区别"><a href="#7-6-mouseover-和mouseenter的区别" class="headerlink" title="7.6 mouseover 和mouseenter的区别"></a>7.6 mouseover 和mouseenter的区别</h4><h3 id="8-JS的节流和防抖"><a href="#8-JS的节流和防抖" class="headerlink" title="8. JS的节流和防抖"></a>8. JS的节流和防抖</h3><h3 id="9-JS的垃圾回收机制"><a href="#9-JS的垃圾回收机制" class="headerlink" title="9. JS的垃圾回收机制"></a>9. JS的垃圾回收机制</h3><p><a href="https://www.cnblogs.com/echolun/p/11503915.html" target="_blank" rel="noopener">参考博客</a></p>
<h4 id="9-1-栈、堆、队列"><a href="#9-1-栈、堆、队列" class="headerlink" title="9.1 栈、堆、队列"></a>9.1 栈、堆、队列</h4><p>JavaScript内存空间分为栈，堆，池，队列。其中栈存放变量，基本类型数据与指向复杂类型数据的引用指针；堆存放复杂类型数据；池又称为常量池，用于存放常量；而队列在任务队列也会使用。</p>
<h4 id="9-2-JS垃圾回收机制"><a href="#9-2-JS垃圾回收机制" class="headerlink" title="9.2 JS垃圾回收机制"></a>9.2 JS垃圾回收机制</h4><p>离开作用域的值被自动标记为可以回收，因此将在垃圾收集期间被删除</p>
<p>垃圾收集机制的原理：找出那些不再继续使用的变量，然后释放其占用的内存，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间）周期性地执行这一操作。</p>
<p><strong>如何标识无用变量</strong>：垃圾收集方式</p>
<p>（1）标记清除：思想是给当前不使用的值加上标记，然后再回收其内存。（<strong>JS中最常用的</strong>）</p>
<p>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后去掉环境中的变量以及被环境中变量引用的变量的标记，在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后垃圾收集机器完成<strong>内存清除</strong>工作，销毁那些带标记的值并回收他们所使用的内存空间。</p>
<p>（2）引用计数：（不太常见）跟踪记录每个值被引用的次数，当引用次数变为0时，将其占用的内存空间回收回来。但有一个严重问题：<strong>循环引用</strong>，因此被放弃了。</p>
<p>（3）性能问题：如何确定垃圾收集的时间间隔：IE7：静态临界值调整为动态修正（&lt;15%：临界值加倍；&gt;85%：重置回默认临界值）</p>
<p>（4）管理内存：<strong>解除引用</strong>：一旦数据不再有用，通过将其值设为null来释放其引用，目的是让值脱离执行环境，以便垃圾收集器下次运行时将其回收，同时也有助于消除循环引用现象。</p>
<h4 id="9-3-如何防止内存泄漏？"><a href="#9-3-如何防止内存泄漏？" class="headerlink" title="9.3 如何防止内存泄漏？"></a>9.3 如何防止内存泄漏？</h4><p>（1）减少使用全局变量，若一定要使用要记得在使用完毕后手动释放，如将变量指向null；</p>
<p>（2）避免被遗忘的定时器和回调函数；</p>
<p>（3）及时释放闭包中的变量；</p>
<p>（4）DOM的引用</p>
<h3 id="10-AJAX解决浏览器缓存问题"><a href="#10-AJAX解决浏览器缓存问题" class="headerlink" title="10. AJAX解决浏览器缓存问题"></a>10. AJAX解决浏览器缓存问题</h3><h3 id="11-eval是做什么的-（欺骗词法）"><a href="#11-eval是做什么的-（欺骗词法）" class="headerlink" title="11. eval是做什么的?（欺骗词法）"></a>11. eval是做什么的?（欺骗词法）</h3><p><strong>eval(str)：</strong>它的功能是将对应的字符串解析成js并执行，可以在运行期修改书写期的词法作用域:</p>
<p><strong>with(obj）：</strong>with可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符</p>
<p><strong>eval()函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而with()声明实际上是根据你传给它的对象凭空创建了一个新的词法作用域</strong></p>
<p><strong>为什么不推荐使用eval()和with()?</strong></p>
<p>(1)欺骗词法会导致性能下降</p>
<p>(2)会被严格模式所限制，with被完全禁止，而在保留核心功能的前提下，间接或非安全地使用eval()也被禁止了</p>
<p><strong>为什么会导致性能下降？</strong></p>
<p>JS引擎会在编译阶段进行数项的性能优化，其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。但如果引擎在代码中发现了eval()和with()，在悲观情况下可能会做不到任何优化。</p>
<p><strong>引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的</strong></p>
<h3 id="12-如何理解前端模块化？"><a href="#12-如何理解前端模块化？" class="headerlink" title="12. 如何理解前端模块化？"></a>12. 如何理解前端模块化？</h3><h4 id="12-1-说一下Commonjs-AMD-CMD"><a href="#12-1-说一下Commonjs-AMD-CMD" class="headerlink" title="12.1 说一下Commonjs,AMD,CMD"></a>12.1 说一下Commonjs,AMD,CMD</h4><h3 id="13-实现一个once函数，传入函数参数只执行一次"><a href="#13-实现一个once函数，传入函数参数只执行一次" class="headerlink" title="13. 实现一个once函数，传入函数参数只执行一次"></a>13. 实现一个once函数，传入函数参数只执行一次</h3><h3 id="14-如何实现一个私有变量，用getName方法可以访问，不能直接访问"><a href="#14-如何实现一个私有变量，用getName方法可以访问，不能直接访问" class="headerlink" title="14. 如何实现一个私有变量，用getName方法可以访问，不能直接访问"></a>14. 如何实现一个私有变量，用getName方法可以访问，不能直接访问</h3><p>（1）通过#设置类中的私有变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    #name='Bob';</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        this.#name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    getName()&#123;</span><br><span class="line">        return this.#name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> my=<span class="keyword">new</span> Person(<span class="string">'Lily'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(my.getName());</span><br></pre></td></tr></table></figure>

<p>（2）设置属性值的getter和setter</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="15-重排和重绘"><a href="#15-重排和重绘" class="headerlink" title="15. 重排和重绘"></a>15. 重排和重绘</h4><h3 id="15-重排和重绘-1"><a href="#15-重排和重绘-1" class="headerlink" title="15. 重排和重绘"></a>15. 重排和重绘</h3><p>重排（重构/回流/reflow）：当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建, 这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。</p>
<p>重绘（repaint或redraw）：当盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器便把这些元素都按照各自的特性绘制一遍，将内容呈现在页面上。重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。</p>
<p>触发重绘的条件：改变元素外观属性。如：color，background-color等。</p>
<p>注意：table及其内部元素可能需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花两倍时间，这就是我们尽量避免使用table布局页面的原因之一。</p>
<p>重绘和重排的关系：在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。所以，<strong>重排必定会引发重绘，但重绘不一定会引发重排。</strong></p>
<h3 id="16-const、let、var"><a href="#16-const、let、var" class="headerlink" title="16. const、let、var"></a>16. const、let、var</h3><h4 id="16-1-let-和-var-的区别："><a href="#16-1-let-和-var-的区别：" class="headerlink" title="16.1 let 和 var 的区别："></a>16.1 let 和 var 的区别：</h4><p>（1）let有块作用域，所声明的变量只在let命令所在的代码块内有效（for循环：<em>JavaScript引擎内部可以记住上一次循环的值</em>）</p>
<p>（2）let不存在变量提升：let:报错ReferenceError  var:输出undefined</p>
<p>（3）let暂时性死区：ES6 明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。“暂时性死区”也意味着<code>typeof</code>不再是一个百分之百安全的操作。</p>
<p>（4）let不允许在相同作用域内重复声明同一个变量</p>
<h4 id="16-2-为什么需要块级作用域？"><a href="#16-2-为什么需要块级作用域？" class="headerlink" title="16.2 为什么需要块级作用域？"></a>16.2 为什么需要块级作用域？</h4><p><strong>场景一：</strong>内层变量可能会覆盖外层变量；</p>
<p><strong>场景二：</strong>用来计数的循环变量泄露为全局变量</p>
<h4 id="16-3-const命令"><a href="#16-3-const命令" class="headerlink" title="16.3 const命令"></a>16.3 const命令</h4><p>（1）<code>const</code>声明的变量不得改变值，这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>
<p>（2）<code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效</p>
<p>（3）const命令声明的常量也不提升，也存在暂时性死区</p>
<p>（4）const声明的常量同样不可以重复声明</p>
<p><code>const</code>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于将对象声明为常量，该常量所存储的地址不能变，但对象本身可以变。可以用Object.freeze()方法将对象冻结</p>
<h3 id="17-性能问题"><a href="#17-性能问题" class="headerlink" title="17.性能问题"></a>17.性能问题</h3><p><a href="https://github.com/fouber/blog/issues/3" target="_blank" rel="noopener">https://github.com/fouber/blog/issues/3</a></p>
<h3 id="18-深拷贝和浅拷贝"><a href="#18-深拷贝和浅拷贝" class="headerlink" title="18.深拷贝和浅拷贝"></a>18.深拷贝和浅拷贝</h3><h4 id="18-1-什么是深拷贝和浅拷贝？"><a href="#18-1-什么是深拷贝和浅拷贝？" class="headerlink" title="18.1 什么是深拷贝和浅拷贝？"></a>18.1 什么是深拷贝和浅拷贝？</h4><p>浅拷贝和深拷贝都只针对于引用数据类型，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存；但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象；<br>   区别：浅拷贝只复制对象的第一层属性、深拷贝可以对对象的属性进行递归复制；</p>
<h4 id="18-2-常用的拷贝API："><a href="#18-2-常用的拷贝API：" class="headerlink" title="18.2 常用的拷贝API："></a>18.2 常用的拷贝API：</h4><p><strong>（1）Array.slice和Array.concat:只拷贝第一层</strong></p>
<p><strong>（2）Object.assign(targer,source1,source2…)：浅拷贝，只拷贝第一层</strong></p>
<p><strong>（3）扩展运算符：<code>...obj</code>：浅拷贝，只拷贝第一层</strong></p>
<h4 id="18-3-实现深拷贝的方法："><a href="#18-3-实现深拷贝的方法：" class="headerlink" title="18.3 实现深拷贝的方法："></a>18.3 实现深拷贝的方法：</h4><p><strong>（1）递归实现深拷贝</strong></p>
<p>缺陷：当遇到两个互相引用的对象，会出现死循环的情况，为了避免相互引用的对象导致死循环的情况，则应该在遍历的时候判断是否相互引用对象，如果是则退出循环；即<code>obj[i]==obj</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> copy=obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? []:&#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(obj &amp;&amp; <span class="keyword">typeof</span> obj===<span class="string">'object'</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> obj)&#123;</span><br><span class="line">            <span class="comment">//只拷贝实例属性</span></span><br><span class="line">            <span class="keyword">if</span>(obj.hasOwnProperty(prop))&#123;</span><br><span class="line">                <span class="keyword">if</span>(obj[prop]==obj)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (obj[prop]&amp;&amp;<span class="keyword">typeof</span> obj[prop]===<span class="string">'object'</span>)&#123;</span><br><span class="line">                    copy[prop]=deepCopy(obj[prop]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    copy[prop]=obj[prop];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）借用JSON对象的parse和stringfy</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> strCopy=<span class="built_in">JSON</span>.stringify(obj);</span><br><span class="line">    <span class="keyword">let</span> copy=<span class="built_in">JSON</span>.parse(strCopy);</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）除了上面两种方法之外，我们还可以借用JQ的extend方法。</strong></p>
<p><strong><code>$.extend( [deep ], target, object1 [, objectN ] )</code></strong></p>
<p><strong>deep</strong>表示是否深拷贝，为true为深拷贝，为false，则为浅拷贝</p>
<p><strong>target</strong> <strong>Object</strong>类型 目标对象，其他对象的成员属性将被附加到该对象上。</p>
<p><strong>object1 objectN</strong>可选。 Object类型 第一个以及第N个被合并的对象。 </p>
<h3 id="19-前端工程化与性能"><a href="#19-前端工程化与性能" class="headerlink" title="19. 前端工程化与性能"></a>19. 前端工程化与性能</h3><h4 id="19-1-前段工程的三个阶段"><a href="#19-1-前段工程的三个阶段" class="headerlink" title="19.1 前段工程的三个阶段"></a>19.1 前段工程的三个阶段</h4><p><strong>第一阶段：库/框架选型，代码规范：提高开发效率</strong></p>
<p><strong>第二阶段：简单构建优化：提高运行效率，即性能</strong></p>
<p><strong>第三阶段：JS/CSS模块化开发：分治！提高维护效率</strong></p>
<p>JS模块化：Common JS , AMD,UMD,ES6 Module</p>
<p>CSS模块化：基本都是在less,sass,stylus等预处理器的import/mixin特性支持下实现的 </p>
<p><strong>第四阶段：</strong>组件化开发和资源管理</p>
<p>当我们要开发一款完整的Web应用时，前端将面临更多的工程问题，比如：</p>
<ul>
<li>大体量：多功能、多页面、多状态、多系统；</li>
<li>大规模：多人甚至多团队合作开发；</li>
<li>高性能：CDN部署、<a href="https://developers.google.com/speed/docs/insights/LeverageBrowserCaching" target="_blank" rel="noopener">缓存控制</a>、<a href="https://developers.google.com/speed/docs/insights/LeverageBrowserCaching" target="_blank" rel="noopener">文件指纹</a>、缓存复用、请求合并、按需加载、同步/异步加载、移动端<a href="https://developers.google.com/speed/docs/insights/mobile" target="_blank" rel="noopener">首屏CSS内嵌</a>、HTTP 2.0服务端<a href="http://chimera.labs.oreilly.com/books/1230000000545/ch12.html#HTTP2_PUSH" target="_blank" rel="noopener">资源推送</a>。</li>
</ul>
<p><strong>组件化开发：</strong></p>
<p>整个前端项目可以划分为这么几种开发概念：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>JS模块</td>
<td>独立的算法和数据单元</td>
<td>浏览器环境检测(detect)，网络请求(ajax)，应用配置(config)，DOM操作(dom)，工具函数(utils)，以及组件里的JS单元</td>
</tr>
<tr>
<td>CSS模块</td>
<td>独立的功能性样式单元</td>
<td>栅格系统(grid)，字体图标(icon-fonts)，动画样式(animate)，以及组件里的CSS单元</td>
</tr>
<tr>
<td>UI组件</td>
<td>独立的可视/可交互功能单元</td>
<td>页头(header)，页尾(footer)，导航栏(nav)，搜索框(search)</td>
</tr>
<tr>
<td>页面</td>
<td>前端这种GUI软件的界面状态，是UI组件的容器</td>
<td>首页(index)，列表页(list)，用户管理(user)</td>
</tr>
<tr>
<td>应用</td>
<td>整个项目或整个站点被称之为应用，由多个页面组成</td>
<td></td>
</tr>
</tbody></table>
<p><strong>“智能”静态资源管理</strong></p>
<p>前端和客户端GUI有一个很大的不同：<strong>前端是一种远程部署，运行时增量下载的GUI软件</strong></p>
<p>前端应用没有安装过程，其所需程序资源都部署在远程服务器，用户使用浏览器访问不同的页面来加载不同的资源，随着页面访问的增加，渐进式的将整个程序下载到本地运行，“增量下载”是前端在工程上有别于客户端GUI软件的根本原因。</p>
<p>如果用户第一次访问页面就强制其加载全站静态资源再展示，相信会有很多用户因为失去耐心而流失。根据“增量”的原则，我们应该精心规划每个页面的资源加载策略，使得用户无论访问哪个页面都能按需加载页面所需资源，没访问过的无需加载，访问过的可以缓存复用，最终带来流畅的应用体验。</p>
<p>由“增量”原则引申出的前端优化技巧几乎成为了性能优化的核心，有加载相关的按需加载、延迟加载、预加载、请求合并等策略；有缓存相关的浏览器缓存利用，缓存更新、缓存共享、非覆盖式发布等方案；还有复杂的BigRender、BigPipe、Quickling、PageCache等技术。这些优化方案无不围绕着如何将增量原则做到极致而展开。</p>
<p><strong>静态网页资源的管理和优化</strong></p>
<p>静态资源管理系统=资源表+资源加载框架</p>
<blockquote>
<p><strong>资源表：</strong>资源表是一份数据文件（比如JSON），是项目中所有静态资源（主要是JS和CSS）的构建信息记录，通过构建工具扫描项目源码生成，是一种k-v结构的数据，以每个资源的id为key，记录了资源的类别、部署路径、依赖关系、打包合并等内容。</p>
<p><strong>资源加载框架：</strong>资源加载框架则提供一些资源引用的API，让开发者根据id来引用资源，替代静态的script/link标签来收集、去重、按需加载资源。调用这些接口时，框架通过查表来查找资源的各项信息，并递归查找其依赖的资源的信息，然后我们可以在这个过程中实现各种性能优化算法来“智能”加载资源。</p>
<p><img src="/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E6%A1%86%E6%9E%B6.png" alt="资源加载框架"></p>
</blockquote>
<h4 id="19-2-浅析前端工程化"><a href="#19-2-浅析前端工程化" class="headerlink" title="19.2 浅析前端工程化"></a>19.2 浅析前端工程化</h4><p><a href="https://www.cnblogs.com/ihardcoder/p/5378290.html" target="_blank" rel="noopener">参考</a></p>
<h5 id="19-2-1-前端工程化，面临的问题是如何提高编码-gt-测试-gt-维护阶段的生产效率"><a href="#19-2-1-前端工程化，面临的问题是如何提高编码-gt-测试-gt-维护阶段的生产效率" class="headerlink" title="19.2.1 前端工程化，面临的问题是如何提高编码-&gt;测试-&gt;维护阶段的生产效率"></a>19.2.1 前端工程化，面临的问题是如何提高<strong>编码-&gt;测试-&gt;维护</strong>阶段的生产效率</h5><h5 id="19-2-2-要解决前端工程化的问题，可以从两个角度入手：开发和部署。"><a href="#19-2-2-要解决前端工程化的问题，可以从两个角度入手：开发和部署。" class="headerlink" title="19.2.2 要解决前端工程化的问题，可以从两个角度入手：开发和部署。"></a>19.2.2 要解决前端工程化的问题，可以从两个角度入手：<strong>开发</strong>和<strong>部署</strong>。</h5><p>从<strong>开发角度</strong>，要解决的问题包括：</p>
<p>（1）提高开发生产效率；</p>
<p>（2）降低维护难度。</p>
<p>这两个问题的解决方案有两点：</p>
<p>（1）制定开发规范，提高团队协作能力；</p>
<p>（2）分治。软件工程中有个很重要的概念叫做<strong>模块化开发</strong>其中心思想就是分治。</p>
<p>从<strong>部署角度</strong>，要解决的问题主要是<strong>资源管理</strong>，包括：</p>
<p>（1）代码审查；</p>
<p>（2）压缩打包；</p>
<p>（3）增量更新；</p>
<p>（4）单元测试；</p>
<p><strong>模块化开发：</strong>模块白盒，组件黑盒。颗粒度不同</p>
<h5 id="19-2-3-构建-amp-编译"><a href="#19-2-3-构建-amp-编译" class="headerlink" title="19.2.3 构建&amp;编译"></a>19.2.3 构建&amp;编译</h5><p>2016年节点下，一个典型的web前后端协作模式如下图：</p>
<p><img src="/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/before.png" alt="before"></p>
<p><strong>大前端模式下：</strong></p>
<p><img src="/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/now.png" alt="now"></p>
<p>大前端体系下，前端开发人员掌握着Node.js搭建的web server层。与上文提到的常规前端开发体系下相比，省略了mock server的角色，但是构建在大前端体系下的作用并没有发生改变。也就是说，不论是大前端还是“小”前端，构建阶段在两种模式下的作用完全一致，<strong>构建的作用就是对静态资源以及模板进行处理</strong>，换句话说：<strong>构建的核心是资源管理</strong>。</p>
<p><strong>什么是资源管理？</strong></p>
<p>前端的资源可以分为<strong>静态资源</strong>和<strong>模板</strong>。模板对静态资源是引用关系，两者相辅相成，构建过程中需要对两种资源使用不同的构建策略。</p>
<p>静态资源包括js、css、图片等文件，目前随着一些新规范和css预编译器的普及，通常开发阶段的静态资源是：</p>
<ol>
<li>es6/7规范的文件；</li>
<li>less/sass等文件（具体看团队技术选型）；</li>
<li>[可选]独立的小图标，在构建阶段使用工具处理成spirit图片。</li>
</ol>
<p>构建可以分为<strong>工具层面</strong>和<strong>平台层面</strong>的功能：</p>
<ul>
<li>工具层面</li>
</ul>
<ol>
<li>预编译，包括es6/7语法转译（比如babel）、css预编译器处理（如将less/sass编译成css）、spirit图片生成；</li>
<li>依赖打包。分析文件依赖关系，将同步依赖的的文件打包在一起，减少http请求数量；</li>
<li>资源嵌入。比如小于10KB的图片编译为base64格式嵌入文档，减少一次http请求；（对于jpg格式的图片，每一个图片相当于一次http请求，图片多了的话，耗性能比较严重。而将jpg转化成base64格式的图片，则极大地减少了请求数，因为base64是文本格式，可以直接放在body里。一般对于小于10KB大小的图片进行base64转码）</li>
<li>文件压缩。减小文件体积；</li>
<li>hash指纹。通过给文件名加入hash指纹，以应对浏览器缓存引起的静态资源更新问题；</li>
<li>代码审查。避免上线文件的低级错误；</li>
<li>模板构建。</li>
</ol>
<ul>
<li>平台层面</li>
</ul>
<ol>
<li>文件监听。配合动态构建、浏览器自动刷新等功能，提高开发效率；</li>
<li>mock server。并非所有前端团队都是大前端（事实上很少团队是大前端），即使在大前端体系下，mock server的存在也是很有必要的；</li>
</ol>
<h5 id="19-2-4-总结"><a href="#19-2-4-总结" class="headerlink" title="19.2.4 总结;"></a>19.2.4 总结;</h5><p>一个完整的前端工程体系应该包括：</p>
<p>（1）统一的开发规范；</p>
<p>（2）组件化/模块化开发；</p>
<p>（3）构建流程。</p>
<h4 id="19-3-前端功能化-构建"><a href="#19-3-前端功能化-构建" class="headerlink" title="19.3 前端功能化-构建"></a>19.3 前端功能化-构建</h4><p><strong>构建的核心是资源管理，</strong>就是把前端工程师开发的源代码进行编译、压缩、打包等一系列操作，最终产出可以直接上线或者可供后端工程师的资源。</p>
<p>构建可以划分为<strong>纯前端构建</strong>（不涉及后端模板的构建，经过构建之后的前端代码可以直接上线，这种情况下大多是数据驱动UI的web应用，可以使用一些框架如:React,Vue等）和<strong>前后端协作构建</strong></p>
<h5 id="19-3-1-基本功能"><a href="#19-3-1-基本功能" class="headerlink" title="19.3.1 基本功能"></a>19.3.1 基本功能</h5><h5 id="19-3-2-整体流程"><a href="#19-3-2-整体流程" class="headerlink" title="19.3.2 整体流程"></a>19.3.2 整体流程</h5><p><img src="/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B.png" alt="构建流程"></p>
<p>上图中提到的各个构建行为中，代码审查、预编译、uglify&amp;compress、hash指纹实现较容易，各构建模式中没有差异，而依赖打包管理和模板构建是需要额外配置并且方案不唯一。</p>
<p>模板前端构建和后端构建的对比如下：<br><img src="/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/%E5%89%8D%E5%90%8E%E7%AB%AF%E6%A8%A1%E6%9D%BF%E6%9E%84%E5%BB%BA.png" alt="前后端模板构建"></p>
<p>根据表格的对比数据可以看出模板后端构建相比前端构建有很大优势。但是作为构建平台，应该同时支持两种模式。所以在开发构建平台的时候，开发者应该提供前端构建的功能接口，由用户选择是否采用。</p>
<h4 id="19-4-前端模块化："><a href="#19-4-前端模块化：" class="headerlink" title="19.4 前端模块化："></a>19.4 前端模块化：</h4><h5 id="19-4-1-CommonJS-AMD-CMD-ES6的对比"><a href="#19-4-1-CommonJS-AMD-CMD-ES6的对比" class="headerlink" title="19.4.1 CommonJS, AMD, CMD, ES6的对比"></a>19.4.1 CommonJS, AMD, CMD, ES6的对比</h5><ul>
<li><p><strong>CommonJS,AMD,CMD在ES5中就已经实现;</strong></p>
</li>
<li><p><strong>AMD/CMD/CommonJs是JS模块化开发的标准，目前对应的实现是RequireJs/SeaJs/nodeJs.</strong></p>
</li>
<li><p><strong>CommonJs主要针对服务端，AMD/CMD主要针对浏览器端，所以最容易混淆的是AMD/CMD。</strong></p>
<p>针对服务器端和针对浏览器端有什么本质的区别呢？服务器端一般采用同步加载文件，也就是说需要某个模块，服务器端便停下来，等待它加载再执行。这里如果有其他后端语言，如java，经验的‘玩家’应该更容易理解。而浏览器端要保证效率，需要采用异步加载，这就需要一个预处理，提前将所需要的模块文件并行加载好。</p>
<p><strong>AMD/CMD区别：虽然都是异步加载，最明显的区别就是在模块定义时对依赖的处理不同</strong>）</p>
<ul>
<li>AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块</li>
<li>CMD推崇就近依赖，只有在用到某个模块的时候再去require</li>
</ul>
<p><strong>通俗来说：</strong><br> AMD在加载完成定义（<code>define</code>）好的模块就会立即执行，所有执行完成后，遇到<code>require</code>才会执行主逻辑。（提前加载）<br> <code>CMD</code>在加载完成定义（<code>define</code>）好的模块，仅仅是下载不执行，在遇到<code>require</code>才会执行对应的模块。（按需加载）<br> <code>AMD</code>用户体验好，因为没有延迟，<code>CMD</code>性能好，因为只有用户需要的时候才执行。</p>
</li>
<li><p>如何使用？CommonJs的话，因为nodeJs就是它的实现，所以使用node就行，也不用引入其他包。AMD则是通过<code>&lt;script&gt;</code>标签引入RequireJs，具体语法还是去看官方文档或者百度一下吧。CMD则是引入SeaJs。</p>
</li>
</ul>
<h5 id="19-4-2-模块化主要解决两个问题：“命名冲突”，“文件依赖”"><a href="#19-4-2-模块化主要解决两个问题：“命名冲突”，“文件依赖”" class="headerlink" title="19.4.2 模块化主要解决两个问题：“命名冲突”，“文件依赖”"></a>19.4.2 模块化主要解决两个问题：“命名冲突”，“文件依赖”</h5><p><strong>（1）CommonJS :用于Node环境</strong></p>
<p>在CommonJS规范下,一个模块想要对外暴露变量，可以用<code>module.export=variable;</code>一个模块要引入其他模块暴露的变量，用<code>var ref=require(&#39;module_name&#39;)</code>,就拿到了引用模块的变量。</p>
<p><strong>在Node环境中，有两种方法可以在一个模块中输出变量：</strong></p>
<p>在node.js中提供了module和exports两个对象，module对象中包含exports属性，<code>module.exports</code>和<code>exports</code>默认情况下指向同一块内存，初始状态都是{},而模块文件默认返回的是<code>module.exports</code>，因此不能对<code>exports</code>赋值字面量对象，函数以及数组，会改变exports对象指向的内存。</p>
<ul>
<li>对<code>module.export</code>赋值</li>
<li>直接使用exports</li>
</ul>
<p><strong>（2）AMD（用于浏览器环境）</strong>：RequireJS是AMD规范的实现</p>
<p>AMD是”Asynchronous Module Definition”的简写，也就是异步模块定义。它采用异步方式加载模块。通过define方法去定义模块，require方法去加载模块。</p>
<p>RequireJS：是一个AMD框架，可以异步加载JS文件，按照模块加载方法，通过define()函数定义，第一个参数是一个数组，里面定义一些需要依赖的包，第二个参数是一个回调函数，通过变量来引用模块里面的方法，最后通过return来输出。</p>
<p>是一个<strong>依赖前置</strong>、<strong>异步定义</strong>的AMD框架（在参数里面引入js文件），在定义的同时如果需要用到别的模块，在最前面定义好即在参数数组里面进行引入，在回调里面加载</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义模块myModule.js</span></span><br><span class="line">define([<span class="string">'package/lib'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">lib</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'helloworld'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        foo:foo</span><br><span class="line">    &#125;</span><br><span class="line">&#125;])</span><br><span class="line"><span class="comment">//加载模块</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'myModule'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">my</span>)</span>&#123;</span><br><span class="line">    my.foo();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>语法：</strong></p>
<p>requireJS定义了一个函数 define，它是全局变量，用来定义模块</p>
<p><strong>define(id?, dependencies?, factory);</strong></p>
<ul>
<li>id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）</li>
<li>dependencies：是一个当前模块依赖的模块名称数组</li>
<li>factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值<br> 在页面上使用require函数加载模块</li>
</ul>
<p>require([dependencies], function(){});<br> <strong>require()函数接受两个参数</strong></p>
<ul>
<li>第一个参数是一个数组，表示所依赖的模块</li>
<li>第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块<br> require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</li>
</ul>
<p><strong>（3）CMD（Common Module Definition）</strong></p>
<p>即通用模块定义，对应<code>SeaJS</code>，是阿里玉伯团队首先提出的概念和设计。跟requireJS解决同样问题，只是运行机制不同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义模块  myModule.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">'jquery.js'</span>)</span><br><span class="line">  $(<span class="string">'div'</span>).addClass(<span class="string">'active'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line">seajs.use([<span class="string">'myModule.js'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">my</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>语法：</strong></p>
<p>Sea.js 推崇一个模块一个文件，遵循统一的写法。</p>
<p><strong>define(id?, dependencies?, factory)</strong><br> 因为CMD推崇一个文件一个模块，所以经常就用文件名作为模块id<br> CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写<br> factory有三个参数</p>
<p><strong>function(require, exports, module)</strong></p>
<ul>
<li>require<br> require 是 factory 函数的第一个参数</li>
<li>require(id)<br> require 是一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口</li>
<li>exports<br> exports 是一个对象，用来向外提供模块接口</li>
<li>module<br> module 是一个对象，上面存储了与当前模块相关联的一些属性和方法</li>
</ul>
<p><strong>（4）ES6：Module</strong>：结合了commonjs和AMD的优点，因为其简约的api已经可以完全取代它们了。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/25/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/" rel="prev" title="微信小程序开发">
      <i class="fa fa-chevron-left"></i> 微信小程序开发
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-闭包"><span class="nav-text">1. 闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-循环和闭包"><span class="nav-text">1.1 循环和闭包</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-模块"><span class="nav-text">1.2 模块</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-对象"><span class="nav-text">2. 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对象深度克隆的简单实现"><span class="nav-text">对象深度克隆的简单实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#js监听对象属性的改变"><span class="nav-text">js监听对象属性的改变</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-理解对象"><span class="nav-text">2.1 理解对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-1-属性类型"><span class="nav-text">2.1.1 属性类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-2-定义多个属性"><span class="nav-text">2.1.2 定义多个属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-3-读取属性的特性"><span class="nav-text">2.1.3 读取属性的特性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2创建对象"><span class="nav-text">2.2创建对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-1-工厂模式："><span class="nav-text">2.2.1 工厂模式：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-2-构造函数模式"><span class="nav-text">2.2.2 构造函数模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-3-原型模式"><span class="nav-text">2.2.3 原型模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-4-组合使用构造函数模式和原型模式（最广泛、认同度最高）"><span class="nav-text">2.2.4 组合使用构造函数模式和原型模式（最广泛、认同度最高）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-5-动态原型模式（可以把所有信息都封装在构造函数中）"><span class="nav-text">2.2.5 动态原型模式（可以把所有信息都封装在构造函数中）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-6-寄生（parasitic）构造函数模式（不建议使用）"><span class="nav-text">2.2.6 寄生（parasitic）构造函数模式（不建议使用）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-7-稳妥构造函数模式"><span class="nav-text">2.2.7 稳妥构造函数模式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-继承"><span class="nav-text">2.3 继承</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-1-原型链继承"><span class="nav-text">2.3.1 原型链继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-2-借用构造函数（伪造对象或经典继承）"><span class="nav-text">2.3.2 借用构造函数（伪造对象或经典继承）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-3-组合继承（JS中最常用的继承模式，也称伪经典继承）"><span class="nav-text">2.3.3 组合继承（JS中最常用的继承模式，也称伪经典继承）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-4-原型式继承-ES5通过Object-create-方法规范化了原型式继承"><span class="nav-text">2.3.4 原型式继承:ES5通过Object.create()方法规范化了原型式继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-5-寄生式继承"><span class="nav-text">2.3.5 寄生式继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-6-寄生组合式继承（最理想）"><span class="nav-text">2.3.6 寄生组合式继承（最理想）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-混合对象“类”"><span class="nav-text">3. 混合对象“类”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-this"><span class="nav-text">4. this</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-调用位置：函数在代码中被调用的位置（而不是被声明的位置）"><span class="nav-text">4.1 调用位置：函数在代码中被调用的位置（而不是被声明的位置）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-绑定规则："><span class="nav-text">4.2 绑定规则：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-1-默认绑定：独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则；"><span class="nav-text">4.2.1 默认绑定：独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则；</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-2-隐式绑定：在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把this间接（隐式）绑定到这个对象上"><span class="nav-text">4.2.2 隐式绑定：在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把this间接（隐式）绑定到这个对象上</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-3-显式绑定：使用call-和apply"><span class="nav-text">4.2.3 显式绑定：使用call()和apply()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-4-new绑定-实际上并不存在所谓的“构造函数”，只有对于函数的构造调用"><span class="nav-text">4.2.4 new绑定:实际上并不存在所谓的“构造函数”，只有对于函数的构造调用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-优先级：new绑定-gt-显式绑定-gt-隐式绑定-gt-默认绑定"><span class="nav-text">4.3 优先级：new绑定&gt;显式绑定&gt;隐式绑定&gt;默认绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-绑定例外"><span class="nav-text">4.4 绑定例外</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-this词法"><span class="nav-text">4.5 this词法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-事件循环：EventLoop"><span class="nav-text">5. 事件循环：EventLoop</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-浏览器的进程与线程："><span class="nav-text">5.1 浏览器的进程与线程：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-EventLoop：事件循环"><span class="nav-text">5.2 EventLoop：事件循环</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-异步编程的几种方法"><span class="nav-text">6. 异步编程的几种方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-回调函数"><span class="nav-text">6.1 回调函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-事件监听"><span class="nav-text">6.2 事件监听</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-发布-订阅"><span class="nav-text">6.3 发布&#x2F;订阅</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-Promise"><span class="nav-text">6.4 Promise:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-5-Generator-生成器"><span class="nav-text">6.5 Generator:生成器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-6-async-await"><span class="nav-text">6.6 async&#x2F;await</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-前端中的事件流"><span class="nav-text">7. 前端中的事件流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-事件"><span class="nav-text">7.1 事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-冒泡"><span class="nav-text">7.2 冒泡</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-捕获"><span class="nav-text">7.3 捕获</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-如何让事件先冒泡后捕获？"><span class="nav-text">7.4 如何让事件先冒泡后捕获？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-5-事件委托"><span class="nav-text">7.5 事件委托</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-6-mouseover-和mouseenter的区别"><span class="nav-text">7.6 mouseover 和mouseenter的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-JS的节流和防抖"><span class="nav-text">8. JS的节流和防抖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-JS的垃圾回收机制"><span class="nav-text">9. JS的垃圾回收机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-1-栈、堆、队列"><span class="nav-text">9.1 栈、堆、队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-JS垃圾回收机制"><span class="nav-text">9.2 JS垃圾回收机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-3-如何防止内存泄漏？"><span class="nav-text">9.3 如何防止内存泄漏？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-AJAX解决浏览器缓存问题"><span class="nav-text">10. AJAX解决浏览器缓存问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-eval是做什么的-（欺骗词法）"><span class="nav-text">11. eval是做什么的?（欺骗词法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-如何理解前端模块化？"><span class="nav-text">12. 如何理解前端模块化？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#12-1-说一下Commonjs-AMD-CMD"><span class="nav-text">12.1 说一下Commonjs,AMD,CMD</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-实现一个once函数，传入函数参数只执行一次"><span class="nav-text">13. 实现一个once函数，传入函数参数只执行一次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-如何实现一个私有变量，用getName方法可以访问，不能直接访问"><span class="nav-text">14. 如何实现一个私有变量，用getName方法可以访问，不能直接访问</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#15-重排和重绘"><span class="nav-text">15. 重排和重绘</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-重排和重绘-1"><span class="nav-text">15. 重排和重绘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-const、let、var"><span class="nav-text">16. const、let、var</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#16-1-let-和-var-的区别："><span class="nav-text">16.1 let 和 var 的区别：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-2-为什么需要块级作用域？"><span class="nav-text">16.2 为什么需要块级作用域？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-3-const命令"><span class="nav-text">16.3 const命令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-性能问题"><span class="nav-text">17.性能问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-深拷贝和浅拷贝"><span class="nav-text">18.深拷贝和浅拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#18-1-什么是深拷贝和浅拷贝？"><span class="nav-text">18.1 什么是深拷贝和浅拷贝？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-2-常用的拷贝API："><span class="nav-text">18.2 常用的拷贝API：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-3-实现深拷贝的方法："><span class="nav-text">18.3 实现深拷贝的方法：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-前端工程化与性能"><span class="nav-text">19. 前端工程化与性能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#19-1-前段工程的三个阶段"><span class="nav-text">19.1 前段工程的三个阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-2-浅析前端工程化"><span class="nav-text">19.2 浅析前端工程化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#19-2-1-前端工程化，面临的问题是如何提高编码-gt-测试-gt-维护阶段的生产效率"><span class="nav-text">19.2.1 前端工程化，面临的问题是如何提高编码-&gt;测试-&gt;维护阶段的生产效率</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#19-2-2-要解决前端工程化的问题，可以从两个角度入手：开发和部署。"><span class="nav-text">19.2.2 要解决前端工程化的问题，可以从两个角度入手：开发和部署。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#19-2-3-构建-amp-编译"><span class="nav-text">19.2.3 构建&amp;编译</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#19-2-4-总结"><span class="nav-text">19.2.4 总结;</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-3-前端功能化-构建"><span class="nav-text">19.3 前端功能化-构建</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#19-3-1-基本功能"><span class="nav-text">19.3.1 基本功能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#19-3-2-整体流程"><span class="nav-text">19.3.2 整体流程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-4-前端模块化："><span class="nav-text">19.4 前端模块化：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#19-4-1-CommonJS-AMD-CMD-ES6的对比"><span class="nav-text">19.4.1 CommonJS, AMD, CMD, ES6的对比</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#19-4-2-模块化主要解决两个问题：“命名冲突”，“文件依赖”"><span class="nav-text">19.4.2 模块化主要解决两个问题：“命名冲突”，“文件依赖”</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="柴郡猫"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">柴郡猫</p>
  <div class="site-description" itemprop="description">向死而生的生命都在热烈地生长</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/holichang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;holichang" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1185381333@qq.com" title="E-Mail → mailto:1185381333@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">柴郡猫</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
