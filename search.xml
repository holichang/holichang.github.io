<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>面经——JavaScript</title>
    <url>/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/</url>
    <content><![CDATA[<h3 id="1-闭包"><a href="#1-闭包" class="headerlink" title="1. 闭包"></a>1. 闭包</h3><p><strong>无论通过何种手段将内部函数传递到所在的词法作用域以外，它持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包</strong></p>
<blockquote>
<p>思考：通过使用闭包，在作用域之外也可以调用函数，同时该函数还可以访问本身词法作用域中的变量</p>
</blockquote>
<p>在定时器、事件监听器、AJAX请求、跨窗口通信、Web Workers或者任何其他的异步（或同步）任务中，只要使用了<strong>回调函数</strong>，实际上就是在使用闭包</p>
<h5 id="1-1-循环和闭包"><a href="#1-1-循环和闭包" class="headerlink" title="1.1 循环和闭包"></a>1.1 循环和闭包</h5><p>IIFE：立即执行函数表达式，相当于将块转为了一个可以被关闭的作用域（var）</p>
<p>先看下面这个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;,<span class="number">1000</span>*i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//预期：分别输出数字1-5，每秒一次，每次一个</span></span><br><span class="line"><span class="comment">//该段代码会以每秒一次的频率输出五次6</span></span><br></pre></td></tr></table></figure>

<p>缺陷是我们试图假设循环中的每个迭代在运行时都会给自己捕获一个i的副本，但是根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被<strong>封闭在一个共享的全局作用域中，</strong>因此事实上只有一个i。</p>
<p>如何修改？</p>
<p><strong>方法一：使用IIFE</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(j)</span><br><span class="line">        &#125;,<span class="number">1000</span>*j)</span><br><span class="line">    &#125;(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：使用setTimeout第三个参数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;,i*<span class="number">1000</span>,i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//setTimeout的第三个参数为传给执行函数的其他参数（IE9 及其更早版本不支持该参数）。</span></span><br></pre></td></tr></table></figure>

<p><strong>方法三：使用let：块级作用域</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> j=i;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;,j*<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line">或：</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;=<span class="number">5</span>;i++)</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;,i*<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每次迭代都会创建一个i的副本</span></span><br></pre></td></tr></table></figure>

<h5 id="1-2-模块"><a href="#1-2-模块" class="headerlink" title="1.2 模块"></a>1.2 模块</h5><p>模块模式需要具备两个必要条件：</p>
<p>（1）必须有外部的封闭函数，该函数必须至少被调用一次，（<strong>每次调用都会创建一个新的模块实例？</strong>）</p>
<p>（2）封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态</p>
<p><strong>现代的模块机制：</strong></p>
<p>大多数模块依赖加载器/管理器本质上都是将这种模块定义封装进一个友好的API。这里并不会研究某个具体的库，为了宏观了解会简单介绍一些核心概念：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MyModules=(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">module</span>=&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">define</span>(<span class="params">name,deps,impl</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;deps.length;i++)&#123;</span><br><span class="line">            deps[i]=<span class="built_in">module</span>[deps[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        modules[name]=impl.apply(impl,deps)</span><br><span class="line">        <span class="comment">//引入需要的依赖</span></span><br><span class="line">    &#125;<span class="comment">//该函数用于向管理中添加模块</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">module</span>[name];</span><br><span class="line">    &#125;<span class="comment">//通过名称获取模块</span></span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        define:define,</span><br><span class="line">        <span class="keyword">get</span>:<span class="keyword">get</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">//下面为使用方法：[]为新定义的模块需要引入的依赖模块列表</span><br><span class="line">MyModules.define("bar",[],function()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">who</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'let me introduce:'</span>+who;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        hello:hello</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">MyModules.define(<span class="string">"foo"</span>,[<span class="string">"bar"</span>],<span class="function"><span class="keyword">function</span>(<span class="params">bar</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hungry=<span class="string">"hippo"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">awesome</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(bar.hello(hungry).toUpperCase());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>&#123;</span><br><span class="line">        awesome:awesome</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> bar=MyModules.get(<span class="string">"bar"</span>);</span><br><span class="line"><span class="keyword">var</span> foo=MyModules.get(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	bar.hello(<span class="string">"hippo"</span>)</span><br><span class="line">);<span class="comment">//let me introduce: hippo</span></span><br><span class="line">foo.awesome();<span class="comment">//LET ME INTRODUCE:HIPPO</span></span><br></pre></td></tr></table></figure>

<p><strong>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包</strong></p>
<h3 id="2-对象"><a href="#2-对象" class="headerlink" title="2. 对象"></a>2. 对象</h3><h4 id="对象深度克隆的简单实现"><a href="#对象深度克隆的简单实现" class="headerlink" title="对象深度克隆的简单实现"></a>对象深度克隆的简单实现</h4><h4 id="js监听对象属性的改变"><a href="#js监听对象属性的改变" class="headerlink" title="js监听对象属性的改变"></a>js监听对象属性的改变</h4><h4 id="2-1-理解对象"><a href="#2-1-理解对象" class="headerlink" title="2.1 理解对象"></a>2.1 理解对象</h4><h5 id="2-1-1-属性类型"><a href="#2-1-1-属性类型" class="headerlink" title="2.1.1 属性类型"></a>2.1.1 属性类型</h5><p>ES5中有两种属性：数据属性和访问器属性</p>
<p><strong>数据属性</strong>：数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性：</p>
<p>[[Configurable]]:表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。</p>
<p>[[Enumerable]]：表示能否通过for-in循环返回属性。</p>
<p>[[Writable]]：表示能否修改属性的值。</p>
<p>[[Value]]：包含这个属性的值。</p>
<p><strong>要修改属性默认的特性：</strong>ES5的<strong>Object.defineProperty()</strong>方法（三个参数：属性所在的对象、属性的名字、描述符对象）使用如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">"name"</span>,&#123;</span><br><span class="line">    writable:<span class="literal">false</span>;</span><br><span class="line">    value:<span class="string">"Nicholas"</span>;</span><br><span class="line">&#125;)</span><br><span class="line">alert(person.name);<span class="comment">//"Nicholas"</span></span><br><span class="line">person.name=<span class="string">"Greg"</span>;</span><br><span class="line">alert(person.name);<span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>

<p>可以多次调用Object.defineProperty()方法修改同一个属性，但在把configurable特性设置为false之后就会有限制了。同时，<strong>在调用Object.defineProperty()方法创建一个新属性时，如果不指定，configurable，enumerable和writable特性的默认值都是false</strong>,如果调用Object.defineProperty()方法是修改已定义属性的特性，则无此限制。</p>
<p><strong>访问器属性</strong>（常用方法：设置一个属性的值会导致其他属性发生变化）</p>
<p>访问器属性不包含数据值，它包含一对getter函数和setter函数（不过这两个函数都不是必需的）。在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值，在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性：</p>
<p>[[Configurable]]:表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。</p>
<p>[[Enumerable]]：表示能否通过for-in循环返回属性。</p>
<p>[[Get]]：在读取属性时调用的函数。默认值为undefined。</p>
<p>[[Set]]：在写入属性时调用的函数。默认值为undefined。</p>
<p><strong>访问器属性不能直接定义，必须使用</strong>Object.defineProperty()来定义。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> book=&#123;</span><br><span class="line">    _year:<span class="number">2004</span>,</span><br><span class="line">    edition:<span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book,<span class="string">"year"</span>,&#123;</span><br><span class="line">    <span class="keyword">get</span>:function()&#123;</span><br><span class="line">        <span class="keyword">return</span> book._year;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>:function(newValue)&#123;</span><br><span class="line">        <span class="keyword">if</span>(newValue&gt;<span class="number">2004</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>._year=newValue;</span><br><span class="line">            <span class="keyword">this</span>.edition=newValue<span class="number">-2004</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">book.year=<span class="number">2005</span>;</span><br><span class="line">alert(book.edition);<span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h5 id="2-1-2-定义多个属性"><a href="#2-1-2-定义多个属性" class="headerlink" title="2.1.2 定义多个属性"></a>2.1.2 定义多个属性</h5><p>Object.defineProperties()方法:可以一次性定义多个属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperties(book,&#123;</span><br><span class="line">    _year:&#123;</span><br><span class="line">        writable:<span class="literal">true</span>,</span><br><span class="line">        value:<span class="number">2004</span></span><br><span class="line">    &#125;,</span><br><span class="line">    edition:&#123;</span><br><span class="line">        writable:<span class="literal">true</span>;</span><br><span class="line">        value:<span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    year:&#123;</span><br><span class="line">        <span class="keyword">get</span>:function()&#123;</span><br><span class="line">            <span class="keyword">return</span> book._year;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>:function(newValue)&#123;</span><br><span class="line">            <span class="keyword">if</span>(newValue&gt;<span class="number">2004</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>._year=newValue;</span><br><span class="line">                <span class="keyword">this</span>.edition=newValue<span class="number">-2004</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="2-1-3-读取属性的特性"><a href="#2-1-3-读取属性的特性" class="headerlink" title="2.1.3 读取属性的特性"></a>2.1.3 读取属性的特性</h5><p><strong>Object.getOwnPropertyDescriptor()</strong>方法：取得给定属性的描述符。接收两个参数：属性所在的对象和要读取其描述符的属性名称，如：(接上段代码)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> descriptor=<span class="built_in">Object</span>.getOwnPropertyDescriptor(book,<span class="string">"_year"</span>);</span><br><span class="line">alert(descriptor.value);<span class="comment">//2004</span></span><br><span class="line">alert(descriptor.configurable);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p><strong>ES5的Object.getOwnPropertyDescriptor（）方法只能用于实例属性，要取得原型属性的描述符，必须直接在原型对象上调用该方法。</strong></p>
<p>在JavaScript 中，可以针对任何对象——包括 DOM 和BOM 对象，使用Object.getOwnProperty-Descriptor()方法。支持这个方法的浏览器有IE9+、Firefox 4+、Safari 5+、Opera 12+和Chrome。</p>
<h4 id="2-2创建对象"><a href="#2-2创建对象" class="headerlink" title="2.2创建对象"></a>2.2创建对象</h4><h5 id="2-2-1-工厂模式："><a href="#2-2-1-工厂模式：" class="headerlink" title="2.2.1 工厂模式："></a>2.2.1 工厂模式：</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> person=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">   person.name=name;</span><br><span class="line">   person.age=age;</span><br><span class="line">   person.job=job;</span><br><span class="line">   person.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'my name is'</span>+<span class="keyword">this</span>.name)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1=createPerson(<span class="string">"Nicholas"</span>,<span class="number">29</span>,<span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2=createPerson(<span class="string">"Greg"</span>,<span class="number">27</span>,<span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure>

<p>用函数来封装以特定接口创建对象的细节（虽然解决了创建多个相似对象的问题，但没有解决对象识别的问题,即怎么知道一个对象的类型）</p>
<h5 id="2-2-2-构造函数模式"><a href="#2-2-2-构造函数模式" class="headerlink" title="2.2.2 构造函数模式"></a>2.2.2 构造函数模式</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.job=job;</span><br><span class="line">    <span class="keyword">this</span>.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>,<span class="number">29</span>,<span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2=<span class="keyword">new</span> Person(<span class="string">"Greg"</span>,<span class="number">23</span>,<span class="string">"Doctor"</span>);</span><br><span class="line">alert(person1.constructor==Person);<span class="comment">//true</span></span><br><span class="line">alert(person1 <span class="keyword">instanceof</span> Person);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>构造函数模式和工厂模式的区别：</strong></p>
<p>（1）没有显式地创建一个新对象</p>
<p>（2）直接将属性和方法赋给了新对象</p>
<p>（3）没有return语句</p>
<p><strong>使用new操作符调用构造函数实际会经历以下步骤：</strong></p>
<p>（1）创建一个新对象</p>
<p>（2）这个新对象会被执行[[Prototype]]连接；</p>
<p>（3）将构造函数的作用域赋给新对象（因此this就指向了这个对象）</p>
<p>（4）执行构造函数中的代码（为这个新对象添加属性）</p>
<p>（5）返回新对象</p>
<p><strong>创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式胜过工厂模式的地方。</strong>在这个例子中，person1 和person2 之所以同时是Object 的实例，是因为所有对象均继承自Object</p>
<p><strong>构造函数模式存在的问题</strong>：每个方法都要在每个实例重新创建一遍</p>
<h5 id="2-2-3-原型模式"><a href="#2-2-3-原型模式" class="headerlink" title="2.2.3 原型模式"></a>2.2.3 原型模式</h5><blockquote>
<p>在所有实现中都无法访问[[prototype]]或<em>proto</em></p>
</blockquote>
<p><strong>构造函数，原型和实例的关系：</strong></p>
<p>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。</p>
<p><strong>（1）理解原型对象</strong>：prototype是通过调用构造函数而创建的那个对象实例的原型对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name=<span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age=<span class="number">29</span>;</span><br><span class="line">Person.prototype.job=<span class="string">"Software Engineer"</span>;</span><br><span class="line">Person.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName();<span class="comment">//"Nicholas"</span></span><br><span class="line"><span class="comment">//person1._proto_为Person.prototype</span></span><br></pre></td></tr></table></figure>

<p>在默认情况下，所有原型对象都会自动获得一个constructor(构造函数)属性，这个属性是一个指向prototype属性所在函数的指针。Person.prototype.constructor指向Person</p>
<p><img src="/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/D:%5CFront-End-Note%5Cimage%5C%E5%8E%9F%E5%9E%8B.png" alt="原型"></p>
<p>明确一点：<strong>这个连接存在于实例与构造函数的原型对象之间</strong>，而不是存在于实例与构造函数之间（即person1与Person.prototype之间的联系）person1内部有一个指向Person.prototype的指针（<code>[[prototype]]</code>或<code>_proto_</code>：虽然在所有实现中都无法访问到，但可以通过<code>isprototypeOf()</code>来确定是否是某实例的原型对象）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(Person.prototype.isPrototypeOf(person1));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>Object.getPrototypeOf():</strong>可以方便地获取一个对象的原型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(<span class="built_in">Object</span>.getPrototypeOf(person1)==Person.prototype);<span class="comment">//true</span></span><br><span class="line">alert(<span class="built_in">Object</span>.getPrototypeOf(person1).name);<span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>

<p>当代码要取得某个对象的某个属性时，会先从对象实例本身开始搜索，如果没有找到属性名，则继续搜索指针指向的原型对象。</p>
<p>当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性，也就是说，添加这个属性值会阻止我们访问原型中的那个属性，但不会修改那个属性;不过<strong>使用delete操作符可以完全删除实例属性</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person1.name=<span class="string">"Greg"</span>;</span><br><span class="line">alert(person1.name);<span class="comment">//Greg</span></span><br><span class="line">alert(person1.hasOwnProperty(<span class="string">"name"</span>));<span class="comment">//true</span></span><br><span class="line"><span class="keyword">delete</span> person1.name;</span><br><span class="line">alert(person1.hasOwnProperty(<span class="string">"name"</span>));<span class="comment">//false</span></span><br><span class="line">alert(person1.name);<span class="comment">//Nicholas</span></span><br></pre></td></tr></table></figure>

<p><strong>hasOwnProperty()</strong>方法：检测一个属性是存在于实例中还是原型中</p>
<p><em>Object.getOwnPropertyDescriptor()方法只能用于实例属性，要取得原型属性的描述符，必须直接在原型对象上调用Object.getOwnPropertyDescriptor()方法</em></p>
<p><strong>（2）原型与in操作符</strong></p>
<p><strong>单独使用</strong>：in操作符只要通过对象能访问到属性就返回true,hasOwnProperty()只在属性存在于实例中时才返回true,因此当in操作符返回true，而hasOwnProperty()返回false时,就说明该属性存在于原型中</p>
<p><strong>for-in循环</strong>时：返回的是所有能够通过对象访问的，可枚举的属性，其中既包括存在于实例中的属性，也包括在原型中的属性。（<strong>屏蔽了原型中不可枚举属性（即将[[Enumerable]]标记为false属性）的实例属性也会在for-in循环中返回，因为根据规定，所有开发人员定义的属性都是可枚举的——只有在IE8及更早版本中例外</strong>）</p>
<p><strong>Object.keys()</strong>方法：接收一个对象作为参数，返回一个包含所有<strong>可枚举</strong>属性的<strong>字符串</strong>数组</p>
<p><strong>Object.getOwnPropertyNames():</strong>接收一个对象作为参数，返回一个包含<strong>所有实例属性</strong>的<strong>字符串</strong>数组</p>
<p><strong>（3）更简单的原型语法</strong>：用字面量法重写原型对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype=&#123;</span><br><span class="line">    <span class="keyword">constructor</span>:Person,</span><br><span class="line">    name:"Nicholas",</span><br><span class="line">    age:29,</span><br><span class="line">    job:"Software Engineer",</span><br><span class="line">    sayName:function()&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype,<span class="string">"constructor"</span>,&#123;</span><br><span class="line">    enumerable:<span class="literal">false</span>,</span><br><span class="line">    value:Person</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName();<span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>

<p>但此时，constructor属性不再指向Person函数，而是<strong>指向Object</strong>,但由于此时constructor属性为自定义的，<strong>可枚举</strong>，因此可以通过Object.defineProperty()将其[[Enumerable]]属性特性改为false。</p>
<p><strong>（4）原型的动态性</strong></p>
<p>重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系，他们引用的仍然是最初的原型。</p>
<p><strong>所以只能修改</strong></p>
<p><strong>（5）原生对象的原型</strong></p>
<p>可以修改如Array,Object,String等原生引用类型的原型，如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.startsWith=<span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.indexof(text)==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（6）原型对象的问题</strong></p>
<p><strong>原型对象中的引用类型值会被共享</strong></p>
<h5 id="2-2-4-组合使用构造函数模式和原型模式（最广泛、认同度最高）"><a href="#2-2-4-组合使用构造函数模式和原型模式（最广泛、认同度最高）" class="headerlink" title="2.2.4 组合使用构造函数模式和原型模式（最广泛、认同度最高）"></a>2.2.4 组合使用构造函数模式和原型模式（最广泛、认同度最高）</h5><p>构造函数用于定义实例属性，而原型模式用于定义方法和共享的属性。</p>
<h5 id="2-2-5-动态原型模式（可以把所有信息都封装在构造函数中）"><a href="#2-2-5-动态原型模式（可以把所有信息都封装在构造函数中）" class="headerlink" title="2.2.5 动态原型模式（可以把所有信息都封装在构造函数中）"></a>2.2.5 动态原型模式（可以把所有信息都封装在构造函数中）</h5><p>通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.job=job;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName!=<span class="string">"function"</span>)</span><br><span class="line">        <span class="comment">//此时sayName若是不存在或者不是函数类型，都会对原型初始化，而且检查一个属性或方法就可以</span></span><br><span class="line">    &#123;</span><br><span class="line">        Person.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-6-寄生（parasitic）构造函数模式（不建议使用）"><a href="#2-2-6-寄生（parasitic）构造函数模式（不建议使用）" class="headerlink" title="2.2.6 寄生（parasitic）构造函数模式（不建议使用）"></a>2.2.6 寄生（parasitic）构造函数模式（不建议使用）</h5><p>假如我们想创建一个具有额外方法的特殊数组，由于不能直接修改Array函数，因此可以使用这个模式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">values.push.apply(values,<span class="built_in">arguments</span>);<span class="comment">//arguments是个类数组对象，不能直接push到数组中</span></span><br></pre></td></tr></table></figure>

<p>构造函数在没有返回值的情况下，默认返回新对象实例，而该模式下的构造函数形式类似于工厂模式，在末尾有return语句，可以重写调用构造函数时返回的值，因此，<strong>返回的对象与构造函数以及构造函数的原型属性之间没有关系</strong>，也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。使用instanceof 没有意义。</p>
<h5 id="2-2-7-稳妥构造函数模式"><a href="#2-2-7-稳妥构造函数模式" class="headerlink" title="2.2.7 稳妥构造函数模式"></a>2.2.7 稳妥构造函数模式</h5><p>指的是没有公共属性，最适合在一些安全环境中使用，也与工厂模式很像</p>
<p>与寄生构造函数模式的区别：（1）不引用this对象（寄生模式在声明方法时使用）；（2）不使用new操作符</p>
<p>这种模式下创建的对象除了使用方法，没有其他办法访问属性值。</p>
<h4 id="2-3-继承"><a href="#2-3-继承" class="headerlink" title="2.3 继承"></a>2.3 继承</h4><p>ES只支持实现继承，而且主要依靠原型链</p>
<p>方法签名：</p>
<h5 id="2-3-1-原型链继承"><a href="#2-3-1-原型链继承" class="headerlink" title="2.3.1 原型链继承"></a>2.3.1 原型链继承</h5><p>基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法</p>
<p>实现本质是重写原型对象，代之以另一个新类型的实例</p>
<p><strong>（1）别忘记默认的原型</strong></p>
<p>所有函数的默认原型都是Object的实例</p>
<p><img src="/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="原型链"></p>
<p><strong>（2）确定原型和实例的关系</strong></p>
<p>instanceof操作符：+构造函数：只要用这个操作符测试实例与原型链中出现过的构造函数，就会返回true</p>
<p>isPrototypeOf()方法:只要是原型链中出现过的原型对象，都可以说是该原型链所派生的实例的原型</p>
<p><strong>（3）谨慎的定义方法</strong></p>
<p>给原型添加方法的代码一定要放在替换原型的语句之后，且不能使用字面量方法创建原型方法</p>
<p><strong>（4）原型链的问题</strong></p>
<p>第一个问题：包含引用类型值的原型属性会被所有实例共享</p>
<p>第二个问题：在创建子类型的实例时，不能向超类型的构造函数中传递参数</p>
<h5 id="2-3-2-借用构造函数（伪造对象或经典继承）"><a href="#2-3-2-借用构造函数（伪造对象或经典继承）" class="headerlink" title="2.3.2 借用构造函数（伪造对象或经典继承）"></a>2.3.2 借用构造函数（伪造对象或经典继承）</h5><p>基本思想：在子类型构造函数的内部调用超类型构造函数（使用call()方法或apply()方法）<strong>屏蔽掉超类型中的引用类型值</strong></p>
<p>好处：可以传递参数</p>
<p>问题：无法避免构造函数模式存在的问题——方法都在构造函数中定义，无法复用</p>
<h5 id="2-3-3-组合继承（JS中最常用的继承模式，也称伪经典继承）"><a href="#2-3-3-组合继承（JS中最常用的继承模式，也称伪经典继承）" class="headerlink" title="2.3.3 组合继承（JS中最常用的继承模式，也称伪经典继承）"></a>2.3.3 组合继承（JS中最常用的继承模式，也称伪经典继承）</h5><p>指的是将原型链和借用构造函数的技术组合到一起，使用原型链实现对原型属性和方法的继承，而使用借用构造函数来实现对实例属性的继承。</p>
<p>而且instanceof()和isPrototypeOf()也能够用于识别基于组合继承创建的对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.colors=[<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//继承属性</span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>,name);<span class="comment">//第二次调用构造函数，SubType实例中传入了第二组name和colors</span></span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承方法</span></span><br><span class="line">SubType.prototype=<span class="keyword">new</span> SuperType();<span class="comment">//第一次调用构造函数，SubType原型中传入了name和colors</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用寄生式组合继承方法：</span></span><br><span class="line"><span class="comment">function inheriPrototype(subType,superType)&#123;</span></span><br><span class="line"><span class="comment">    var prototype=object(superType.prototype);//创建对象：构建超类型原型的一个副本</span></span><br><span class="line"><span class="comment">    prototype.constructer=subType;//增强对象</span></span><br><span class="line"><span class="comment">    subType.prototype=prototype;//指定对象：将新创建的对象（即副本）赋值给子类型的原型</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">inheriPrototype(SubType,SuperType);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">SubType.prototype.constructor=SubType;</span><br><span class="line">SubType.prototype.sayAge=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 =<span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>,<span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"yellow"</span>);</span><br><span class="line">alert(instance1.colors);<span class="comment">//"red","green","blue","yellow"</span></span><br><span class="line">instance1.sayName();<span class="comment">//"Nicholas"</span></span><br><span class="line">instance1.sayAge();<span class="comment">//29</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 =<span class="keyword">new</span> SubType(<span class="string">"Greg"</span>,<span class="number">27</span>);</span><br><span class="line">alert(instance2.colors);<span class="comment">//"red","green","blue"</span></span><br><span class="line">instance2.sayName();<span class="comment">//"Greg"</span></span><br><span class="line">instance2.sayAge();<span class="comment">//27</span></span><br></pre></td></tr></table></figure>

<p><u>问题：会调用两次超类型构造函数</u></p>
<h5 id="2-3-4-原型式继承-ES5通过Object-create-方法规范化了原型式继承"><a href="#2-3-4-原型式继承-ES5通过Object-create-方法规范化了原型式继承" class="headerlink" title="2.3.4 原型式继承:ES5通过Object.create()方法规范化了原型式继承"></a>2.3.4 原型式继承:ES5通过Object.create()方法规范化了原型式继承</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype=o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;<span class="comment">//相当于利用一个构造函数做桥接，</span></span><br></pre></td></tr></table></figure>

<p>思想是基于对象o，创建一个实例，该实例的原型对象o,在包含引用类型属性值方面该方法与原型模式是一样的</p>
<p>ES5新增了Object.create()方法：接受两个参数：一个是用作新对象原型的对象和（可选的）一个新对象定义额外的对象，该对象中每个属性都是通过自己的描述符定义的.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">     name:<span class="string">'Nicholas'</span>,</span><br><span class="line">     friends:[<span class="string">'Shelby'</span>,<span class="string">'Court'</span>,;Van]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1=<span class="built_in">Object</span>.create(person,&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        value:<span class="string">'Greg'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(person1.name);<span class="comment">//'Greg'</span></span><br></pre></td></tr></table></figure>

<p>支持Object.create()方法的浏览器有IE9+、Firefox 4+、Safari 5+、Opera 12+ 和Chrome。<strong>在没有必要兴师动众地创建构造函数</strong>，而只想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的。不过别忘了，包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。</p>
<h5 id="2-3-5-寄生式继承"><a href="#2-3-5-寄生式继承" class="headerlink" title="2.3.5 寄生式继承"></a>2.3.5 寄生式继承</h5><p>思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象（即在内部通过构造函数创建一个实例，再为该对象增加方法，最后返回该对象）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone=<span class="built_in">Object</span>.create(o);</span><br><span class="line">    clone.sayHi=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"Hi!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">    name:<span class="string">'Nichlas'</span>,</span><br><span class="line">    friends:[<span class="string">'Tom'</span>,<span class="string">'Bob'</span>,<span class="string">'Greg'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> another=createAnother(person);</span><br><span class="line">another.sayHi();<span class="comment">//'Hi!'</span></span><br></pre></td></tr></table></figure>

<p>在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示范继承模式时使用的Object.create()函数不是必需的；任何能够返回新对象的函数都适用于此模式。</p>
<h5 id="2-3-6-寄生组合式继承（最理想）"><a href="#2-3-6-寄生组合式继承（最理想）" class="headerlink" title="2.3.6 寄生组合式继承（最理想）"></a>2.3.6 寄生组合式继承（最理想）</h5><p>用于解决组合继承两次调用构造函数的问题，方法见上方代码，该方法只调用一次SuperType构造函数,且原型链保持不变。</p>
<p><strong>基本思路：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的不过是超类型原型的一个副本而已，方法同原型式继承</strong></p>
<h3 id="3-混合对象“类”"><a href="#3-混合对象“类”" class="headerlink" title="3. 混合对象“类”"></a>3. 混合对象“类”</h3><h3 id="4-this"><a href="#4-this" class="headerlink" title="4. this"></a>4. this</h3><h4 id="4-1-调用位置：函数在代码中被调用的位置（而不是被声明的位置）"><a href="#4-1-调用位置：函数在代码中被调用的位置（而不是被声明的位置）" class="headerlink" title="4.1 调用位置：函数在代码中被调用的位置（而不是被声明的位置）"></a>4.1 调用位置：函数在代码中被调用的位置（而不是被声明的位置）</h4><p>调用栈：为了到达当前执行位置所调用的所有函数</p>
<h4 id="4-2-绑定规则："><a href="#4-2-绑定规则：" class="headerlink" title="4.2 绑定规则："></a>4.2 绑定规则：</h4><h5 id="4-2-1-默认绑定：独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则；"><a href="#4-2-1-默认绑定：独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则；" class="headerlink" title="4.2.1 默认绑定：独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则；"></a>4.2.1 默认绑定：独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则；</h5><p>回调函数相当于隐式的传参</p>
<p>非严格模式下，将全局对象用于默认绑定，而严格模式下，this会绑定到undefined</p>
<p><em>对于默认绑定来说，决定this绑定对象的并不是调用位置是否是严格模式，而是函数体是否处于严格模式</em></p>
<h5 id="4-2-2-隐式绑定：在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把this间接（隐式）绑定到这个对象上"><a href="#4-2-2-隐式绑定：在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把this间接（隐式）绑定到这个对象上" class="headerlink" title="4.2.2 隐式绑定：在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把this间接（隐式）绑定到这个对象上"></a>4.2.2 隐式绑定：在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把this间接（隐式）绑定到这个对象上</h5><p>考虑调用位置是否有上下文对象（对象属性引用链中只有上一层或者说是最后一层在调用位置中起作用），参数传递其实就是一种隐式赋值；可能会发生隐式丢失</p>
<h5 id="4-2-3-显式绑定：使用call-和apply"><a href="#4-2-3-显式绑定：使用call-和apply" class="headerlink" title="4.2.3 显式绑定：使用call()和apply()"></a>4.2.3 显式绑定：使用call()和apply()</h5><p><strong>硬绑定：</strong>典型应用场景就是创建一个包裹函数，负责接收参数并返回值</p>
<p>ES5提供了内置方法：Function.prototype.bind:会返回一个硬编码的新函数，它会把你指定的参数设置为this的上下文并调用原始函数。</p>
<blockquote>
<p>怎么原生JS实现bind?</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">if</span>(!<span class="built_in">Function</span>.prototype.myBind)&#123;</span><br><span class="line">&gt;<span class="built_in">Function</span>.prototype.myBind=<span class="function"><span class="keyword">function</span>(<span class="params">oThis</span>)</span>&#123;</span><br><span class="line">&gt;<span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>!==<span class="string">'function'</span>)&#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Function.prototype.myBind-what is trying '</span>+<span class="string">'to be found is not callable'</span>);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">var</span> aArgs=<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>);</span><br><span class="line">&gt;<span class="keyword">var</span> fToBind=<span class="keyword">this</span>;<span class="comment">//要绑定的函数</span></span><br><span class="line">&gt;<span class="keyword">var</span> fNOP=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&gt;<span class="comment">//</span></span><br><span class="line">&gt;<span class="keyword">var</span> fBound=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> fToBind.apply((<span class="keyword">this</span> <span class="keyword">instanceof</span> fNOP &amp;&amp; oThis? <span class="keyword">this</span>:oThis),aArgs.concat.apply(aArgs,<span class="built_in">arguments</span>));</span><br><span class="line"> <span class="comment">//不是被new调用的时候this绑定到全局对象或者undefined,被new调用的时候this绑定到fBound</span></span><br><span class="line">&gt;&#125;;   </span><br><span class="line">&gt;fNOP.prototype=<span class="keyword">this</span>.prototype;</span><br><span class="line">&gt;fBound.prototype=<span class="keyword">new</span> fNOP();</span><br><span class="line">&gt;<span class="comment">//</span></span><br><span class="line">&gt;<span class="comment">//这段代码会判断硬绑定是否是被new调用，如果是的话就会用新创建的this替换硬绑定的this</span></span><br><span class="line">&gt;<span class="keyword">return</span> fBound;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如何判断一个函数是否是被new调用？new 的实现原理：</p>
</blockquote>
</blockquote>
<p><strong>API调用的“上下文”：</strong>如arr.forEach(function,可选参数，指定this)</p>
<h5 id="4-2-4-new绑定-实际上并不存在所谓的“构造函数”，只有对于函数的构造调用"><a href="#4-2-4-new绑定-实际上并不存在所谓的“构造函数”，只有对于函数的构造调用" class="headerlink" title="4.2.4 new绑定:实际上并不存在所谓的“构造函数”，只有对于函数的构造调用"></a>4.2.4 new绑定:实际上并不存在所谓的“构造函数”，只有对于函数的构造调用</h5><p>使用new来调用函数，会自动执行下面的操作：</p>
<p>a.创建（或者说是构造）一个全新的对象；</p>
<p>b.这个新对象会被执行[[Prototype]]连接；</p>
<p>c.这个新对象会绑定到函数调用的this；</p>
<p>d.如果函数没有其他返回对象，那么new表达式中的函数调用会自动返回这个新对象</p>
<h4 id="4-3-优先级：new绑定-gt-显式绑定-gt-隐式绑定-gt-默认绑定"><a href="#4-3-优先级：new绑定-gt-显式绑定-gt-隐式绑定-gt-默认绑定" class="headerlink" title="4.3 优先级：new绑定&gt;显式绑定&gt;隐式绑定&gt;默认绑定"></a>4.3 优先级：new绑定&gt;显式绑定&gt;隐式绑定&gt;默认绑定</h4><blockquote>
<p><strong>判断this：</strong></p>
<p>1.函数是否在new中调用（new绑定）？如果是的话this绑定的是新创建的对象</p>
<p>2.函数是否通过apply,call(显式绑定)？如果是的话，this绑定的是指定的对象</p>
<p>3.函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this绑定的就是这个上下文对象</p>
<p>4.如果上述都不是的话就是默认绑定，严格模式下this 绑定到undefined，非严格模式下绑定到全局对象</p>
</blockquote>
<h4 id="4-4-绑定例外"><a href="#4-4-绑定例外" class="headerlink" title="4.4 绑定例外"></a>4.4 绑定例外</h4><p>（1）被忽略的this</p>
<p>如<code>foo.apply(null,arguments)</code>或<code>foo.bind(null,可预设参数)</code>，当函数并不关心this时，可以用null占位，默认规则下会把this绑定到全局对象，这种方式可能会导致许多问题（比如修改了全局对象），可以通过<code>Object.Create(null)</code>创建一个空对象，该对象与{}很像，<strong>但并不会创建Object.prototype这个委托，所以它比{}更空</strong>.</p>
<p>（2）间接引用</p>
<p>容易在赋值的时候发生，传递的是原函数的引用</p>
<p>（3）软绑定:在绑定之后还保留隐式绑定和显式绑定对this值得修改（重点：考虑this不绑定全局对象和undefined时，可修改为其他对象）</p>
<blockquote>
<p>原生JS实现软绑定：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.softBind)&#123;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.softBind=<span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> fn=<span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">//捕获所有curried参数</span></span><br><span class="line">        <span class="keyword">var</span> curried=[].slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">var</span> bound=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply(</span><br><span class="line">                (!<span class="keyword">this</span>||<span class="keyword">this</span>===global)?obj:<span class="keyword">this</span>,curried.concat.apply(curried,<span class="built_in">arguments</span>))</span><br><span class="line">        &#125;;</span><br><span class="line">        bound.prototype=<span class="built_in">Object</span>.create(fn.prototype);<span class="comment">//使fn成为bound的原型</span></span><br><span class="line">        <span class="keyword">return</span> bound;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"name:"</span>+<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;<span class="attr">name</span>:<span class="string">"obj"</span>&#125;,obj1=&#123;<span class="attr">name</span>:<span class="string">"obj1"</span>&#125;,obj2=&#123;<span class="attr">name</span>:<span class="string">"obj2"</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> fooOBJ=foo.softBind(obj);</span><br><span class="line">fooOBJ();<span class="comment">//"obj"</span></span><br><span class="line"><span class="comment">//此处调用采用默认绑定，this绑定到undefined 或全局对象</span></span><br><span class="line"><span class="comment">//在强绑定中这之后this绑定不会再更换，而在软绑定中可通过隐式绑定或显示绑定修改内部this绑定</span></span><br><span class="line">obj2.foo=fooOBJ;</span><br><span class="line">obj2.foo();<span class="comment">//"obj2"</span></span><br><span class="line">fooOBJ.apply(obj1,<span class="built_in">arguments</span>);<span class="comment">//"obj3"</span></span><br></pre></td></tr></table></figure>

<h4 id="4-5-this词法"><a href="#4-5-this词法" class="headerlink" title="4.5 this词法"></a>4.5 this词法</h4><p>ES6中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定this,具体来说，箭头函数会继承外层函数调用的this绑定（无论this绑定到什么），这其实和ES6之前的self=this机制一样</p>
<h3 id="5-事件循环：EventLoop"><a href="#5-事件循环：EventLoop" class="headerlink" title="5. 事件循环：EventLoop"></a>5. 事件循环：EventLoop</h3><h4 id="5-1-浏览器的进程与线程："><a href="#5-1-浏览器的进程与线程：" class="headerlink" title="5.1 浏览器的进程与线程："></a>5.1 浏览器的进程与线程：</h4><p><strong>5.1.1 进程：</strong></p>
<p>进程是cpu的资源分配的最小单位。</p>
<p><strong>多进程</strong>：多进程指的是在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如你可以听歌的同时，打开编辑器敲代码，编辑器和听歌软件的进程之间丝毫不会相互干扰。</p>
<p><strong>浏览器是多进程的，浏览器的进程主要包括以下几种：</strong></p>
<ol>
<li>Browser进程：浏览器的主进程（负责协调，主控）</li>
<li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</li>
<li>GPU进程：最多一个，用于3D绘制</li>
<li><strong>浏览器渲染进程（内核）</strong>：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）</li>
</ol>
<p>在浏览网页时，同时打开几个新的页面， 这就要打开几个浏览窗口，但一旦开启十几个窗口，整个计算机就会越来越慢。</p>
<p><strong>多进程浏览器的优点</strong></p>
<ul>
<li><p>避免页面渲染影响整个浏览器</p>
</li>
<li><p>避免第三方插件影响整个浏览器</p>
</li>
<li><p>多进程充分利用多核优势</p>
</li>
<li><p>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性</p>
<blockquote>
<p><strong>沙盒模型：</strong></p>
</blockquote>
</li>
</ul>
<p>通俗的讲，就是用户打开多个窗口，如果其中一个窗口崩掉了，也不会影响整个浏览器，其他的界面照样正常运行</p>
<p><strong>5.1.2 线程：</strong></p>
<p>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；</p>
<p>进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)。</p>
<p><strong>浏览器的渲染进程（浏览器内核）是多线程的，主要为以下几大类：</strong></p>
<ol>
<li><p><strong>GUI线程</strong></p>
<p>负责渲染浏览器界面HTML元素,当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时,该线程就会执行。在Javascript引擎运行脚本期间,GUI渲染线程都是处于挂起状态的,也就是说被”冻结”了.</p>
</li>
<li><p><strong>Javascript引擎线程</strong></p>
<p>也可以称为JS内核，主要负责处理Javascript脚本程序，例如V8引擎。Javascript引擎线程理所当然是负责解析Javascript脚本，运行代码。</p>
<p><strong>Javascript是单线程的</strong></p>
<p>这是因为Javascript这门脚本语言诞生的使命所致：JavaScript为处理页面中用户的交互，以及操作DOM树、CSS样式树来给用户呈现一份动态而丰富的交互体验和服务器逻辑的交互处理。如果JavaScript是多线程的方式来操作这些UI DOM，则可能出现UI操作的冲突； 如果Javascript是多线程的话，在多线程的交互下，处于UI中的DOM节点就可能成为一个临界资源，假设存在两个线程同时操作一个DOM，一个负责修改一个负责删除，那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果。当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性，Javascript在最初就选择了单线程执行。</p>
<p><strong>GUI 渲染线程 与 JavaScript引擎线程互斥！</strong></p>
<p>由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JavaScript线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JavaScript引擎为互斥的关系，当JavaScript引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到引擎线程空闲时立即被执行。</p>
<p><strong>JS阻塞页面加载</strong></p>
<p>由于GUI渲染线程与JavaScript执行线程是互斥的关系，当浏览器在执行JavaScript程序的时候，GUI渲染线程会被保存在一个队列中，直到JS程序执行完成，才会接着执行。因此如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p>
</li>
<li><p><strong>事件触发线程</strong></p>
<p>当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。</p>
</li>
<li><p><strong>定时器线程</strong></p>
<p>浏览器定时计数器并不是由JavaScript引擎计数的, 因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。</p>
</li>
<li><p><strong>网络请求线程</strong></p>
<p>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript引擎的处理队列中等</p>
<p>待处理。</p>
</li>
</ol>
<h4 id="5-2-EventLoop：事件循环"><a href="#5-2-EventLoop：事件循环" class="headerlink" title="5.2 EventLoop：事件循环"></a>5.2 EventLoop：事件循环</h4><p><strong>在ES6之前：</strong>所有JS的执行环境都有事件循环的内置机制，它随着时间的推移每次都调用JS引擎处理程序中多个代码块的执行。也就是说，是JS周围的环境来调度这些事情的。</p>
<p><img src="/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.png" alt="事件循环"></p>
<p>事件循环有一个简单的任务 —— 去监控执行栈和任务队列。如果执行栈是空的，它就会取出任务队列中的第一个事件，然后将它压入到任务中，然后运行它。</p>
<p>这样的迭代在事件循环中被称作一个 <strong>tick</strong>。每一个事件就是一个回调函数。</p>
<p><strong>5.2.1 执行栈和任务队列</strong></p>
<p><strong>栈（stack）</strong></p>
<p>栈在javascript中又称执行栈，调用栈，是一种后进先出的数组结构，<br> <code>Javascript</code> 有一个 主线程（<code>main thread</code>）和 调用栈(或执行栈<code>call-stack</code>)，主线各所有的任务都会被放到调用栈等待主线程执行。<br> JS调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空。</p>
<p><strong>队列（Queue）</strong></p>
<p>队列即任务队列<code>Task Queue</code>，是一种先进先出的一种数据结构。在队尾添加新元素，从队头移除元素。</p>
<p><strong>5.2.2 同步任务和异步任务</strong></p>
<p>javascript是单线程。单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。<br>于是js所有任务分为两种：同步任务，异步任务<br><strong>同步任务</strong>是调用立即得到结果的任务，同步任务在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；</p>
<p><strong>异步任务</strong>是调用无法立即得到结果，需要额外的操作才能预期结果的任务，异步任务不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p>
<p> JS引擎遇到异步任务（DOM事件监听、网络请求、setTimeout计时器等），会交给<strong>相应的线程</strong>单独去维护异步任务，等待某个时机（计时器结束、网络请求成功、用户点击DOM），然后由 事件触发线程 将异步对应的 回调函数 加入到消息队列中，消息队列中的回调函数等待被执行。</p>
<p><strong>具体来说，异步运行机制如下：</strong></p>
<ul>
<li>（1）所有同步任务都在主线程上执行，形成一个[执行栈]</li>
<li>（2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li>
<li>（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li>
<li>（4）主线程不断重复上面的第三步。</li>
</ul>
<p>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）</p>
<p><img src="/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.png" alt="事件循环"></p>
<p><strong>5.2.3 宏任务与微任务</strong></p>
<p>在挂起任务时，JS 引擎会将所有任务按照类别分到这两个队列中，首先在 宏任务 的队列中取出第一个任务，执行完毕后取出 微任务 队列中的所有任务顺序执行；之后再取 宏任务，周而复始，直至两个队列的任务都取完。</p>
<p>在事件循环中，每进行一次循环操作称为tick，通过阅读规范可知，每一次 tick 的任务处理模型是比较复杂的，其关键的步骤可以总结如下：</p>
<ol>
<li>在此次 tick 中选择最先进入队列的任务( oldest task )，如果有则执行(一次)</li>
<li>检查是否存在 Microtasks ，如果存在则不停地执行，直至清空Microtask Queue</li>
<li>更新 render</li>
<li>主线程重复执行上述步骤</li>
</ol>
<p>可以用一张图来说明下流程：</p>
<p><img src="/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%AE%8F%E4%BB%BB%E5%8A%A1.jpg" alt="微任务与宏任务"></p>
<p>规范中规定，task分为两大类, 分别是 Macro Task （宏任务）和 Micro Task（微任务）, 并且每个宏任务结束后, 都要清空所有的微任务,这里的 Macro Task也是我们常说的 task ，有些文章并没有对其做区分，后面文章中所提及的task皆看做宏任务( macro task)。</p>
<p>(macro)task 主要包含：script( 整体代码)、setTimeout、setInterval、I/O、UI 交互事件、setImmediate(Node.js 环境)</p>
<p>microtask主要包含：Promise、MutaionObserver、process.nextTick(Node.js 环境)</p>
<p>setTimeout/Promise 等API便是任务源，而进入任务队列的是由他们指定的具体执行任务。来自不同任务源的任务会进入到不同的任务队列。其中 setTimeout 与 setInterval 是同源的。</p>
<blockquote>
<p><strong>思考：为什么要区分宏任务和微任务？</strong></p>
<p>便于紧急任务插队？</p>
</blockquote>
<h3 id="6-异步编程的几种方法"><a href="#6-异步编程的几种方法" class="headerlink" title="6. 异步编程的几种方法"></a>6. 异步编程的几种方法</h3><h4 id="6-1-回调函数"><a href="#6-1-回调函数" class="headerlink" title="6.1 回调函数"></a>6.1 回调函数</h4><p><strong>6.1.1 回调函数的优缺点：</strong></p>
<p>回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而回调函数有一个致命的弱点，就是容易写出回调地狱</p>
<p><strong>6.1.2 多层回调会导致回掉地狱，那么如何解决这种问题呢？</strong></p>
<p>（1）promise</p>
<p>（2）generater</p>
<p>（3）async/await</p>
<h4 id="6-2-事件监听"><a href="#6-2-事件监听" class="headerlink" title="6.2 事件监听"></a>6.2 事件监听</h4><p>采用事件驱动模式，任务的执行不取决于代码的顺序，而取决于某个事件是否发生，如：<code>func.trigger(&#39;done&#39;)</code>：通过trigger函数触发某个事件。</p>
<p>这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合”（Decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。</p>
<h4 id="6-3-发布-订阅"><a href="#6-3-发布-订阅" class="headerlink" title="6.3 发布/订阅"></a>6.3 发布/订阅</h4><h4 id="6-4-Promise"><a href="#6-4-Promise" class="headerlink" title="6.4 Promise:"></a>6.4 Promise:</h4><p><strong>6.4.1 Promise的含义</strong></p>
<p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<p><strong><code>Promise</code>对象有以下两个特点。</strong></p>
<p>（1）<strong>对象的状态不受外界影响：</strong><code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>
<p>（2）<strong>一旦状态改变，就不会再变，任何时候都可以得到这个结果：</strong><code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>
<p><strong>6.4.2 Promise基本用法</strong></p>
<p>以Ajax异步请求为例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getJson=<span class="function"><span class="keyword">function</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> promise=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> handler=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.readyState!=<span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status===<span class="number">200</span>)&#123;</span><br><span class="line">                resolve(<span class="keyword">this</span>.response);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">const</span> client=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        client.open(<span class="string">"GET"</span>,url);</span><br><span class="line">        client.onreadystatechange=handler;</span><br><span class="line">        client.responseType=<span class="string">"json"</span>;</span><br><span class="line">        client.setRequestHeader(<span class="string">"Accept"</span>,<span class="string">"application/json"</span>);</span><br><span class="line">        client.send();</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line">getJson(<span class="string">"./posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Contents:'</span>+result);<span class="comment">//result为resolve()函数的参数，此处为返回的repsonse</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'出错率！'</span>+err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>6.4.3 Promise.prototype.then()</strong></p>
<p>它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，<code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数（可选）是<code>rejected</code>状态的回调函数。</p>
<p>可以采用链式写法：then方法后面再调用另一个then方法</p>
<p><strong>6.4.4  Promise.prototype.catch()</strong></p>
<p><code>Promise.prototype.catch</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。</p>
<p><strong>Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。</strong></p>
<p><strong>6.4.5 Promise.prototype.finally</strong></p>
<p><code>finally</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p>
<p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p>
<p><strong>6.4.6 Promise.all()</strong></p>
<p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p=<span class="built_in">Promise</span>.all([p1,p2,p3]);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Promise.all()</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例，如果不是，就会先调用下面讲到的<strong><code>Promise.resolve</code></strong>方法，将参数转为 Promise 实例，再进一步处理。另外，<code>Promise.all()</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</p>
<p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p>
<p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p>
<p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p>
<p><strong>6.4.7 Promise.race()</strong></p>
<p>Promise.race()方法同样是将多个Promise实例，包装成一个新的Promise实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p>
<p><strong>6.4.8 Promise.allsettled()</strong></p>
<p><code>Promise.allSettled()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束。该方法由 <a href="https://github.com/tc39/proposal-promise-allSettled" target="_blank" rel="noopener">ES2020</a> 引入。</p>
<p><strong>6.4.9 Promise.any()</strong></p>
<p><code>Promise.any()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。该方法目前是一个第三阶段的<a href="https://github.com/tc39/proposal-promise-any" target="_blank" rel="noopener">提案</a> 。</p>
<p><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是不会因为某个 Promise 变成<code>rejected</code>状态而结束</p>
<h4 id="6-5-Generator-生成器"><a href="#6-5-Generator-生成器" class="headerlink" title="6.5 Generator:生成器"></a>6.5 Generator:生成器</h4><h4 id="6-6-async-await"><a href="#6-6-async-await" class="headerlink" title="6.6 async/await"></a>6.6 async/await</h4><h3 id="7-前端中的事件流"><a href="#7-前端中的事件流" class="headerlink" title="7. 前端中的事件流"></a>7. 前端中的事件流</h3><h4 id="7-1-事件"><a href="#7-1-事件" class="headerlink" title="7.1 事件"></a>7.1 事件</h4><h4 id="7-2-冒泡"><a href="#7-2-冒泡" class="headerlink" title="7.2 冒泡"></a>7.2 冒泡</h4><h4 id="7-3-捕获"><a href="#7-3-捕获" class="headerlink" title="7.3 捕获"></a>7.3 捕获</h4><h4 id="7-4-如何让事件先冒泡后捕获？"><a href="#7-4-如何让事件先冒泡后捕获？" class="headerlink" title="7.4 如何让事件先冒泡后捕获？"></a>7.4 如何让事件先冒泡后捕获？</h4><h4 id="7-5-事件委托"><a href="#7-5-事件委托" class="headerlink" title="7.5 事件委托"></a>7.5 事件委托</h4><h4 id="7-6-mouseover-和mouseenter的区别"><a href="#7-6-mouseover-和mouseenter的区别" class="headerlink" title="7.6 mouseover 和mouseenter的区别"></a>7.6 mouseover 和mouseenter的区别</h4><h3 id="8-JS的节流和防抖"><a href="#8-JS的节流和防抖" class="headerlink" title="8. JS的节流和防抖"></a>8. JS的节流和防抖</h3><h3 id="9-JS的垃圾回收机制"><a href="#9-JS的垃圾回收机制" class="headerlink" title="9. JS的垃圾回收机制"></a>9. JS的垃圾回收机制</h3><p><a href="https://www.cnblogs.com/echolun/p/11503915.html" target="_blank" rel="noopener">参考博客</a></p>
<h4 id="9-1-栈、堆、队列"><a href="#9-1-栈、堆、队列" class="headerlink" title="9.1 栈、堆、队列"></a>9.1 栈、堆、队列</h4><p>JavaScript内存空间分为栈，堆，池，队列。其中栈存放变量，基本类型数据与指向复杂类型数据的引用指针；堆存放复杂类型数据；池又称为常量池，用于存放常量；而队列在任务队列也会使用。</p>
<h4 id="9-2-JS垃圾回收机制"><a href="#9-2-JS垃圾回收机制" class="headerlink" title="9.2 JS垃圾回收机制"></a>9.2 JS垃圾回收机制</h4><p>离开作用域的值被自动标记为可以回收，因此将在垃圾收集期间被删除</p>
<p>垃圾收集机制的原理：找出那些不再继续使用的变量，然后释放其占用的内存，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间）周期性地执行这一操作。</p>
<p><strong>如何标识无用变量</strong>：垃圾收集方式</p>
<p>（1）标记清除：思想是给当前不使用的值加上标记，然后再回收其内存。（<strong>JS中最常用的</strong>）</p>
<p>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后去掉环境中的变量以及被环境中变量引用的变量的标记，在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后垃圾收集机器完成<strong>内存清除</strong>工作，销毁那些带标记的值并回收他们所使用的内存空间。</p>
<p>（2）引用计数：（不太常见）跟踪记录每个值被引用的次数，当引用次数变为0时，将其占用的内存空间回收回来。但有一个严重问题：<strong>循环引用</strong>，因此被放弃了。</p>
<p>（3）性能问题：如何确定垃圾收集的时间间隔：IE7：静态临界值调整为动态修正（&lt;15%：临界值加倍；&gt;85%：重置回默认临界值）</p>
<p>（4）管理内存：<strong>解除引用</strong>：一旦数据不再有用，通过将其值设为null来释放其引用，目的是让值脱离执行环境，以便垃圾收集器下次运行时将其回收，同时也有助于消除循环引用现象。</p>
<h4 id="9-3-如何防止内存泄漏？"><a href="#9-3-如何防止内存泄漏？" class="headerlink" title="9.3 如何防止内存泄漏？"></a>9.3 如何防止内存泄漏？</h4><p>（1）减少使用全局变量，若一定要使用要记得在使用完毕后手动释放，如将变量指向null；</p>
<p>（2）避免被遗忘的定时器和回调函数；</p>
<p>（3）及时释放闭包中的变量；</p>
<p>（4）DOM的引用</p>
<h3 id="10-AJAX解决浏览器缓存问题"><a href="#10-AJAX解决浏览器缓存问题" class="headerlink" title="10. AJAX解决浏览器缓存问题"></a>10. AJAX解决浏览器缓存问题</h3><h3 id="11-eval是做什么的-（欺骗词法）"><a href="#11-eval是做什么的-（欺骗词法）" class="headerlink" title="11. eval是做什么的?（欺骗词法）"></a>11. eval是做什么的?（欺骗词法）</h3><p><strong>eval(str)：</strong>它的功能是将对应的字符串解析成js并执行，可以在运行期修改书写期的词法作用域:</p>
<p><strong>with(obj）：</strong>with可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符</p>
<p><strong>eval()函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而with()声明实际上是根据你传给它的对象凭空创建了一个新的词法作用域</strong></p>
<p><strong>为什么不推荐使用eval()和with()?</strong></p>
<p>(1)欺骗词法会导致性能下降</p>
<p>(2)会被严格模式所限制，with被完全禁止，而在保留核心功能的前提下，间接或非安全地使用eval()也被禁止了</p>
<p><strong>为什么会导致性能下降？</strong></p>
<p>JS引擎会在编译阶段进行数项的性能优化，其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。但如果引擎在代码中发现了eval()和with()，在悲观情况下可能会做不到任何优化。</p>
<p><strong>引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的</strong></p>
<h3 id="12-如何理解前端模块化？"><a href="#12-如何理解前端模块化？" class="headerlink" title="12. 如何理解前端模块化？"></a>12. 如何理解前端模块化？</h3><h4 id="12-1-说一下Commonjs-AMD-CMD"><a href="#12-1-说一下Commonjs-AMD-CMD" class="headerlink" title="12.1 说一下Commonjs,AMD,CMD"></a>12.1 说一下Commonjs,AMD,CMD</h4><h3 id="13-实现一个once函数，传入函数参数只执行一次"><a href="#13-实现一个once函数，传入函数参数只执行一次" class="headerlink" title="13. 实现一个once函数，传入函数参数只执行一次"></a>13. 实现一个once函数，传入函数参数只执行一次</h3><h3 id="14-如何实现一个私有变量，用getName方法可以访问，不能直接访问"><a href="#14-如何实现一个私有变量，用getName方法可以访问，不能直接访问" class="headerlink" title="14. 如何实现一个私有变量，用getName方法可以访问，不能直接访问"></a>14. 如何实现一个私有变量，用getName方法可以访问，不能直接访问</h3><p>（1）通过#设置类中的私有变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    #name='Bob';</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        this.#name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    getName()&#123;</span><br><span class="line">        return this.#name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> my=<span class="keyword">new</span> Person(<span class="string">'Lily'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(my.getName());</span><br></pre></td></tr></table></figure>

<p>（2）设置属性值的getter和setter</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="15-重排和重绘"><a href="#15-重排和重绘" class="headerlink" title="15. 重排和重绘"></a>15. 重排和重绘</h4><h3 id="15-重排和重绘-1"><a href="#15-重排和重绘-1" class="headerlink" title="15. 重排和重绘"></a>15. 重排和重绘</h3><p>重排（重构/回流/reflow）：当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建, 这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。</p>
<p>重绘（repaint或redraw）：当盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器便把这些元素都按照各自的特性绘制一遍，将内容呈现在页面上。重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。</p>
<p>触发重绘的条件：改变元素外观属性。如：color，background-color等。</p>
<p>注意：table及其内部元素可能需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花两倍时间，这就是我们尽量避免使用table布局页面的原因之一。</p>
<p>重绘和重排的关系：在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。所以，<strong>重排必定会引发重绘，但重绘不一定会引发重排。</strong></p>
<h3 id="16-const、let、var"><a href="#16-const、let、var" class="headerlink" title="16. const、let、var"></a>16. const、let、var</h3><h4 id="16-1-let-和-var-的区别："><a href="#16-1-let-和-var-的区别：" class="headerlink" title="16.1 let 和 var 的区别："></a>16.1 let 和 var 的区别：</h4><p>（1）let有块作用域，所声明的变量只在let命令所在的代码块内有效（for循环：<em>JavaScript引擎内部可以记住上一次循环的值</em>）</p>
<p>（2）let不存在变量提升：let:报错ReferenceError  var:输出undefined</p>
<p>（3）let暂时性死区：ES6 明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。“暂时性死区”也意味着<code>typeof</code>不再是一个百分之百安全的操作。</p>
<p>（4）let不允许在相同作用域内重复声明同一个变量</p>
<h4 id="16-2-为什么需要块级作用域？"><a href="#16-2-为什么需要块级作用域？" class="headerlink" title="16.2 为什么需要块级作用域？"></a>16.2 为什么需要块级作用域？</h4><p><strong>场景一：</strong>内层变量可能会覆盖外层变量；</p>
<p><strong>场景二：</strong>用来计数的循环变量泄露为全局变量</p>
<h4 id="16-3-const命令"><a href="#16-3-const命令" class="headerlink" title="16.3 const命令"></a>16.3 const命令</h4><p>（1）<code>const</code>声明的变量不得改变值，这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>
<p>（2）<code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效</p>
<p>（3）const命令声明的常量也不提升，也存在暂时性死区</p>
<p>（4）const声明的常量同样不可以重复声明</p>
<p><code>const</code>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于将对象声明为常量，该常量所存储的地址不能变，但对象本身可以变。可以用Object.freeze()方法将对象冻结</p>
<h3 id="17-性能问题"><a href="#17-性能问题" class="headerlink" title="17.性能问题"></a>17.性能问题</h3><p><a href="https://github.com/fouber/blog/issues/3" target="_blank" rel="noopener">https://github.com/fouber/blog/issues/3</a></p>
<h3 id="18-深拷贝和浅拷贝"><a href="#18-深拷贝和浅拷贝" class="headerlink" title="18.深拷贝和浅拷贝"></a>18.深拷贝和浅拷贝</h3><h4 id="18-1-什么是深拷贝和浅拷贝？"><a href="#18-1-什么是深拷贝和浅拷贝？" class="headerlink" title="18.1 什么是深拷贝和浅拷贝？"></a>18.1 什么是深拷贝和浅拷贝？</h4><p>浅拷贝和深拷贝都只针对于引用数据类型，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存；但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象；<br>   区别：浅拷贝只复制对象的第一层属性、深拷贝可以对对象的属性进行递归复制；</p>
<h4 id="18-2-常用的拷贝API："><a href="#18-2-常用的拷贝API：" class="headerlink" title="18.2 常用的拷贝API："></a>18.2 常用的拷贝API：</h4><p><strong>（1）Array.slice和Array.concat:只拷贝第一层</strong></p>
<p><strong>（2）Object.assign(targer,source1,source2…)：浅拷贝，只拷贝第一层</strong></p>
<p><strong>（3）扩展运算符：<code>...obj</code>：浅拷贝，只拷贝第一层</strong></p>
<h4 id="18-3-实现深拷贝的方法："><a href="#18-3-实现深拷贝的方法：" class="headerlink" title="18.3 实现深拷贝的方法："></a>18.3 实现深拷贝的方法：</h4><p><strong>（1）递归实现深拷贝</strong></p>
<p>缺陷：当遇到两个互相引用的对象，会出现死循环的情况，为了避免相互引用的对象导致死循环的情况，则应该在遍历的时候判断是否相互引用对象，如果是则退出循环；即<code>obj[i]==obj</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> copy=obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? []:&#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(obj &amp;&amp; <span class="keyword">typeof</span> obj===<span class="string">'object'</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> obj)&#123;</span><br><span class="line">            <span class="comment">//只拷贝实例属性</span></span><br><span class="line">            <span class="keyword">if</span>(obj.hasOwnProperty(prop))&#123;</span><br><span class="line">                <span class="keyword">if</span>(obj[prop]==obj)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (obj[prop]&amp;&amp;<span class="keyword">typeof</span> obj[prop]===<span class="string">'object'</span>)&#123;</span><br><span class="line">                    copy[prop]=deepCopy(obj[prop]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    copy[prop]=obj[prop];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）借用JSON对象的parse和stringfy</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> strCopy=<span class="built_in">JSON</span>.stringify(obj);</span><br><span class="line">    <span class="keyword">let</span> copy=<span class="built_in">JSON</span>.parse(strCopy);</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）除了上面两种方法之外，我们还可以借用JQ的extend方法。</strong></p>
<p><strong><code>$.extend( [deep ], target, object1 [, objectN ] )</code></strong></p>
<p><strong>deep</strong>表示是否深拷贝，为true为深拷贝，为false，则为浅拷贝</p>
<p><strong>target</strong> <strong>Object</strong>类型 目标对象，其他对象的成员属性将被附加到该对象上。</p>
<p><strong>object1 objectN</strong>可选。 Object类型 第一个以及第N个被合并的对象。 </p>
<h3 id="19-前端工程化与性能"><a href="#19-前端工程化与性能" class="headerlink" title="19. 前端工程化与性能"></a>19. 前端工程化与性能</h3><h4 id="19-1-前段工程的三个阶段"><a href="#19-1-前段工程的三个阶段" class="headerlink" title="19.1 前段工程的三个阶段"></a>19.1 前段工程的三个阶段</h4><p><strong>第一阶段：库/框架选型，代码规范：提高开发效率</strong></p>
<p><strong>第二阶段：简单构建优化：提高运行效率，即性能</strong></p>
<p><strong>第三阶段：JS/CSS模块化开发：分治！提高维护效率</strong></p>
<p>JS模块化：Common JS , AMD,UMD,ES6 Module</p>
<p>CSS模块化：基本都是在less,sass,stylus等预处理器的import/mixin特性支持下实现的 </p>
<p><strong>第四阶段：</strong>组件化开发和资源管理</p>
<p>当我们要开发一款完整的Web应用时，前端将面临更多的工程问题，比如：</p>
<ul>
<li>大体量：多功能、多页面、多状态、多系统；</li>
<li>大规模：多人甚至多团队合作开发；</li>
<li>高性能：CDN部署、<a href="https://developers.google.com/speed/docs/insights/LeverageBrowserCaching" target="_blank" rel="noopener">缓存控制</a>、<a href="https://developers.google.com/speed/docs/insights/LeverageBrowserCaching" target="_blank" rel="noopener">文件指纹</a>、缓存复用、请求合并、按需加载、同步/异步加载、移动端<a href="https://developers.google.com/speed/docs/insights/mobile" target="_blank" rel="noopener">首屏CSS内嵌</a>、HTTP 2.0服务端<a href="http://chimera.labs.oreilly.com/books/1230000000545/ch12.html#HTTP2_PUSH" target="_blank" rel="noopener">资源推送</a>。</li>
</ul>
<p><strong>组件化开发：</strong></p>
<p>整个前端项目可以划分为这么几种开发概念：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>JS模块</td>
<td>独立的算法和数据单元</td>
<td>浏览器环境检测(detect)，网络请求(ajax)，应用配置(config)，DOM操作(dom)，工具函数(utils)，以及组件里的JS单元</td>
</tr>
<tr>
<td>CSS模块</td>
<td>独立的功能性样式单元</td>
<td>栅格系统(grid)，字体图标(icon-fonts)，动画样式(animate)，以及组件里的CSS单元</td>
</tr>
<tr>
<td>UI组件</td>
<td>独立的可视/可交互功能单元</td>
<td>页头(header)，页尾(footer)，导航栏(nav)，搜索框(search)</td>
</tr>
<tr>
<td>页面</td>
<td>前端这种GUI软件的界面状态，是UI组件的容器</td>
<td>首页(index)，列表页(list)，用户管理(user)</td>
</tr>
<tr>
<td>应用</td>
<td>整个项目或整个站点被称之为应用，由多个页面组成</td>
<td></td>
</tr>
</tbody></table>
<p><strong>“智能”静态资源管理</strong></p>
<p>前端和客户端GUI有一个很大的不同：<strong>前端是一种远程部署，运行时增量下载的GUI软件</strong></p>
<p>前端应用没有安装过程，其所需程序资源都部署在远程服务器，用户使用浏览器访问不同的页面来加载不同的资源，随着页面访问的增加，渐进式的将整个程序下载到本地运行，“增量下载”是前端在工程上有别于客户端GUI软件的根本原因。</p>
<p>如果用户第一次访问页面就强制其加载全站静态资源再展示，相信会有很多用户因为失去耐心而流失。根据“增量”的原则，我们应该精心规划每个页面的资源加载策略，使得用户无论访问哪个页面都能按需加载页面所需资源，没访问过的无需加载，访问过的可以缓存复用，最终带来流畅的应用体验。</p>
<p>由“增量”原则引申出的前端优化技巧几乎成为了性能优化的核心，有加载相关的按需加载、延迟加载、预加载、请求合并等策略；有缓存相关的浏览器缓存利用，缓存更新、缓存共享、非覆盖式发布等方案；还有复杂的BigRender、BigPipe、Quickling、PageCache等技术。这些优化方案无不围绕着如何将增量原则做到极致而展开。</p>
<p><strong>静态网页资源的管理和优化</strong></p>
<p>静态资源管理系统=资源表+资源加载框架</p>
<blockquote>
<p><strong>资源表：</strong>资源表是一份数据文件（比如JSON），是项目中所有静态资源（主要是JS和CSS）的构建信息记录，通过构建工具扫描项目源码生成，是一种k-v结构的数据，以每个资源的id为key，记录了资源的类别、部署路径、依赖关系、打包合并等内容。</p>
<p><strong>资源加载框架：</strong>资源加载框架则提供一些资源引用的API，让开发者根据id来引用资源，替代静态的script/link标签来收集、去重、按需加载资源。调用这些接口时，框架通过查表来查找资源的各项信息，并递归查找其依赖的资源的信息，然后我们可以在这个过程中实现各种性能优化算法来“智能”加载资源。</p>
<p><img src="/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E6%A1%86%E6%9E%B6.png" alt="资源加载框架"></p>
</blockquote>
<h4 id="19-2-浅析前端工程化"><a href="#19-2-浅析前端工程化" class="headerlink" title="19.2 浅析前端工程化"></a>19.2 浅析前端工程化</h4><p><a href="https://www.cnblogs.com/ihardcoder/p/5378290.html" target="_blank" rel="noopener">参考</a></p>
<h5 id="19-2-1-前端工程化，面临的问题是如何提高编码-gt-测试-gt-维护阶段的生产效率"><a href="#19-2-1-前端工程化，面临的问题是如何提高编码-gt-测试-gt-维护阶段的生产效率" class="headerlink" title="19.2.1 前端工程化，面临的问题是如何提高编码-&gt;测试-&gt;维护阶段的生产效率"></a>19.2.1 前端工程化，面临的问题是如何提高<strong>编码-&gt;测试-&gt;维护</strong>阶段的生产效率</h5><h5 id="19-2-2-要解决前端工程化的问题，可以从两个角度入手：开发和部署。"><a href="#19-2-2-要解决前端工程化的问题，可以从两个角度入手：开发和部署。" class="headerlink" title="19.2.2 要解决前端工程化的问题，可以从两个角度入手：开发和部署。"></a>19.2.2 要解决前端工程化的问题，可以从两个角度入手：<strong>开发</strong>和<strong>部署</strong>。</h5><p>从<strong>开发角度</strong>，要解决的问题包括：</p>
<p>（1）提高开发生产效率；</p>
<p>（2）降低维护难度。</p>
<p>这两个问题的解决方案有两点：</p>
<p>（1）制定开发规范，提高团队协作能力；</p>
<p>（2）分治。软件工程中有个很重要的概念叫做<strong>模块化开发</strong>其中心思想就是分治。</p>
<p>从<strong>部署角度</strong>，要解决的问题主要是<strong>资源管理</strong>，包括：</p>
<p>（1）代码审查；</p>
<p>（2）压缩打包；</p>
<p>（3）增量更新；</p>
<p>（4）单元测试；</p>
<p><strong>模块化开发：</strong>模块白盒，组件黑盒。颗粒度不同</p>
<h5 id="19-2-3-构建-amp-编译"><a href="#19-2-3-构建-amp-编译" class="headerlink" title="19.2.3 构建&amp;编译"></a>19.2.3 构建&amp;编译</h5><p>2016年节点下，一个典型的web前后端协作模式如下图：</p>
<p><img src="/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/before.png" alt="before"></p>
<p><strong>大前端模式下：</strong></p>
<p><img src="/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/now.png" alt="now"></p>
<p>大前端体系下，前端开发人员掌握着Node.js搭建的web server层。与上文提到的常规前端开发体系下相比，省略了mock server的角色，但是构建在大前端体系下的作用并没有发生改变。也就是说，不论是大前端还是“小”前端，构建阶段在两种模式下的作用完全一致，<strong>构建的作用就是对静态资源以及模板进行处理</strong>，换句话说：<strong>构建的核心是资源管理</strong>。</p>
<p><strong>什么是资源管理？</strong></p>
<p>前端的资源可以分为<strong>静态资源</strong>和<strong>模板</strong>。模板对静态资源是引用关系，两者相辅相成，构建过程中需要对两种资源使用不同的构建策略。</p>
<p>静态资源包括js、css、图片等文件，目前随着一些新规范和css预编译器的普及，通常开发阶段的静态资源是：</p>
<ol>
<li>es6/7规范的文件；</li>
<li>less/sass等文件（具体看团队技术选型）；</li>
<li>[可选]独立的小图标，在构建阶段使用工具处理成spirit图片。</li>
</ol>
<p>构建可以分为<strong>工具层面</strong>和<strong>平台层面</strong>的功能：</p>
<ul>
<li>工具层面</li>
</ul>
<ol>
<li>预编译，包括es6/7语法转译（比如babel）、css预编译器处理（如将less/sass编译成css）、spirit图片生成；</li>
<li>依赖打包。分析文件依赖关系，将同步依赖的的文件打包在一起，减少http请求数量；</li>
<li>资源嵌入。比如小于10KB的图片编译为base64格式嵌入文档，减少一次http请求；（对于jpg格式的图片，每一个图片相当于一次http请求，图片多了的话，耗性能比较严重。而将jpg转化成base64格式的图片，则极大地减少了请求数，因为base64是文本格式，可以直接放在body里。一般对于小于10KB大小的图片进行base64转码）</li>
<li>文件压缩。减小文件体积；</li>
<li>hash指纹。通过给文件名加入hash指纹，以应对浏览器缓存引起的静态资源更新问题；</li>
<li>代码审查。避免上线文件的低级错误；</li>
<li>模板构建。</li>
</ol>
<ul>
<li>平台层面</li>
</ul>
<ol>
<li>文件监听。配合动态构建、浏览器自动刷新等功能，提高开发效率；</li>
<li>mock server。并非所有前端团队都是大前端（事实上很少团队是大前端），即使在大前端体系下，mock server的存在也是很有必要的；</li>
</ol>
<h5 id="19-2-4-总结"><a href="#19-2-4-总结" class="headerlink" title="19.2.4 总结;"></a>19.2.4 总结;</h5><p>一个完整的前端工程体系应该包括：</p>
<p>（1）统一的开发规范；</p>
<p>（2）组件化/模块化开发；</p>
<p>（3）构建流程。</p>
<h4 id="19-3-前端功能化-构建"><a href="#19-3-前端功能化-构建" class="headerlink" title="19.3 前端功能化-构建"></a>19.3 前端功能化-构建</h4><p><strong>构建的核心是资源管理，</strong>就是把前端工程师开发的源代码进行编译、压缩、打包等一系列操作，最终产出可以直接上线或者可供后端工程师的资源。</p>
<p>构建可以划分为<strong>纯前端构建</strong>（不涉及后端模板的构建，经过构建之后的前端代码可以直接上线，这种情况下大多是数据驱动UI的web应用，可以使用一些框架如:React,Vue等）和<strong>前后端协作构建</strong></p>
<h5 id="19-3-1-基本功能"><a href="#19-3-1-基本功能" class="headerlink" title="19.3.1 基本功能"></a>19.3.1 基本功能</h5><h5 id="19-3-2-整体流程"><a href="#19-3-2-整体流程" class="headerlink" title="19.3.2 整体流程"></a>19.3.2 整体流程</h5><p><img src="/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B.png" alt="构建流程"></p>
<p>上图中提到的各个构建行为中，代码审查、预编译、uglify&amp;compress、hash指纹实现较容易，各构建模式中没有差异，而依赖打包管理和模板构建是需要额外配置并且方案不唯一。</p>
<p>模板前端构建和后端构建的对比如下：<br><img src="/2020/03/25/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94JavaScript/%E5%89%8D%E5%90%8E%E7%AB%AF%E6%A8%A1%E6%9D%BF%E6%9E%84%E5%BB%BA.png" alt="前后端模板构建"></p>
<p>根据表格的对比数据可以看出模板后端构建相比前端构建有很大优势。但是作为构建平台，应该同时支持两种模式。所以在开发构建平台的时候，开发者应该提供前端构建的功能接口，由用户选择是否采用。</p>
<h4 id="19-4-前端模块化"><a href="#19-4-前端模块化" class="headerlink" title="19.4 前端模块化"></a>19.4 前端模块化</h4><h5 id="19-4-1-JS模块化编程：CommonJS-AMD-CMD"><a href="#19-4-1-JS模块化编程：CommonJS-AMD-CMD" class="headerlink" title="19.4.1 JS模块化编程：CommonJS,AMD,CMD"></a>19.4.1 JS模块化编程：CommonJS,AMD,CMD</h5><p>AMD/CMD/CommonJs是JS模块化开发的标准，目前对应的实现是RequireJs/SeaJs/nodeJs.</p>
<p><strong>（）</strong></p>
<h4 id="19-4-前端工程化-性能"><a href="#19-4-前端工程化-性能" class="headerlink" title="19.4 前端工程化-性能"></a>19.4 前端工程化-性能</h4>]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序开发</title>
    <url>/2020/03/25/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h4 id="1-小程序与普通网页开发的区别"><a href="#1-小程序与普通网页开发的区别" class="headerlink" title="1. 小程序与普通网页开发的区别"></a>1. 小程序与普通网页开发的区别</h4><p>小程序的主要开发语言是 JavaScript ，小程序的开发同普通的网页开发相比有很大的相似性。对于前端开发者而言，从网页开发迁移到小程序的开发成本并不高，但是二者还是有些许区别的。</p>
<p><strong>网页开发渲染线程和脚本线程是互斥的</strong>，这也是为什么长时间的脚本运行可能会导致页面失去响应，而<strong>在小程序中，二者是分开的，分别运行在不同的线程中</strong>。网页开发者可以使用到各种浏览器暴露出来的 DOM API，进行 DOM 选中和操作。而如上文所述，小程序的逻辑层和渲染层是分开的，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的DOM API和BOM API。这一区别导致了前端开发非常熟悉的一些库，例如 jQuery、 Zepto 等，在小程序中是无法运行的。同时 JSCore 的环境同 NodeJS 环境也是不尽相同，所以一些 NPM 的包在小程序中也是无法运行的。</p>
<p>网页开发者需要面对的环境是各式各样的浏览器，PC 端需要面对 IE、Chrome、QQ浏览器等，在移动端需要面对Safari、Chrome以及 iOS、Android 系统中的各式 WebView 。而小程序开发过程中需要面对的是两大操作系统 iOS 和 Android 的微信客户端，以及用于辅助开发的小程序开发者工具，小程序中三大运行环境也是有所区别的，如表1-1所示。</p>
<p>表1-1 小程序的运行环境</p>
<table>
<thead>
<tr>
<th align="left"><strong>运行环境</strong></th>
<th align="left"><strong>逻辑层</strong></th>
<th align="left"><strong>渲染层</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">iOS</td>
<td align="left">JavaScriptCore</td>
<td align="left">WKWebView</td>
</tr>
<tr>
<td align="left">安卓</td>
<td align="left">V8</td>
<td align="left">chromium定制内核</td>
</tr>
<tr>
<td align="left">小程序开发者工具</td>
<td align="left">NWJS</td>
<td align="left">Chrome WebView</td>
</tr>
</tbody></table>
<p>网页开发者在开发网页的时候，只需要使用到浏览器，并且搭配上一些辅助工具或者编辑器即可。小程序的开发则有所不同，需要经过申请小程序帐号、安装小程序开发者工具、配置项目等等过程方可完成。</p>
]]></content>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>使用AJAX</title>
    <url>/2020/03/22/%E4%BD%BF%E7%94%A8AJAX/</url>
    <content><![CDATA[<h4 id="1-AJAX是什么？"><a href="#1-AJAX是什么？" class="headerlink" title="1. AJAX是什么？"></a>1. AJAX是什么？</h4><p>AJAX = 异步 JavaScript 和 XML。</p>
<p>AJAX 是一种用于创建快速动态网页的技术。</p>
<p>通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p>
<p>传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。</p>
<h4 id="2-怎么用AJAX？"><a href="#2-怎么用AJAX？" class="headerlink" title="2.怎么用AJAX？"></a>2.怎么用AJAX？</h4><h5 id="2-1-创建XMLHttpRequest对象"><a href="#2-1-创建XMLHttpRequest对象" class="headerlink" title="2.1 创建XMLHttpRequest对象"></a>2.1 创建XMLHttpRequest对象</h5><p>老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlhttp;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;</span><br><span class="line">  <span class="comment">//  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码</span></span><br><span class="line">  xmlhttp= <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">// IE6, IE5 浏览器执行代码</span></span><br><span class="line">  xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-1-向服务器发送请求"><a href="#2-1-向服务器发送请求" class="headerlink" title="2.1 向服务器发送请求"></a>2.1 向服务器发送请求</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(method,url,<span class="keyword">async</span>);   <span class="comment">// 规定请求的类型、URL以及是否异步处理请求</span></span><br><span class="line"><span class="comment">//  method:请求方法：GET或POST</span></span><br><span class="line"><span class="comment">//  url:文件在服务器上的位置</span></span><br><span class="line"><span class="comment">//  async：true（异步）或false（同步）</span></span><br><span class="line">xmlhttp.setRequestHeader(<span class="string">"首部字段"</span>,<span class="string">"首部字段值"</span>)</span><br><span class="line">xmlhttp.send(str);   <span class="comment">// 将请求发送到服务器</span></span><br><span class="line"><span class="comment">//  str:仅用于POST请求</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-服务器响应"><a href="#2-2-服务器响应" class="headerlink" title="2.2 服务器响应"></a>2.2 服务器响应</h4><p>如果来自服务器的响应是XML，而且需要作为XML对象进行解析，使用<code>responseXML</code></p>
<p>如果来自服务器的响应并非XML，使用<code>xmlhttp.responseText</code></p>
<h5 id="2-3-监听readyState事件，响应已就绪时处理响应结果"><a href="#2-3-监听readyState事件，响应已就绪时处理响应结果" class="headerlink" title="2.3 监听readyState事件，响应已就绪时处理响应结果"></a>2.3 监听readyState事件，响应已就绪时处理响应结果</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xmlhttp.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).innerHTML=xmlhttp.responseText;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>readyState：存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。</p>
<ul>
<li>0: 请求未初始化</li>
<li>1: 服务器连接已建立</li>
<li>2: 请求已接收</li>
<li>3: 请求处理中</li>
<li>4: 请求已完成，且响应已就绪</li>
</ul>
<p>status：200：“OK”，404：未找到页面</p>
<h4 id="3-通过JQuery使用AJAX"><a href="#3-通过JQuery使用AJAX" class="headerlink" title="3. 通过JQuery使用AJAX"></a>3. 通过JQuery使用AJAX</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;<span class="attr">name</span>:value, <span class="attr">name</span>:value, ... &#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>面经——CSS</title>
    <url>/2020/03/17/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94CSS/</url>
    <content><![CDATA[<h4 id="1-盒模型"><a href="#1-盒模型" class="headerlink" title="1.盒模型"></a>1.盒模型</h4><p>CSS盒子模型：网页设计中CSS技术所使用的一种思维模型。</p>
<p>CSS盒子模型组成：外边距（margin）、边框（border）、内边距（padding）、内容（content）。</p>
<p>CSS盒子模型分为：标准W3C盒子模型，IE盒子模型，注意在两种模型中宽（width）和高（height）包括属性的不同。</p>
<p><strong>标准W3C盒子模型：</strong></p>
<p><img src="/2020/03/17/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94CSS/D:%5CmyBlog%5Csource_posts%5C%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94CSS%5CW3C%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.png" alt="W3C盒子模型"></p>
<p>W3C模型中：</p>
<p>　　　　　　CSS中的宽（width）=内容（content）的宽</p>
<p>　　　　　　CSS中的高（height）=内容（content）的高</p>
<p><strong>IE盒子模型：</strong></p>
<p><img src="/2020/03/17/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94CSS/D:%5CmyBlog%5Csource_posts%5C%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94CSS%5CIE%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.png" alt="IE盒子模型"></p>
<p>IE模型中：</p>
<p>　　　　　　CSS中的宽（width）=内容（content）的宽+（border+padding）*2</p>
<p>　　　　　　CSS中的高（height）=内容（content）的高+（border+padding）*2</p>
<p><strong>boxsizing取值：</strong></p>
<p>content-box：默认值，盒子的宽度或高度为总尺度（margin+border+padding+元素内容）</p>
<p>border-box：盒子的宽度或高度为元素内容的宽度或高度</p>
<p>inherit：元素继承父元素的盒子模型模式</p>
<p><img src="/2020/03/17/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94CSS/D:%5CmyBlog%5Csource_posts%5C%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94CSS%5C%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.png" alt="盒子模型"></p>
<h4 id="2-BFC-块状模式上下文"><a href="#2-BFC-块状模式上下文" class="headerlink" title="2. BFC:块状模式上下文"></a>2. BFC:块状模式上下文</h4><h4 id="3-布局"><a href="#3-布局" class="headerlink" title="3. 布局"></a>3. 布局</h4><p><strong>flex布局</strong></p>
<p><strong>浮动布局，浮动清除</strong></p>
<p><strong>z-index的定位方法</strong></p>
<p><strong>三栏布局</strong></p>
<blockquote>
<p><strong>浮动布局时,三个div的生成顺序有没有影响？</strong></p>
</blockquote>
<p><strong>垂直居中的方法</strong></p>
<blockquote>
<p><strong>如何实现图片在某个容器中居中？</strong></p>
<p><strong>有一个width:300,height:300的div，怎么实现在屏幕上垂直水平居中？</strong></p>
</blockquote>
<h4 id="4-display属性"><a href="#4-display属性" class="headerlink" title="4.display属性"></a>4.display属性</h4><p><strong>block，inline，inline-block的区别</strong></p>
<p>block:默认换行，width缺省时为父元素宽度，可以设置高宽，padding-top,padding-bottom,margin-top,margin-bottom</p>
<p>inline:可以排在一行，无法设置宽高，padding-top,padding-bottom,margin-top,margin-bottom无效</p>
<p>inline-block:不换行，可以设置元素宽高</p>
<h4 id="2-画一条0-5px的线"><a href="#2-画一条0-5px的线" class="headerlink" title="2. 画一条0.5px的线"></a>2. 画一条0.5px的线</h4><h4 id="3-link标签和import标签的区别"><a href="#3-link标签和import标签的区别" class="headerlink" title="3. link标签和import标签的区别"></a>3. link标签和import标签的区别</h4><h4 id="4-transition和animation的区别"><a href="#4-transition和animation的区别" class="headerlink" title="4. transition和animation的区别"></a>4. transition和animation的区别</h4><h4 id="8-关于JS动画和CSS3动画的差异性"><a href="#8-关于JS动画和CSS3动画的差异性" class="headerlink" title="8. 关于JS动画和CSS3动画的差异性"></a>8. 关于JS动画和CSS3动画的差异性</h4><h4 id="9-说一下块元素和行内元素"><a href="#9-说一下块元素和行内元素" class="headerlink" title="9. 说一下块元素和行内元素"></a>9. 说一下块元素和行内元素</h4><h4 id="10-多行元素的文本省略号"><a href="#10-多行元素的文本省略号" class="headerlink" title="10. 多行元素的文本省略号"></a>10. 多行元素的文本省略号</h4><h4 id="11-visibility-hidden-opacity-0-display-none"><a href="#11-visibility-hidden-opacity-0-display-none" class="headerlink" title="11.  visibility=hidden,opacity=0,display : none"></a>11.  visibility=hidden,opacity=0,display : none</h4><h4 id="12-双边距重叠问题（外边距折叠）"><a href="#12-双边距重叠问题（外边距折叠）" class="headerlink" title="12. 双边距重叠问题（外边距折叠）"></a>12. 双边距重叠问题（外边距折叠）</h4><h4 id="13-position属性"><a href="#13-position属性" class="headerlink" title="13. position属性"></a>13. position属性</h4><h4 id="14-浮动清除"><a href="#14-浮动清除" class="headerlink" title="14. 浮动清除"></a>14. 浮动清除</h4><h4 id="15-CSS3新特性"><a href="#15-CSS3新特性" class="headerlink" title="15. CSS3新特性"></a>15. CSS3新特性</h4><h4 id="16-CSS选择器有哪些，优先级如何？"><a href="#16-CSS选择器有哪些，优先级如何？" class="headerlink" title="16. CSS选择器有哪些，优先级如何？"></a>16. CSS选择器有哪些，优先级如何？</h4><h4 id="17-CSS3的溢出处理，overflow的原理"><a href="#17-CSS3的溢出处理，overflow的原理" class="headerlink" title="17.  CSS3的溢出处理，overflow的原理"></a>17.  CSS3的溢出处理，overflow的原理</h4><h4 id="18-三栏布局的实现方式"><a href="#18-三栏布局的实现方式" class="headerlink" title="18. 三栏布局的实现方式"></a>18. 三栏布局的实现方式</h4><blockquote>
<p><strong>浮动布局时,三个div的生成顺序有没有影响？</strong></p>
</blockquote>
<h4 id="19-calc属性"><a href="#19-calc属性" class="headerlink" title="19. calc属性"></a>19. calc属性</h4><h4 id="20-display-table和本身的table有什么区别"><a href="#20-display-table和本身的table有什么区别" class="headerlink" title="20. display: table和本身的table有什么区别"></a>20. display: table和本身的table有什么区别</h4><h4 id="21-用的最多的css属性是什么？"><a href="#21-用的最多的css属性是什么？" class="headerlink" title="21. 用的最多的css属性是什么？"></a>21. 用的最多的css属性是什么？</h4><h4 id="22-box-sizing"><a href="#22-box-sizing" class="headerlink" title="22.box-sizing"></a>22.box-sizing</h4><h4 id="23-css预处理器有什么？"><a href="#23-css预处理器有什么？" class="headerlink" title="23.css预处理器有什么？"></a>23.css预处理器有什么？</h4><h4 id="24-设置一个元素的背景颜色，背景颜色会填充哪些区域？"><a href="#24-设置一个元素的背景颜色，背景颜色会填充哪些区域？" class="headerlink" title="24. 设置一个元素的背景颜色，背景颜色会填充哪些区域？"></a>24. 设置一个元素的背景颜色，背景颜色会填充哪些区域？</h4><h4 id="25-CSS画正方体，三角形"><a href="#25-CSS画正方体，三角形" class="headerlink" title="25.CSS画正方体，三角形"></a>25.CSS画正方体，三角形</h4>]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>面经——HTML_浏览器</title>
    <url>/2020/03/17/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94HTML-%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
    <content><![CDATA[<h4 id="1-Cookie、session、sessionStorage、localStorage的区别"><a href="#1-Cookie、session、sessionStorage、localStorage的区别" class="headerlink" title="1. Cookie、session、sessionStorage、localStorage的区别"></a>1. Cookie、session、sessionStorage、localStorage的区别</h4><p><strong>1.1 cookie:</strong>存储在浏览器端</p>
<p>（1）cookie数据始终在同源的http请求中携带（即使不需要），可以在客户端和服务器之间来回传输；</p>
<p>（2）cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下，存储的数据只有4k左右。</p>
<p>（3）关闭浏览器也不会失效，只要在设置的过期时间之前一直有效，在所有同源窗口中都是共享的</p>
<p>（4）用于保存登录状态</p>
<p><strong>1.2 session</strong></p>
<p>放在服务器端</p>
<p><strong>1.3 sessionStorage</strong></p>
<p>（1）不会把数据发给服务器，仅在本地保存；</p>
<p>（2）存储数据的大小比cookie大的多，可以达到5M或更大</p>
<p>（3）仅在当前浏览器窗口关闭前有效，关闭后数据自动删除；</p>
<p><strong>1.4 localStorage</strong></p>
<p>（1）不会把数据发给服务器，仅在本地保存；</p>
<p>（2）存储数据的大小比cookie大的多，可以达到5M或更大</p>
<p>（3）存储持久数据，浏览器关闭后数据不丢失除非主动删除；</p>
<h4 id="2-HTML5-Web存储"><a href="#2-HTML5-Web存储" class="headerlink" title="2. HTML5 Web存储"></a>2. HTML5 Web存储</h4><p><strong>2.1 本地存储用户的浏览数据</strong></p>
<p>早期用的是cookie，但cookie会将存储的数据发送到浏览器端，且存储数据量小，只有4K左右</p>
<p><strong>H5提供的Web Storage：localStorage和sessionStorage</strong></p>
<p><strong>常用API:</strong></p>
<p>保存数据：localStorage.setItem(key,value);</p>
<p>读取数据：localStorage.getItem(key);</p>
<p>删除单个数据：localStorage.removeItem(key)</p>
<p>删除所有数据：localStorage.clear();</p>
<p>得到某个索引的key:localStorage.key(index);</p>
<p><strong>2.2 应用程序缓存：使用HTML5，建立cache manifest文件,可以轻松创建web应用的离线版本</strong></p>
<p><strong>什么是应用程序缓存？</strong></p>
<p>（1）离线浏览：用户可在应用离线时使用它们；</p>
<p>（2）速度：已缓存资源加载速度更快；</p>
<p>（3）减少服务器负载：浏览器将只从服务器下载更新过或更改过的资源</p>
<p><strong>怎样启用应用程序缓存？</strong></p>
<p><code>&lt;html manifest=&quot;demo.appache&quot;&gt;</code></p>
<p><strong>Manifest文件的结构：</strong></p>
<p>manifest是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容），可分为3部分：</p>
<ul>
<li>CACHE MANIFEST：在此标题下列出的文件将在首次下载后进行缓存</li>
<li>NETWORK:在此标题下列出的文件需要与服务器进行连接，且不会被缓存</li>
<li>FALLBACK:在此标题下列出的文件规定当前页面无法访问时的回退页面（比如404页面）</li>
</ul>
<h4 id="3-说几个H5-的新标签"><a href="#3-说几个H5-的新标签" class="headerlink" title="3. 说几个H5 的新标签"></a>3. 说几个H5 的新标签</h4><p>首先html5为了更好的实践web语义化，增加了header，footer，nav,aside,section等语义化标签，在表单方面，为了增强表单，为input增加了color，email,data ,range等类型，在存储方面，提供了sessionStorage，localStorage,和离线存储，通过这些存储方式方便数据在客户端的存储和获取，在多媒体方面规定了音频和视频元素audio和vedio，另外还有地理定位，canvas画布，拖放，多线程编程的web worker和websocket协议</p>
<p><strong>3.1 H5浏览器支持：</strong></p>
<p>（1）将HTML5元素定义为块元素：</p>
<p>HTML5 定了 8 个新的 HTML <strong>语义（semantic）</strong> 元素。所有这些元素都是 <strong>块级</strong> 元素。为了能让旧版本的浏览器正确显示这些元素，你可以设置 CSS 的 <strong>display</strong> 属性值为 <strong>block</strong>:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">header</span>,<span class="selector-tag">article</span>,<span class="selector-tag">section</span>,<span class="selector-tag">aside</span>,<span class="selector-tag">footer</span>,<span class="selector-tag">nav</span>,<span class="selector-tag">main</span>,<span class="selector-tag">figure</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）为HTML添加新元素</p>
<p>通过<code>document.createElement(&#39;&#39;)</code>创建新元素，设置样式，以标签&lt;&gt;形式添加到html中；</p>
<p>（3）IE浏览器问题：IE8及以前不支持以上方法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--[if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">    &lt;script src="http://cdn.static.runoob.com/libs/html5shiv/3.7/html5shiv.min.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>3.2 H5新元素</strong></p>
<p>（1）<code>&lt;canvas&gt;</code>:依赖于分辨率；不支持事件处理器；文本渲染能力弱；能够以.png和.jpg格式保存结果图像；最适合图像密集型的游戏，其中许多对象会被频繁重绘；通过JS绘制2D图形；</p>
<p>（2）<code>&lt;svg&gt;</code>：矢量图形，不依赖于分辨率；支持事件处理器；最适合带有大量渲染区域的应用程序（比如谷歌地图）；复杂度高会减慢渲染速度（任何过渡使用DOM的应用都不快）；不适合游戏应用；使用XML描述2D图形；</p>
<p>（3）<code>&lt;math&gt;</code>：MathML:数学标记语言，是一种基于XML的标准，用来在互联网上书写数学符号和公式的置标语言。</p>
<p>（4）<code>&lt;video&gt;</code>：支持的视频格式：MP4,WebM,Ogg</p>
<p>（5）<code>&lt;audio&gt;</code>：支持的音频格式：MP3,Wav,Ogg</p>
<p><strong>3.3 H5 Geolocation地理定位</strong></p>
<p><code>navigator.geolocation.getCurrentPosition(showPositon,showError)</code>：获取用户位置；</p>
<p>showPosition:获取位置成功后回调的函数；返回一个coordinates对象：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>coords.latitude</td>
<td>十进制数的纬度</td>
</tr>
<tr>
<td>coords.longitude</td>
<td>十进制数的经度</td>
</tr>
<tr>
<td>coords.accuracy</td>
<td>位置精度</td>
</tr>
<tr>
<td>coords.altitude</td>
<td>海拔，海平面以上以米计</td>
</tr>
<tr>
<td>coords.altitudeAccuracy</td>
<td>位置的海拔精度</td>
</tr>
<tr>
<td>coords.heading</td>
<td>方向，从正北开始以度计</td>
</tr>
<tr>
<td>coords.speeding</td>
<td>速度，以米/每秒计</td>
</tr>
<tr>
<td>timestamp</td>
<td>响应的日期/时间</td>
</tr>
</tbody></table>
<p>showError获取位置失败后回调的函数：</p>
<table>
<thead>
<tr>
<th>error.code</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>error.PERMISSION_DENIED</td>
<td>用户拒绝对获取地理位置的请求</td>
</tr>
<tr>
<td>error.POSITION_UNAVAILABLE</td>
<td>位置信息不可用</td>
</tr>
<tr>
<td>error.TIMEOUT</td>
<td>请求用户地理位置超时</td>
</tr>
<tr>
<td>error.UNKNOWN_ERROR</td>
<td>未知错误</td>
</tr>
</tbody></table>
<p><strong>3.4 新增的input类型</strong></p>
<p>type=”color”,”date”,”datetime”,”datetime-local”,”email”,”month”,”number”,”range”,”search”,”tel”,”time”,”url”,”week”</p>
<p><strong>3.5 新增表单元素</strong></p>
<p><code>&lt;datalist&gt;</code>：规定form或input 域应该拥有自动完成功能；</p>
<p><code>&lt;keygen&gt;</code>：提供一种验证用户的可靠方法，规定用于表单的密钥对生成器字段</p>
<p>（私钥存储与客户端，公钥则被发送到服务器，公钥可用于之后验证用户的客户端证书）</p>
<p><code>&lt;output&gt;</code>：用于不同类型的输出，比如计算或脚本输出</p>
<p><strong>3.6 新增表单属性</strong></p>
<p>（1）<code>&lt;form&gt;</code>：</p>
<p>新属性：</p>
<p>autocomplete:提交后刷新页面，可以自动补完，值为’on’或’off’;</p>
<p>novalidate：一个布尔值，规定在提交表单时不应该验证form或input域</p>
<p>（2）<code>&lt;input&gt;</code>：新属性：autocomplete, autofocus, form, formaction, formenctype, formmethod, formnovalidate, formtarget,</p>
<p> height和width:只用于image类型的<code>&lt;input&gt;</code>标签，规定高宽加载时可以预留适当空间</p>
<p> list, min与max, multiple, pattern(regexp), placeholder, required, step</p>
<h4 id="4-HTML5-拖放"><a href="#4-HTML5-拖放" class="headerlink" title="4. HTML5 拖放"></a>4. HTML5 拖放</h4><p><strong>4.1 首先将被拖动元素设置为可拖动：draggable:true</strong></p>
<p><strong>4.2 为被拖动元素添加ondragstart响应事件drag(event)</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drag</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event.dataTransfer.setData(<span class="string">"Text"</span>,event.target.id);</span><br><span class="line">&#125;<span class="comment">//dataTransfer.setData()方法设置被拖数据的数据类型和值</span></span><br></pre></td></tr></table></figure>

<p><strong>4.3 放到何处：ondragover:规定在何处放置被拖动的数据</strong></p>
<p>默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式，通过调用ondragover事件的event.preventDefault()方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">event.preventDefault();</span><br></pre></td></tr></table></figure>

<p><strong>4.4. 进行放置：ondrop</strong></p>
<p>当放置被拖数据时，会发生drop事件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drop</span>(<span class="params">ev</span>)</span>&#123;</span><br><span class="line">    ev.preventDefault();</span><br><span class="line">    <span class="keyword">var</span> data=ev.dataTransfer.getData(<span class="string">"Text"</span>);</span><br><span class="line">    ev.target.appendChild(<span class="built_in">document</span>.getElementById(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码解释：</p>
<ul>
<li>调用 preventDefault() 来避免浏览器对数据的默认处理（drop 事件的默认行为是以链接形式打开）</li>
<li>通过 dataTransfer.getData(“Text”) 方法获得被拖的数据。该方法将返回在 setData() 方法中设置为相同类型的任何数据。</li>
<li>被拖数据是被拖元素的 id (“drag1”)</li>
<li>把被拖元素追加到放置元素（目标元素）中</li>
</ul>
<h4 id="5-web-worker"><a href="#5-web-worker" class="headerlink" title="5.web worker"></a>5.web worker</h4><p>当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。</p>
<p>web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。</p>
<p><strong>5.1 先检测浏览器是否支持Web Worker</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span>(Worker)!==<span class="string">"undefined"</span>)&#123;</span><br><span class="line">    <span class="comment">//是的！Web Worker支持！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//抱歉！Web Worker不支持！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5.2 创建外部web worker脚本文件</strong>：存储于‘demo_worker.js’</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timedCount</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i=i+<span class="number">1</span>;</span><br><span class="line">    postMessage(i);</span><br><span class="line">    setTimeout(<span class="string">"timedCount()"</span>,<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line">timedCount();</span><br></pre></td></tr></table></figure>

<p><strong>5.3 创建web worker对象,以调用上一步的文件</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> w==<span class="string">"undefined"</span>)&#123;</span><br><span class="line">    w=<span class="keyword">new</span> worker(<span class="string">'demo_workers.js'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加'onmessage'事件监听器：</span></span><br><span class="line">w.onmessage=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'result'</span>).innerHTML=event.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5.4 终止Web Worker</strong></p>
<p>当我们创建 web worker 对象后，它会继续监听消息（即使在外部脚本完成之后）直到其被终止为止。</p>
<p>如需终止 web worker，并释放浏览器/计算机资源，请使用 terminate() 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">w.terminate();</span><br></pre></td></tr></table></figure>

<h4 id="6-HTML语义化"><a href="#6-HTML语义化" class="headerlink" title="6. HTML语义化"></a>6. HTML语义化</h4><p><strong>6.1 语义化是什么？</strong></p>
<p>语义化标签有自己的含义，简单来说就是让机器可以读懂内容</p>
<p>我们应该在发布内容的时候，就用机器可读的、被广泛认可的语义信息来描述内容，来降低机器处理 Web 内容的难度。</p>
<p><strong>6.2 语义化标签的优势</strong></p>
<p>（1）代码结构清晰，方便阅读，有利于团队合作开发；</p>
<p>（2）方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以语义的方式来渲染网页；</p>
<p>（3）有利于搜索引擎优化（SEO）</p>
<p><strong>6.3 常见的语义化标签</strong></p>
<table>
<thead>
<tr>
<th>标签</th>
<th>语义</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;title&gt;</code></td>
<td>页面主体内容</td>
</tr>
<tr>
<td><code>&lt;hn&gt;</code></td>
<td>h1~h6，分级标题，<code>&lt;h1&gt;</code>与 <code>&lt;title&gt;</code>协调有利于搜索引擎优化</td>
</tr>
<tr>
<td><code>&lt;ul&gt;</code></td>
<td>无序列表</td>
</tr>
<tr>
<td><code>&lt;ol&gt;</code></td>
<td>有序列表</td>
</tr>
<tr>
<td><code>&lt;header&gt;</code></td>
<td>页眉通常包括网站标志、主导航、全站链接以及搜索框</td>
</tr>
<tr>
<td><code>&lt;nav&gt;</code></td>
<td>标记导航，仅对文档中重要的链接群使用</td>
</tr>
<tr>
<td><code>&lt;main&gt;</code></td>
<td>页面主要内容，一个页面只能使用一次，如果是web应用，则包围其主要功能</td>
</tr>
<tr>
<td><code>&lt;article&gt;</code></td>
<td>定义外部的内容，其中的内容独立于文档的其余部分</td>
</tr>
<tr>
<td><code>&lt;section&gt;</code></td>
<td>定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分</td>
</tr>
<tr>
<td><code>&lt;aside&gt;</code></td>
<td>定义其所处内容之外的内容。如侧栏、文章的一组链接、广告、友情链接、相关产品列表等</td>
</tr>
<tr>
<td><code>&lt;footer&gt;</code></td>
<td>页脚，只有当父级是body时，才是整个页面的页脚。</td>
</tr>
<tr>
<td><code>&lt;small&gt;</code></td>
<td>呈现小号字体效果，指定细则，输入免责声明、注解、署名、版权。</td>
</tr>
<tr>
<td><code>&lt;strong&gt;</code></td>
<td>和 <code>em</code> 标签一样，用于强调文本，但它强调的程度更强一些。</td>
</tr>
<tr>
<td><code>&lt;em&gt;</code></td>
<td>将其中的文本表示为强调的内容，表现为斜体。</td>
</tr>
<tr>
<td><code>&lt;mark&gt;</code></td>
<td>使用黄色突出显示部分文本。</td>
</tr>
<tr>
<td><code>&lt;figure&gt;</code></td>
<td>规定独立的流内容（图像、图表、照片、代码等等）（默认有40px左右margin）。</td>
</tr>
<tr>
<td><code>&lt;figcaption&gt;</code></td>
<td>定义 <code>figure</code> 元素的标题，应该被置于 <code>figure</code> 元素的第一个或最后一个子元素的位置。</td>
</tr>
<tr>
<td><code>&lt;cite&gt;</code></td>
<td>表示所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题。</td>
</tr>
<tr>
<td><code>&lt;blockquoto&gt;</code></td>
<td>定义块引用，块引用拥有它们自己的空间。</td>
</tr>
<tr>
<td><code>&lt;q&gt;</code></td>
<td>短的引述（跨浏览器问题，尽量避免使用）</td>
</tr>
<tr>
<td><code>&lt;time&gt;</code></td>
<td>datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式。</td>
</tr>
<tr>
<td><code>&lt;abbr&gt;</code></td>
<td>简称或缩写</td>
</tr>
<tr>
<td><code>&lt;dfn&gt;</code></td>
<td>定义术语元素，与定义必须紧挨着，可以在描述列表dl元素中使用</td>
</tr>
<tr>
<td><code>&lt;address&gt;</code></td>
<td>作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）。</td>
</tr>
<tr>
<td><code>&lt;del&gt;</code></td>
<td>移除的内容</td>
</tr>
<tr>
<td><code>&lt;ins&gt;</code></td>
<td>添加的内容</td>
</tr>
<tr>
<td><code>&lt;code&gt;</code></td>
<td>标记代码</td>
</tr>
<tr>
<td><code>&lt;meter&gt;</code></td>
<td>定义已知范围或分数值内的标量测量。（Internet Explorer 不支持 meter 标签）</td>
</tr>
<tr>
<td><code>&lt;progress&gt;</code></td>
<td>定义运行中的进度（进程）</td>
</tr>
</tbody></table>
<h4 id="7-HTML5服务器发送事件（Server-Sent-Events）"><a href="#7-HTML5服务器发送事件（Server-Sent-Events）" class="headerlink" title="7. HTML5服务器发送事件（Server-Sent Events）"></a>7. HTML5服务器发送事件（Server-Sent Events）</h4><p>Server-Sent事件：单向消息传递，网页自动获取来自服务器的更新</p>
<p>EventSource对象用于接收服务器发送事件通知</p>
<p><strong>webSocket:全双工通讯</strong></p>
<h4 id="8-Doctype作用？严格模式与混杂模式如何区分？它们有何意义？"><a href="#8-Doctype作用？严格模式与混杂模式如何区分？它们有何意义？" class="headerlink" title="8. Doctype作用？严格模式与混杂模式如何区分？它们有何意义？"></a>8. Doctype作用？严格模式与混杂模式如何区分？它们有何意义？</h4><h4 id="9-讲讲viewport和移动端布局"><a href="#9-讲讲viewport和移动端布局" class="headerlink" title="9. 讲讲viewport和移动端布局"></a>9. 讲讲viewport和移动端布局</h4><h4 id="10-DOM中的各种宽度、高度"><a href="#10-DOM中的各种宽度、高度" class="headerlink" title="10. DOM中的各种宽度、高度"></a>10. DOM中的各种宽度、高度</h4><table>
<thead>
<tr>
<th>属性</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>offsetWidth</td>
<td>只读：width+padding-left+padding-right+border-left+border-right+元素的垂直滚动条宽度（如果存在且渲染）</td>
</tr>
<tr>
<td>offsetHeight</td>
<td>只读：height+padding-top+padding-bottom+border-top+border-bottom+元素的水平滚动条高度（如果存在且渲染）</td>
</tr>
<tr>
<td>offsetLeft</td>
<td>只读：父容器的padding-left+子元素的margin-left</td>
</tr>
<tr>
<td>offsetTop</td>
<td>只读：父容器的padding-top+子元素的margin-top</td>
</tr>
<tr>
<td>clientWidth</td>
<td>只读：width+padding-left+padding-right，不包括垂直滚动条的宽度</td>
</tr>
<tr>
<td>clientHeight</td>
<td>只读： height + padding-top+padding-bottom，不包括水平滚动条的高度</td>
</tr>
<tr>
<td>clientLeft</td>
<td>只读：border-left-width</td>
</tr>
<tr>
<td>clientTop</td>
<td>只读：border-top-width</td>
</tr>
<tr>
<td>scrollWidth</td>
<td>与scrollHeight类似</td>
</tr>
<tr>
<td>scrollHeight</td>
<td>该值等于该元素在不使用滚动条的情况下为了适应视口中所用内容所需的最小高度。 没有垂直滚动条的情况下，scrollHeight值与元素视图填充所有内容所需要的最小值<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/clientHeight" target="_blank" rel="noopener"><code>clientHeight</code></a>相同。包括元素的padding，但不包括元素的border和margin。scrollHeight也包括 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::before" target="_blank" rel="noopener"><code>::before</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::after" target="_blank" rel="noopener"><code>::after</code></a>这样的伪元素。</td>
</tr>
<tr>
<td>scrollLeft</td>
<td>左边被卷进去的宽度</td>
</tr>
<tr>
<td>scrollTop</td>
<td>一个元素的 <code>scrollTop</code> 值是这个元素的<strong>内容顶部</strong>（卷起来的）到它的视口可见内容（的顶部）的距离的度量。当一个元素的内容没有产生垂直方向的滚动条，那么它的 <code>scrollTop</code> 值为<code>0</code>。</td>
</tr>
</tbody></table>
<p><strong>几个API函数</strong></p>
<p>网页可见区域宽： document.body.clientWidth;<br>网页可见区域高： document.body.clientHeight;<br>网页可见区域宽： document.body.offsetWidth (包括边框和垂直滚动条的宽);<br>网页可见区域高： document.body.offsetHeight (包括边框和水平滚动条的高);<br>网页正文全文宽： document.body.scrollWidth;<br>网页正文全文高： document.body.scrollHeight;<br>网页被卷去的高： document.body.scrollTop;<br>网页被卷去的左： document.body.scrollLeft;<br>网页正文部分上： window.screenTop;<br>网页正文部分左： window.screenLeft;<br>屏幕分辨率的高： window.screen.height;<br>屏幕分辨率的宽： window.screen.width;<br>屏幕可用工作区高度： window.screen.availHeight</p>
<blockquote>
<p>element.offsetTop：距父元素的距离，循环直到页面顶端，获取图片和页面顶端的距离</p>
<p>document.documentElement.scrollTop||document.body.scrollTop:卷起的高度</p>
<p>document.documentElement.clientHeight:属于DOM：可视区域的高度（不包括包括水平滚动栏和工具栏的高度）</p>
<p>window.innerHeight:属于BOM：获得的是可视区域的高度，同时包括横向滚动条的高度。(IE8以及低版本浏览器不支持)</p>
</blockquote>
<h4 id="11-说几个很实用的BOM属性对象方法"><a href="#11-说几个很实用的BOM属性对象方法" class="headerlink" title="11. 说几个很实用的BOM属性对象方法"></a>11. 说几个很实用的BOM属性对象方法</h4><h4 id="12-HTML5-Web-SQL数据库"><a href="#12-HTML5-Web-SQL数据库" class="headerlink" title="12. HTML5 Web SQL数据库"></a>12. HTML5 Web SQL数据库</h4><p>Web SQL数据库API并不是H5规范的一部分，而是一个独立的规范：</p>
<p><strong>核心方法：</strong></p>
<ul>
<li>openDatabase：这个方法使用现有的数据库或者新建的数据库创建一个数据库对象。</li>
<li>transaction：这个方法让我们能够控制一个事务，以及基于这种情况执行提交或者回滚。</li>
<li>execute Sql：这个方法用于执行实际的 SQL 查询。</li>
</ul>
<h4 id="13-iframe是什么，有什么缺点？"><a href="#13-iframe是什么，有什么缺点？" class="headerlink" title="13. iframe是什么，有什么缺点？"></a>13. iframe是什么，有什么缺点？</h4>]]></content>
      <tags>
        <tag>HTML</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>面经——计算机网络</title>
    <url>/2020/03/17/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>本文经过借鉴书籍资料、他人博客、牛客网面经总结出的知识点</p>
<h4 id="1-http和https"><a href="#1-http和https" class="headerlink" title="1.http和https"></a>1.http和https</h4><p><strong>1.1 http是什么？</strong></p>
<p>超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p>
<p><strong>1.2 https是什么？</strong></p>
<p>是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p>
<a id="more"></a>

<p><strong>1.3 https的工作原理</strong></p>
<p>https的SSL加密是在传输层实现的</p>
<p>客户端在使用https方式与Web服务器通信时有以下几个步骤，如图所示。</p>
<p><img src="https%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="https工作流程"></p>
<p>客户使用https url访问服务器，则要求web 服务器建立ssl链接。</p>
<p>web服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给客户端。</p>
<p>客户端和web服务器端开始协商SSL链接的安全等级，也就是加密等级。</p>
<p>客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。</p>
<p>web服务器通过自己的私钥解密出会话密钥。</p>
<p>web服务器通过会话密钥加密与客户端之间的通信。</p>
<p><strong>1.4 https和http的区别</strong></p>
<p>http传输的数据都是未加密的，也就是明文的，网景公司设置了SSL协议来对http协议传输的数据进行加密处理，简单来说https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。<br>主要的区别如下：</p>
<p>（1）http是明文传输，https则是具有安全性的SSL加密传输协议；</p>
<p>（2）http无法进行身份验证，而https可以通过CA证书进行身份验证，但成本提高了；</p>
<p>（3）http无法保证传输信息的完整性，即传输过程中有可能遭篡改；</p>
<p>（4）端口不同：一般而言，http协议的端口是80，https协议的端口是443</p>
<p><strong>1.5 https的优点</strong></p>
<p>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p>
<p>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</p>
<p>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p>
<p>谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</p>
<p><strong>1.6 https的缺点</strong></p>
<p>https握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电。</p>
<p>https缓存不如http高效，会增加数据开销。</p>
<p>SSL证书也需要钱，功能越强大的证书费用越高。</p>
<p>SSL证书需要绑定IP，不能再同一个ip上绑定多个域名，ipv4资源支持不了这种消耗</p>
<h4 id="2-谈一下TCP"><a href="#2-谈一下TCP" class="headerlink" title="2. 谈一下TCP"></a>2. 谈一下TCP</h4><p><img src="/2020/03/17/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%8A%A5%E5%A4%B4.jpg" alt="TCP报头"></p>
<p>序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。</p>
<p>确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。</p>
<p>确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效</p>
<p>同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。</p>
<p>终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接</p>
<p>PS：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。</p>
<p>SYN：请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1</p>
<p><img src="/2020/03/17/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%AD%97%E6%AE%B5.png" alt="TCP字段"></p>
<p><strong>2.1 TCP的三次握手和四次挥手</strong></p>
<p>（1）三次握手过程如图：</p>
<p><img src="/2020/03/17/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="TCP三次握手"></p>
<p>第一次握手：建立连接时，客户端发送syn包（syn=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</p>
<p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
<p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p>
<p>（2）四次挥手过程如图：</p>
<p><img src="/2020/03/17/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcp%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="tcp四次挥手"></p>
<p>1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。<br>2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。<br>3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。<br>4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。<br>5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。<br>6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p>
<p><strong>2.2 TCP和UDP的区别</strong></p>
<p>TCP：提供的是面向连接、可靠的字节流服务，即客户端和服务器端传输数据之前必须先进行TCP三次握手连接，才能传输数据。并且提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。</p>
<p>UDP（User Data Protocol，用户数据报协议）是一个简单的面向数据报的运输层协议。它不提供可靠性，只是把应用程序传给IP层的数据报发送出去，但是不能保证它们能到达目的地。由于UDP在传输数据报前不用再客户和服务器之间建立一个连接，且没有超时重发等机制，所以传输速度很快。UDP报头如下图：</p>
<p><img src="/2020/03/17/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/UDP%E6%8A%A5%E5%A4%B4.png" alt="UDP报头"></p>
<p><strong>TCP和UDP的区别：</strong></p>
<p>（1）TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接<br>（2）TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保  证可靠交付<br>（3）TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的<br> UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）<br>（4）每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信<br>（5）TCP首部开销20字节;UDP的首部开销小，只有8个字节<br>（6）TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</p>
<h4 id="3-WebSocket的实现和应用"><a href="#3-WebSocket的实现和应用" class="headerlink" title="3.WebSocket的实现和应用"></a>3.WebSocket的实现和应用</h4><p>HTTP瓶颈：</p>
<p>（1）一条连接上只可发送一个请求</p>
<p>（2）请求只能从客户端开始。客户端不可以接收除响应以外的指令</p>
<p>（3）请求/响应首部未经压缩就发送。首部信息越多延迟越大</p>
<p>（4）发送冗长的首部。每次互相发送相同的首部造成的浪费较多</p>
<p>（5）可任意选择数据压缩格式。非强制压缩发送</p>
<p><strong>使用浏览器进行全双工通信的WebSocket</strong></p>
<p><strong>什么是WebSocket?</strong></p>
<p>WebSocket是HTML5中的协议，支持持久连续，http协议不支持持久性连接。Http1.0和HTTP1.1都不支持持久性的链接，HTTP1.1中的keep-alive，将多个http请求合并为1个（减少重复建立tcp连接的次数，但一个请求只能对应一个响应，管线化可以使客户端不需要等待响应即发送下一次请求，但仍是一个请求对应一个响应）</p>
<p><strong>主要特点：</strong></p>
<p>（1）服务器端推送功能</p>
<p>（2）减少通信量：只要建立起WebSocket通信，就希望<strong>一直保持连接状态</strong>，和HTTP相比，不但每次连接时的总开销减少，而且由于WebSocket的<strong>首部信息很小</strong>，通信量也相应减少了</p>
<p><strong>为了实现WebSocket通信，在HTTP连接建立以后，需要完成一次“握手”的步骤</strong></p>
<p><img src="/2020/03/17/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/webSocket%E5%BB%BA%E7%AB%8B%E8%BF%87%E7%A8%8B.png" alt="webSocket建立过程"></p>
<h4 id="4-HTTP请求的方式："><a href="#4-HTTP请求的方式：" class="headerlink" title="4.HTTP请求的方式："></a>4.HTTP请求的方式：</h4><p>（1）GET：获取资源</p>
<p>（2）POST：传输实体主体</p>
<p>（3）PUT：传输文件：就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求URI指定的位置。但是鉴于HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的Web网站不使用该方法。</p>
<p>（4）HEAD：获得报文首部：用于确认URI的有效性及资源更新的日期时间等</p>
<p>（5）DELETE：删除文件：按照请求URI删除指定的资源（不带验证机制，一般不使用）</p>
<p>（6）OPTIONS：询问支持的方法：用来查询针对请求URI指定的资源支持的方法</p>
<p>（7）TRACE：追踪路径：让Web服务器端将之前的请求通信环回给客户端，客户端通过TRACE方法可以查询发送出去的请求是怎样被加工/篡改的，但是该方法 不常用，易引发XST（Cross-Site Tracing,跨站追踪）攻击</p>
<p>（8）CONNECT：要求用隧道协议连接代理：要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer,安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输</p>
<p><strong>4.1 HEAD方法：</strong></p>
<p>head：类似于get请求，只不过返回的响应中没有具体的内容，用户获取报头</p>
<p>options：允许客户端查看服务器的性能，比如说服务器支持的请求方式等等。</p>
<p><strong>4.2 GET和POST的区别：</strong></p>
<p><img src="/2020/03/17/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/POST%E4%B8%8EGET.png" alt="POST与GET"></p>
<h4 id="5-简单说一下HTTP2-0"><a href="#5-简单说一下HTTP2-0" class="headerlink" title="5.简单说一下HTTP2.0"></a>5.简单说一下HTTP2.0</h4><h4 id="6-一个图片url访问后直接下载怎样实现？"><a href="#6-一个图片url访问后直接下载怎样实现？" class="headerlink" title="6.一个图片url访问后直接下载怎样实现？"></a>6.一个图片url访问后直接下载怎样实现？</h4><h4 id="7-说一下web-Quality（无障碍）"><a href="#7-说一下web-Quality（无障碍）" class="headerlink" title="7.说一下web Quality（无障碍）"></a>7.说一下web Quality（无障碍）</h4><h4 id="8-补充400和401、403状态码"><a href="#8-补充400和401、403状态码" class="headerlink" title="8.补充400和401、403状态码"></a>8.补充400和401、403状态码</h4><p>常用的HTTP状态码</p>
<p><strong>状态码类别：</strong></p>
<p>1XX：Information（信息性状态码）：接收的请求正在处理</p>
<p><strong>2XX：Success（成功状态码）：请求正常处理完毕</strong></p>
<p>200 OK：表示从客户端发来的请求在服务器端被正常处理了</p>
<p>204 No Content：表示服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分</p>
<p>206 Partial Content：表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求</p>
<p><strong>3XX：Redirection（重定向状态码）：需要进行附加操作以完成请求</strong></p>
<p>301 Moved Permanently：永久性重定向，该状态码表示请求的资源已被分配了新的URI，<strong>以后</strong>应使用资源现在所指的URI</p>
<p>302 Found：临时性重定向，该状态码表示请求的资源已被分配了新的URI，希望用户<strong>本次</strong>能使用新的URI访问</p>
<p>303 See Other：与302状态码有着相同功能，但303状态码明确表示客户端应当采用GET方法获取资源，这点与302有区别</p>
<p>304 Not Modified（与重定向无关）：表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况，不包含任何响应的主体部分(<strong>如协商缓存机制中的：If-Modified-Since和If-None-Match</strong>)</p>
<p>307 Temporary Redirect（临时重定向）：与302有着相同含义，遵守浏览器标准，不会从POST变为GET</p>
<p><strong>4XX：Client Error（客户端错误状态码）：服务器无法处理请求</strong></p>
<p>400 Bad Request：表示请求报文中存在语法错误</p>
<p>401 Unauthorized：表示发送的请求需要有通过HTTP认证的认证信息，另外若之前已进行过一次HTTP请求，则表示用户认证失败</p>
<p>403 Forbidden：表明对请求资源的访问被服务器拒绝了</p>
<p>404 Not Found：表明服务器上无法找到请求的资源（也可以在服务器端拒绝请求且不想说明理由时使用）</p>
<p>412 Precondition Failed :先决条件失败</p>
<p><strong>5XX：Server Error（服务器错误状态码）：服务器处理请求出错</strong></p>
<p>500 Internal Server Error：该状态码表示服务器端在执行请求时发生了错误</p>
<p>503 Service Unavailable：表明服务器端暂时处于超负载或正在进行停机维护，现在无法处理请求</p>
<h4 id="9-fetch发送2次请求的原因"><a href="#9-fetch发送2次请求的原因" class="headerlink" title="9. fetch发送2次请求的原因"></a>9. fetch发送2次请求的原因</h4><p>Fetch API 提供了一个 JavaScript 接口，用于访问和操纵 HTTP 管道的一些具体部分，例如请求和响应。它还提供了一个全局 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalFetch/fetch" target="_blank" rel="noopener"><code>fetch()</code></a> 方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。</p>
<p>这种功能以前是使用 <code>XMLHttpRequest</code> 实现的。Fetch 提供了一个更理想的替代方案，可以很容易地被其他技术使用，例如 <code>Service Workers</code>。Fetch 还提供了专门的逻辑空间来定义其他与 HTTP 相关的概念，例如 CORS 和 HTTP 的扩展。</p>
<p><strong>请注意，<code>fetch</code> 规范与 <code>jQuery.ajax()</code> 主要有三种方式的不同：</strong></p>
<ul>
<li>当接收到一个代表错误的 HTTP 状态码时，从 <code>fetch()</code> 返回的 Promise <strong>不会被标记为 reject，</strong> 即使响应的 HTTP 状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 <code>ok</code> 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject。</li>
<li><code>fetch()</code> <strong>不会接受跨域 cookies；</strong>你也不能使用 <code>fetch()</code> 建立起跨域会话。其他网站的 <code>Set-Cookie</code> 头部字段将会被无视。</li>
<li><code>fetch</code> <strong>不会发送 cookies</strong>。除非你使用了<em>credentials</em> 的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters" target="_blank" rel="noopener">初始化选项</a>。（自 2017 年 8 月 25 日以后，默认的 credentials 政策变更为 <code>same-origin</code>。Firefox 也在 61.0b13 版本中进行了修改）</li>
</ul>
<p><strong>特点:</strong><br>（1）第一个参数是URL:<br>（2）第二个是可选参数，可以控制不同配置的 init 对象<br>（3）使用了 JavaScript Promises 来处理结果/回调:</p>
<p><strong>配置：</strong></p>
<p>Promise fetch(String url [, Object options]);<br>Promise fetch(Request req [, Object options]);</p>
<p><strong>面试题目：</strong></p>
<p><strong>fetch发送post请求的时候，总是发送2次，第一次状态码是204，第二次才成功？</strong></p>
<p>原因很简单，因为你用fetch的post请求的时候，导致fetch 第一次发送了一个Options请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求</p>
<h4 id="10-Web跨域请求及解决方案"><a href="#10-Web跨域请求及解决方案" class="headerlink" title="10. Web跨域请求及解决方案"></a>10. Web跨域请求及解决方案</h4><p><strong>10.1 跨域请求：（是浏览器的同源策略所导致的）</strong>就是指当前发起请求的域与所请求资源所在的域不同</p>
<p><strong>同域：</strong>协议+域名+端口均相同</p>
<blockquote>
<p>主域名：csdn.net</p>
<p>子域名：blog.csdn.net</p>
<p>URL的构成：http：//主机名.域名（端口号、参数、查询等可选）</p>
<p>域名的级别：</p>
<p>如：<a href="http://www.sina.com.cn:其中sina.com.cn为新浪Web服务器的域名，该域名是三级域名">www.sina.com.cn:其中sina.com.cn为新浪Web服务器的域名，该域名是三级域名</a></p>
</blockquote>
<p><strong>浏览器的同源策略（SOP:Same-origin Policy）：</strong>为了防止XSS,CSRF(Cross-site request forgery:跨站请求伪造)：<a href="https://www.cnblogs.com/itsuibi/p/10752868.html" target="_blank" rel="noopener">攻击的具体解释</a></p>
<blockquote>
<p><strong>CSRF攻击需要满足的条件：</strong></p>
<p>（1）登录受信任网站A，并在本地生成Cookie。（如果用户没有登录网站A，那么网站B在诱导的时候，请求网站A的api接口时，会提示你登录）</p>
<p>（2）在不登出A的情况下，访问危险网站B（其实是利用了网站A的漏洞）。</p>
<p>CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的</p>
<p><strong>XSS攻击</strong>的核心原理是：不需要你做任何的登录认证，它会通过合法的操作（比如在url中输入、在评论框中输入），向你的页面注入脚本（可能是js、hmtl代码块等）。</p>
<p>最后导致的结果可能是：</p>
<p>盗用Cookie破坏页面的正常结构，插入广告等恶意内容D-doss攻击</p>
<p>XSS的防范方式：</p>
<p>（1）编码：将用户输入的数据以纯文本形式输出，不会引起JS执行</p>
<p>（2）过滤：移除用户输入的和事件相关的属性。如onerror可以自动触发攻击，还有onclick等。（总而言是，过滤掉一些不安全的内容）移除用户输入的Style节点、Script节点、Iframe节点。（尤其是Script节点，它可是支持跨域的呀，一定要移除）。</p>
<p>（3）校正：避免直接对HTML Entity进行解码。使用DOM Parse转换，校正不配对的DOM标签。</p>
<p><strong>CSRF和XSS的区别：</strong></p>
<p>区别一：</p>
<p>CSRF：需要用户先登录网站A，获取 cookie。XSS：不需要登录。</p>
<p>区别二：（原理的区别）</p>
<p>CSRF：是利用网站A本身的漏洞，去请求网站A的api。XSS：是向网站 A 注入 JS代码，然后执行 JS 里的代码，篡改网站A的内容。</p>
</blockquote>
<p>同源策略（Same origin policy）是一种约定，<strong>它是浏览器最核心也是最基本的安全功能</strong>。同源策略限制了来自不同源（相对于当前页面而言）的document或script，对当前document的某些属性进行读取或是设置，举例来说，A网站（<a href="http://www.aaa.com）上有某个脚本，在B网站（www.bbb.com）未曾加载该脚本时，该脚本不能读取或是修改B网站的DOM节点数据。" target="_blank" rel="noopener">www.aaa.com）上有某个脚本，在B网站（www.bbb.com）未曾加载该脚本时，该脚本不能读取或是修改B网站的DOM节点数据。</a></p>
<p>在浏览器中，<code>&lt;img&gt;、&lt;iframe&gt;、&lt;link&gt;</code>等标签都可以跨域加载资源，而不受同源策略的限制。这些带“src”的标签每次加载时，实际上是由浏览器发起了一次GET请求。不同于XMLHttpRequest的是，通过src属性加载的资源，浏览器限制了JavaScript的权限，使其不能读写返回的内容。</p>
<p><strong>出于安全考虑，浏览器会限制从JS脚本发起的跨源HTTP请求。 例如，</strong>XMLHttpRequest和Fetch API都遵循同源策略。</p>
<p>在同源策略影响下，域名A向域名B发送Ajax请求，或操作Cookie、LocalStorage、indexDB等数据,或操作dom，js就会受到限制，但请求css，js等静态资源不受限制</p>
<p><img src="/2020/03/17/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5.png" alt="浏览器同源策略"></p>
<blockquote>
<p>浏览器同源策略主要的限制范围:</p>
<p>（1） Cookie、LocalStorage、sessionStorage和 IndexDB 无法读取。<br>（2） DOM 节点无法读取和设置。<br>（3） AJAX 请求不能发送。</p>
</blockquote>
<p><strong>10.2 跨域问题的解决方案</strong>：<a href="https://segmentfault.com/a/1190000017312269" target="_blank" rel="noopener">参考</a></p>
<p><strong>解决跨域的思路</strong></p>
<ul>
<li>被调用方解决： 被调用方解决-支持跨域（根据http协议关于跨域方面的要求，增加响应头信息，告诉浏览器允许被跨域调用）（因为在发生跨域请求时首先调用方发送一个预检请求（OPTIONS请求），这个请求就会被带上允许跨越的请求头信息）</li>
<li>调用方解决：使用代理做调用解决跨域问题-隐藏跨域（利用nginx的反向代理，使访问同一个域名不同的资源路径会代理到不同的服务器上，每个跨域的请求都会带上origin请求头字段，因为访问的资源都是同域名下的，所以不会产生跨越问题）</li>
</ul>
<p><strong>（1）JSONP跨域：JSON是一种数据格式，JSONP是一种数据调用的方式</strong></p>
<p>jsonp就是利用了script标签的src属性是没有跨域的限制的，从而达到跨域访问的目的。因此它的最基本原理就是：动态添加一个<code>&lt;script&gt;</code>标签来实现。<a href="https://blog.csdn.net/hansexploration/article/details/80314948" target="_blank" rel="noopener">详细解释</a>，可以使用ajax中包装的jsonp</p>
<blockquote>
<p>ajax与jsonp的异同：</p>
<p>1、ajax和jsonp这两种技术在调用方式上”看起来”很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装。</p>
<p>2、但ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加</p>
</blockquote>
<p>jsonp缺点：只能使用get请求，不推荐使用</p>
<p><strong>（2）CORS（Cross-Origin Resource Sharing）跨域资源共享：使用较广泛</strong></p>
<p>跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。</p>
<p>Cross-Origin Resource Sharing跨域资源共享,应该算是现在比较推荐的跨域处理方案.不仅适用于各种Method,而且更加方便和简单<br>目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p>
<p>CORS分为两类：简单请求和非简单请求，<a href="https://www.cnblogs.com/tag6254/p/10357744.html" target="_blank" rel="noopener">详细介绍看这里</a> ，如：</p>
<p><strong>简单请求：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;cors HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/17/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CORS%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82.png" alt="CORS简单请求"></p>
<p><strong>非简单请求</strong>会发出一次预检测请求，返回码是204，预检测通过才会真正发出请求，这才返回200。这里通过前端发请求的时候增加一个额外的headers来触发非简单请求。</p>
<p><strong>（3）window.postMessage</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">otherWindow.postMessage(message, targetOrigin, [transfer]);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>otherwindow:其他窗口的一个引用，比如iframe的contentWindow属性、执行<a href="https://developer.mozilla.org/en-US/docs/DOM/window.open" target="_blank" rel="noopener">window.open</a>返回的窗口对象、或者是命名过或数值索引的<a href="https://developer.mozilla.org/en-US/docs/DOM/window.frames" target="_blank" rel="noopener">window.frames</a>。</p>
</blockquote>
<p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p>
<ul>
<li>iframe嵌套页面跨域通信</li>
<li>页面和其打开的新窗口的通信</li>
<li>多窗口之间消息传递</li>
</ul>
<p>用法：<br>postMessage(data,origin)方法接受两个参数，</p>
<p>data：需要传递的数据，html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。<br>origin：协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。</p>
<p><strong>（4）document.domain：只适合主域名相同，但子域名不同的iframe跨域</strong></p>
<p>实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p>
<p><strong>（5）window.name</strong>：<a href="https://www.cnblogs.com/zhuzhenwei918/p/7403796.html" target="_blank" rel="noopener">参考</a></p>
<p>只要是在同一窗口打开的，即使窗口的location发生的变化，window.name也不会改变，因此可以将跨域资源的数据以JSON.Stringfy的格式传入window.name，再将其location改为同源，即可获取数据</p>
<p><strong>（6）WebSocket协议跨域：websoket协议天然支持跨域</strong></p>
<p><strong>（7）Nginx代理跨域</strong></p>
<p>想一下，如果我们请求的时候还是用前端的域名，然后有个东西帮我们把这个请求转发到真正的后端域名上，不就避免跨域了吗？这时候，Nginx出场了。</p>
<blockquote>
<p>Nginx介绍：</p>
<p><strong>正向代理：</strong>正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；<strong>正向代理模式屏蔽或者隐藏了真实客户端信息</strong>。</p>
<p><strong>反向代理：</strong>主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息！</p>
<p><strong>负载均衡</strong></p>
</blockquote>
<p>例如<code>www.a.com/index.html</code>页面去调用<code>www.b.com/service.jsp</code>，可以通过写一个接口<code>www.a.com/service.jsp</code>,由这个接口在后端去调用<code>www.b.com/service.jsp</code>并取到返回值，然后再返回给index.html。</p>
<h4 id="11-从在浏览器输入url到页面显示经过的过程："><a href="#11-从在浏览器输入url到页面显示经过的过程：" class="headerlink" title="11.从在浏览器输入url到页面显示经过的过程："></a>11.从在浏览器输入url到页面显示经过的过程：</h4><p><a href="https://juejin.im/post/5cc573c85188252e741ccbb6" target="_blank" rel="noopener">参考</a></p>
<h4 id="12-浏览器页面渲染流程"><a href="#12-浏览器页面渲染流程" class="headerlink" title="12. 浏览器页面渲染流程"></a>12. 浏览器页面渲染流程</h4><p><a href="https://blog.csdn.net/qq_32657025/article/details/79569213" target="_blank" rel="noopener">参考原文</a></p>
<h5 id="12-1浏览器从HTTP服务器获取html文档，到呈现页面给用户，会经过以下几个步骤："><a href="#12-1浏览器从HTTP服务器获取html文档，到呈现页面给用户，会经过以下几个步骤：" class="headerlink" title="12.1浏览器从HTTP服务器获取html文档，到呈现页面给用户，会经过以下几个步骤："></a>12.1浏览器从HTTP服务器获取html文档，到呈现页面给用户，会经过以下几个步骤：</h5><p><strong>（1）解析文档构建DOM树</strong></p>
<p>浏览器的解析内容可以分为三个部分：</p>
<p>HTML/XHTML/SVG：解析这三种文件后，会生成DOM树（DOM Tree）<br>CSS：解析样式表，生成CSS规则树（CSS Rule Tree）<br>JavaScript：解析脚本，通过DOM API和CSSOM API操作DOM Tree和CSS Rule Tree，与用户进行交互。<br>以上三类文件的执行顺序会根据其在文档中的位置及其标签属性的不同而有异同，具体在后文进行讨论。</p>
<p><strong>（2）构建渲染树</strong><br>解析文档完成后，浏览器引擎会将 CSS Rule Tree 附着到DOM Tree 上，并根据DOM Tree 和 CSS Rule Tree构造 Rendering Tree（渲染树）。此处需要注意：</p>
<p>Render Tree和DOM Tree的区别在于，类似Head或display：node之类的东西不会放在渲染树中；<br>将CSS Rule Tree匹配到DOM Tree需要解析CSS的选择器，为了提高该过程的性能，DOM树应该尽量小，CSS Selector应该尽量使用id和class，避免过度层叠。<br><strong>（3）布局与绘制渲染树</strong><br>解析position, overflow, z-index等等属性，计算每一个渲染树节点的位置和大小，此过程被称为reflow。最后调用操作系统的Native GUI API完成绘制（repain）。注意：</p>
<p>渲染树的节点，在Gecko中称为frame，而在webkit中称为renderer；<br>reflow和repaint是两个不同的概念，其区别会在后文进行探讨。</p>
<h5 id="12-2-脚本和样式文件对页面渲染的影响："><a href="#12-2-脚本和样式文件对页面渲染的影响：" class="headerlink" title="12.2 脚本和样式文件对页面渲染的影响："></a>12.2 脚本和样式文件对页面渲染的影响：</h5><p>浏览器从服务器获取文档并从上到下进行解析，在脚本文件标签不包含defer和async属性的情况下，会按照如下规则执行文档内容：</p>
<p>（1）解析html文档，遇到HTML标签时，构建DOM树<br>（2）在构建DOM的过程中，如果遇到外联的样式声明或脚本声明，则暂停文档解析，创建新的网络连接，开始下载样式文件和脚本文件<br>（3）样式文件下载完成后，构建CSS Rule DOM，脚本文件下载完成后，解释并立即执行。<br>（4）构建DOM的同时，结合CSS规则树完成页面渲染。<br>（5）如果DOM树先于CSS规则树构建完成，则在CSS规则树构建完成后，页面会发生一次重绘，将新构建的CSS规则应用于渲染树。<br><strong>脚本文件对文档解析的影响：</strong><br>在这个过程中，脚本文件的下载和执行是与文档解析同步进行的，脚本文件的下载和执行都会阻塞文档的解析，如果控制得不好，在用户体验上就会造成一定程度的影响。<br><strong>脚本文件的defer和async属性</strong><br>为了防止脚本加载使浏览器页面阻塞，妨碍用户体验。应该合理使用<code>&lt;script&gt;</code>标签的defer属性和async属性。这两个属性用于调整脚本的下载和执行顺序，使其不阻塞页面加载。</p>
<p><strong>defer：开启新的线程下载脚本文件，并使脚本在文档解析完成后执行。</strong></p>
<p>（1）defer只适用于外联脚本，如果script标签没有指定src属性，只是内联脚本，不要使用defer<br>（2）如果有多个声明了defer的脚本，则会按顺序下载和执行<br>（3）defer脚本会在DOMContentLoaded和load事件之前执行</p>
<p><strong>async：异步下载脚本文件，下载完毕立即解释执行代码。 HTML5的新增属性。</strong></p>
<p>（1）只适用于外联脚本，这一点和defer一致<br>（2）如果有多个声明async的脚本，其下载和执行都是异步的，不能确保彼此的先后顺序<br>（3）async会在load事件之前执行，但并不能确保与DOMContentLoaded的执行先后顺序</p>
<p>下面这张图清楚的阐述了<code>&lt;script&gt;</code>脚本在无任何特殊属性、具有defer属性、具有async属性三种情况下的下载执行与文档解析的关系。其中绿色带包文档解析线程；蓝色代表脚本下载线程；红色代表脚本执行线程。</p>
<p><img src="/2020/03/17/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD.png" alt="文件加载"></p>
<p>综上所述，defer属性和async属性都能防止脚本下载阻塞页面渲染。如果脚本之间没有依赖关系，可以使用async属性，如果脚本之间有依赖关系，应使用defer属性。如果同时使用async和defer属性，后者不起作用，浏览器行为由async属性决定。如果不想使用这两个属性，也可将<code>&lt;script&gt;</code>标签防止在<code>&lt;/body&gt;</code>之前，达到同样的效果。</p>
<p><strong>CSS对页面渲染的影响：</strong><br>前端页面渲染时会根据DOM结构生成一个DOM树,然后加上CSS样式生成渲染树。如果CSS文件放在<code>&lt;head&gt;</code>标签中，则CSS Rule Tree会先于DOM树完成构建，之后浏览器就可以边构建DOM树边完成渲染；反之，CSS文件放在所有页面标签之后，比如<code>&lt;body/&gt;</code>之前，那么当DOM树构建完成了，渲染树才构建，浏览器不得不再重新渲染整个页面，这样造成了资源的浪费。而且页面还可能会出现闪跳的感觉，或者白屏或者布局混乱或者样式很丑，直到CSS加载完成，页面重绘才能恢复正常。<br>因此，一般来讲，css标签应放在标签之间。但如果css文件较大，会让首页白屏时间更长，所以并不是说把css都放顶部是一个完美的方法。权衡利弊，应该把必须的css（js）放顶部，把不那么重要的css（js）放底部.</p>
<h5 id="12-3-回流和重绘"><a href="#12-3-回流和重绘" class="headerlink" title="12.3 回流和重绘"></a>12.3 回流和重绘</h5><p><strong>reflow（回流）</strong><br>DOM结构中的各个元素都有自己的盒子模型，浏览器根据各样式计算元素的尺寸和位置，构建渲染树的过程称之为reflow。当渲染树节点的尺寸，布局，隐藏属性发生改变时，会触发reflow操作，重新构建Render Tree。每个页面在第一次加载的时候，会发生一次回流。<br>完成回流后，浏览器会重新绘制受影响的部分到屏幕中，因此，<strong>回流必定会导致重绘</strong>。</p>
<p><strong>repain（重绘）</strong><br>当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来后，浏览器便把这些元素都按照各自的特性进行绘制，于是页面的内容出现了，这个过程称之为repaint。</p>
<p><strong>会触发reflow的操作：</strong><br>Reflow 的成本比 Repaint 的成本高得多。DOM Tree 里的每个结点都会有 reflow 方法，一个结点的 reflow 很有可能导致子结点，甚至父点以及同级结点的 reflow。在一些高性能的电脑上也许还没什么，但是如果 reflow 发生在手机上，那么这个过程是非常痛苦和耗电的。所以，下面这些动作会触发reflow操作，有很大可能会是成本比较高的。</p>
<blockquote>
<p>增加、删除、修改 DOM 结点<br>移动 DOM 的位置<br>绘制动画<br>修改 CSS 样式<br>Resize 窗口的时候或是滚动<br>修改网页的默认字体<br>注：display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发现位置变化</p>
</blockquote>
<p><strong>如何能将Reflow对性能的影响减到最小呢？</strong></p>
<p>（1）不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className;<br>（2）把 DOM 离线后修改。如: 使用 documentFragment 对象在内存里操作 DOM； 先把 DOM 设置为 display:none (有一次 repaint)，然后你想怎么改就怎么改。比如修改 100 次，然后再把他显示出来；克隆一个DOM 节点到内存里，然后想怎么改就怎么改，改完后，和在线的进行交换。<br>（3）千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。</p>
<blockquote>
<p><strong>table标签的缺点：</strong></p>
</blockquote>
<h5 id="12-4-onload事件和DOMContentLoaded事件"><a href="#12-4-onload事件和DOMContentLoaded事件" class="headerlink" title="12.4 onload事件和DOMContentLoaded事件"></a>12.4 onload事件和DOMContentLoaded事件</h5><p>DOMContentLoaded事件是当初始HTML文档完全被加载和解析（即所有的DOM完全解析）时触发的，无需要等待样式表，图片，子框架完成加载。而onload事件要等页面所有元素，包括图片以及脚本等全部加载完成才触发，因此它比DOMContentLoaded要更晚执行。<br>在页面的图片很多，网络不好的情况下，从用户访问到onload触发可能需要很长的时间，此时如果在onload中加入许多初始化的动作, 必然会影响用户的体验。这事使用DOMContentLoaded事件代替onload事件是更合适的。</p>
<blockquote>
<p><strong>思考：我们为什么一再强调将css放在头部，将js文件放在尾部</strong></p>
<p>在面试的过程中，经常会有人在回答页面的优化中提到将js放到body标签底部，原因是因为浏览器生成Dom树的时候是一行一行读HTML代码的，script标签放在最后面就不会影响前面的页面的渲染。那么问题来了，既然Dom树完全生成好后页面才能渲染出来，浏览器又必须读完全部HTML才能生成完整的Dom树，script标签不放在body底部是不是也一样，因为dom树的生成需要整个文档解析完毕。</p>
<p>其实现代浏览器为了更好的用户体验,渲染引擎将尝试尽快在屏幕上显示的内容。它不会等到所有HTML解析之前开始构建和布局渲染树。部分的内容将被解析并显示。也就是说浏览器能够渲染不完整的dom树和cssom，尽快的减少白屏的时间。假如我们将js放在header，js将阻塞解析dom，dom的内容会影响到First Paint，导致First Paint延后。所以说我们会将js放在后面，以减少First Paint的时间，但是不会减少DOMContentLoaded被触发的时间。</p>
</blockquote>
<h5 id="12-5-如何优化图片的加载"><a href="#12-5-如何优化图片的加载" class="headerlink" title="12.5 如何优化图片的加载"></a>12.5 如何优化图片的加载</h5><p><strong>图片懒加载：</strong><a href="https://zhuanlan.zhihu.com/p/55311726" target="_blank" rel="noopener">参考</a></p>
<p><strong>原理：</strong></p>
<p>先将img标签的src链接设为同一张图片（比如空白图片），然后给img标签设置自定义属性（比如 data-src）,然后将真正的图片地址存储在data-src中，当JS监听到该图片元素进入可视窗口时，将自定义属性中的地址存储到src属性中。达到懒加载的效果。</p>
<p><strong>这样做能防止页面一次性向服务器发送大量请求，导致服务器响应慢，页面卡顿崩溃等。</strong></p>
<p>实现懒加载有四个步骤，如下：<br>1.加载loading图片<br>2.判断哪些图片要加载【重点】<br>3.隐形加载图片，先在内存中加载不显示<br>4.替换真图片</p>
<blockquote>
<p><strong>几个API函数</strong></p>
<p>页可见区域宽： document.body.clientWidth;<br>网页可见区域高： document.body.clientHeight;<br>网页可见区域宽： document.body.offsetWidth (包括边线的宽);<br>网页可见区域高： document.body.offsetHeight (包括边线的宽);<br>网页正文全文宽： document.body.scrollWidth;<br>网页正文全文高： document.body.scrollHeight;<br>网页被卷去的高： document.body.scrollTop;<br>网页被卷去的左： document.body.scrollLeft;<br>网页正文部分上： window.screenTop;<br>网页正文部分左： window.screenLeft;<br>屏幕分辨率的高： window.screen.height;<br>屏幕分辨率的宽： window.screen.width;<br>屏幕可用工作区高度： window.screen.availHeight</p>
</blockquote>
<p><img src="/2020/03/17/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD.jpg" alt="图片懒加载"></p>
<p><strong>第一种方法：</strong></p>
<p>使用：</p>
<p>element.offsetTop：距父元素的距离，循环直到页面顶端，获取图片和页面顶端的距离</p>
<p>document.documentElement.scrollTop||document.body.scrollTop:卷起的高度</p>
<p>document.documentElement.clientHeight:属于DOM：可视区域的高度（不包括包括水平滚动栏和工具栏的高度）</p>
<p>window.innerHeight:属于BOM：获得的是可视区域的高度，同时包括横向滚动条的高度。(IE8以及低版本浏览器不支持)</p>
<p>代码实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"ie=edge"</span>&gt;</span><br><span class="line">    &lt;title&gt;图片懒加载&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;style&gt;</span></span><br><span class="line"><span class="regexp">        img &#123;</span></span><br><span class="line"><span class="regexp">            display: block;</span></span><br><span class="line"><span class="regexp">            width: 100%;</span></span><br><span class="line"><span class="regexp">            height: 300px;</span></span><br><span class="line"><span class="regexp">            margin-bottom: 20px;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>style&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">    &lt;img data-src="./im</span>ages/<span class="number">1.</span>jpg<span class="string">" alt="</span><span class="string">"&gt;</span></span><br><span class="line"><span class="string">    &lt;img data-src="</span>./images/<span class="number">2.</span>jpg<span class="string">" alt="</span><span class="string">"&gt;</span></span><br><span class="line"><span class="string">    &lt;img data-src="</span>./images/<span class="number">3.</span>jpg<span class="string">" alt="</span><span class="string">"&gt;</span></span><br><span class="line"><span class="string">    &lt;img data-src="</span>./images/<span class="number">4.</span>jpg<span class="string">" alt="</span><span class="string">"&gt;</span></span><br><span class="line"><span class="string">    &lt;img data-src="</span>./images/<span class="number">5.</span>jpg<span class="string">" alt="</span><span class="string">"&gt;</span></span><br><span class="line"><span class="string">    &lt;img data-src="</span>./images/<span class="number">6.</span>jpg<span class="string">" alt="</span><span class="string">"&gt;</span></span><br><span class="line"><span class="string">    &lt;img data-src="</span>./images/<span class="number">7.</span>jpg<span class="string">" alt="</span><span class="string">"&gt;</span></span><br><span class="line"><span class="string">    &lt;img data-src="</span>./images/<span class="number">8.</span>jpg<span class="string">" alt="</span><span class="string">"&gt;</span></span><br><span class="line"><span class="string">    &lt;img data-src="</span>./images/<span class="number">9.</span>jpg<span class="string">" alt="</span><span class="string">"&gt;</span></span><br><span class="line"><span class="string">    &lt;img data-src="</span>./images/<span class="number">10.</span>jpg<span class="string">" alt="</span><span class="string">"&gt;</span></span><br><span class="line"><span class="string">    &lt;img data-src="</span>./images/<span class="number">1.</span>jpg<span class="string">" alt="</span><span class="string">"&gt;</span></span><br><span class="line"><span class="string">    &lt;img data-src="</span>./images/<span class="number">2.</span>jpg<span class="string">" alt="</span><span class="string">"&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">    var imgs = document.querySelectorAll('img');</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    //offsetTop是元素与offsetParent的距离，循环获取直到页面顶部</span></span><br><span class="line"><span class="string">    function getTop(e) &#123;</span></span><br><span class="line"><span class="string">    var T = e.offsetTop;</span></span><br><span class="line"><span class="string">    while(e = e.offsetParent) &#123;</span></span><br><span class="line"><span class="string">    T += e.offsetTop;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return T;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    function lazyLoad(imgs) &#123;</span></span><br><span class="line"><span class="string">    var H = document.documentElement.clientHeight;//获取可视区域高度</span></span><br><span class="line"><span class="string">    var S = document.documentElement.scrollTop || document.body.scrollTop;</span></span><br><span class="line"><span class="string">    for (var i = 0; i &lt; imgs.length; i++) &#123;</span></span><br><span class="line"><span class="string">    if (H + S &gt; getTop(imgs[i])) &#123;</span></span><br><span class="line"><span class="string">    imgs[i].src = imgs[i].getAttribute('data-src');</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    window.onload = window.onscroll = function () &#123; //onscroll()在滚动条滚动的时候触发</span></span><br><span class="line"><span class="string">    lazyLoad(imgs);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>第二种方法：</strong>使用API</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getBoundingClientRect()<span class="comment">//获取元素的大小及位置，返回值是一个DOMRect对象</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/17/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/getBoundingClientRect.jpg" alt="getBoundingClientRect"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bound = el.getBoundingClientRect();</span><br><span class="line"><span class="keyword">var</span> clientHeight = <span class="built_in">window</span>.innerHeight;<span class="comment">//这个和前面获取可视区高度的效果一样，只是兼容性问题</span></span><br><span class="line">bound.top&lt;=clientHeight<span class="comment">//图片在可视区域内</span></span><br></pre></td></tr></table></figure>

<p>完整代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> imgs = <span class="built_in">document</span>.querySelectorAll(<span class="string">'img'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//用来判断bound.top&lt;=clientHeight的函数，返回一个bool值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIn</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bound = el.getBoundingClientRect();</span><br><span class="line">    <span class="keyword">var</span> clientHeight = <span class="built_in">window</span>.innerHeight;</span><br><span class="line">    <span class="keyword">return</span> bound.top &lt;= clientHeight;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//检查图片是否在可视区内，如果不在，则加载</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Array</span>.from(imgs).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">el</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isIn(el))&#123;</span><br><span class="line">            loadImg(el);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImg</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!el.src)&#123;</span><br><span class="line">        <span class="keyword">var</span> source = el.dataset.src;</span><br><span class="line">        el.src = source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onload = <span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//onscroll()在滚动条滚动的时候触发</span></span><br><span class="line">    check();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="13-web缓存："><a href="#13-web缓存：" class="headerlink" title="13. web缓存："></a>13. web缓存：</h4><p><a href="https://www.cnblogs.com/liluxiang/p/9377539.html" target="_blank" rel="noopener">参考：</a></p>
<h5 id="13-1-宏观上，缓存可以分为私有缓存和共享缓存："><a href="#13-1-宏观上，缓存可以分为私有缓存和共享缓存：" class="headerlink" title="13.1 宏观上，缓存可以分为私有缓存和共享缓存："></a>13.1 宏观上，缓存可以分为私有缓存和共享缓存：</h5><p>共享缓存：能被各级代理缓存的缓存</p>
<p>私有缓存：用户专享的，各级代理不能缓存的缓存</p>
<h5 id="13-2-微观上，缓存可以分为四类："><a href="#13-2-微观上，缓存可以分为四类：" class="headerlink" title="13.2 微观上，缓存可以分为四类："></a>13.2 微观上，缓存可以分为四类：</h5><p><strong>13.2.1 浏览器缓存</strong></p>
<p><strong>13.2.2 代理服务器缓存</strong></p>
<p><strong>13.2.3 网关缓存</strong></p>
<p><strong>13.2.4 数据库缓存</strong></p>
<h4 id="14-http1-0，1-1，2-0"><a href="#14-http1-0，1-1，2-0" class="headerlink" title="14. http1.0，1.1，2.0"></a>14. http1.0，1.1，2.0</h4><h5 id="14-1-http1-0和http1-1"><a href="#14-1-http1-0和http1-1" class="headerlink" title="14.1 http1.0和http1.1:"></a>14.1 http1.0和http1.1:</h5><p><strong>14.1.1 http1.0和http1.1的一些区别：</strong></p>
<p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p>
<p><strong>（1）缓存处理</strong>，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</p>
<p><strong>（2）带宽优化及网络连接的使用</strong>，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p>
<p><strong>（3）错误通知的管理</strong>，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p>
<p><strong>（4）Host头处理</strong>，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p>
<p><strong>（5）长连接</strong>，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p>
<h5 id="14-1-2-HTTP1-X的缺点："><a href="#14-1-2-HTTP1-X的缺点：" class="headerlink" title="14.1.2 HTTP1.X的缺点："></a>14.1.2 HTTP1.X的缺点：</h5><p>（1）HTTP/1.0一次只允许在一个TCP连接上发起一个请求，HTTP/1.1使用的流水线技术也只能部分处理请求并发，仍然会存在队列头阻塞问题，因此客户端在需要发起多次请求时，通常会采用建立多连接来减少延迟。</p>
<p>（2）单向请求，只能由客户端发起。</p>
<p>（3）请求报文与响应报文首部信息冗余量大。</p>
<p>（4）数据未压缩，导致数据的传输量大。</p>
<h5 id="14-2-http2-0"><a href="#14-2-http2-0" class="headerlink" title="14.2 http2.0"></a>14.2 http2.0</h5><p>以以下协议为基础：</p>
<blockquote>
<p>SPDY:</p>
<p>HTTP Speed + Mobility：用于改善并提高移动端通信时的通信速度和性能</p>
<p>Network-Friendly HTTP Upgrade：在移动端通信时改善HTTP性能</p>
</blockquote>
<p>HTTP/2.0 的7项技术和讨论</p>
<p><img src="http2.png" alt="http2"></p>
<h5 id="14-2-1-什么是http2-0"><a href="#14-2-1-什么是http2-0" class="headerlink" title="14.2.1 什么是http2.0?"></a>14.2.1 什么是http2.0?</h5><p>主要基于SPDY，在不改动HTTP语义，方法，状态码及首部字段的情况下，大幅度提高了web性能</p>
<blockquote>
<p><strong>什么是SPDY协议？</strong></p>
<p>SPDY是Speedy的谐音，意为“更快”。它是Google开发的基于TCP协议的<strong>应用层协议</strong>。目标是<strong>优化HTTP协议的性能，通过压缩、多路复用和优先级等技术，缩短网页的加载时间并提高安全性</strong>。SPDY协议的<strong>核心思想是尽量减少TCP连接数。</strong>SPDY并不是一种用于替代HTTP的协议，而是<strong>对HTTP协议的增强</strong>。</p>
<p><strong>HTTP2.0和SPDY的区别</strong></p>
<ol>
<li>HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS</li>
<li>HTTP2.0 消息头的压缩算法采用 <strong>HPACK</strong>，而非 SPDY 采用的 <strong>DEFLATE</strong></li>
</ol>
</blockquote>
<h5 id="14-2-2-HTTP2-0-特点"><a href="#14-2-2-HTTP2-0-特点" class="headerlink" title="14.2.2 HTTP2.0 特点"></a>14.2.2 HTTP2.0 特点</h5><p><strong>（1）二进制传输</strong></p>
<p>HTTP2.0中所有加强性能的核心是二进制传输，在HTTP1.x中，我们是通过文本的方式传输数据。基于文本的方式传输数据存在很多缺陷，文本的表现形式有多样性，因此要做到健壮性考虑的场景必然有很多，但是二进制则不同，只有0和1的组合，因此选择了二进制传输，实现方便且健壮。<br>在HTTP2.0中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。</p>
<p><img src="/2020/03/17/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%A2%9E%E5%8A%A0%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B1%82.png" alt="增加二进制层"></p>
<p>为了保证HTTP不受影响，那就需要在应用层（HTTP2.0）和传输层（TCP or UDP）之间增加一个二进制分帧层。在二进制分帧层上，HTTP2.0会将所有传输的信息分为更小的消息和帧，并采用二进制格式编码，其中HTTP1.x的首部信息会被封装到Headers帧，而Request Body则封装到Data帧。</p>
<p><strong>（2）多路复用</strong></p>
<p>在HTTP1.0中，我们经常会使用到雪碧图、使用多个域名等方式来进行优化，都是因为浏览器限制了同一个域名下的请求数量，当页面需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求时，资源需要等待其他资源请求完成后才能继续发送。<br>HTTP2.0中，有两个概念非常重要：帧（frame）和流（stream）。<br>帧是最小的数据单位，每个帧会标识出该帧属于哪个流，流是多个帧组成的数据流。<br>所谓多路复用，即在一个TCP连接中存在多个流，即可以同时发送多个请求，对端可以通过帧中的表示知道该帧属于哪个请求。在客户端，这些帧乱序发送，到对端后再根据每个帧首部的流标识符重新组装。通过该技术，可以避免HTTP旧版本的队头阻塞问题，极大提高传输性能。</p>
<p><strong>（3）请求优先级</strong>（request prioritization）</p>
<p>多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。</p>
<p><strong>（4）Header压缩</strong></p>
<p>在HTTP1.0中，我们使用文本的形式传输header，在header中携带cookie的话，每次都需要重复传输几百到几千的字节，这着实是一笔不小的开销。<br>在HTTP2.0中，我们使用了HPACK（HTTP2头部压缩算法）压缩格式对传输的header进行编码，减少了header的大小。并在两端维护了索引表，用于记录出现过的header，后面在传输过程中就可以传输已经记录过的header的键名，对端收到数据后就可以通过键名找到对应的值。</p>
<p><strong>（5）服务器Push</strong></p>
<p>在HTTP2.0中，服务端可以在客户端某个请求后，主动推送其他资源。<br>可以想象一下，某些资源客户端是一定会请求的，这时就可以采取服务端push的技术，提前给客户端推送必要的资源，就可以相对减少一点延迟时间。在浏览器兼容的情况下也可以使用prefetch。</p>
<p><strong>（6）更安全</strong></p>
<p>HTTP2.0使用了tls的拓展ALPN做为协议升级，除此之外，HTTP2.0对tls的安全性做了近一步加强，通过黑名单机制禁用了几百种不再安全的加密算法。</p>
<h5 id="14-2-4-额外补充：QUIC"><a href="#14-2-4-额外补充：QUIC" class="headerlink" title="14.2.4 额外补充：QUIC"></a>14.2.4 额外补充：QUIC</h5><p>这里额外给大家介绍一个协议，是由Google基于UDP实现的同为传输层的协议，目标是希望替代TCP协议。<br>该协议支持多路复用，虽然说HTTP2.0也支持多路复用，但是下层仍然是TCP，因为TCP的重传机制，只要一个包丢失就得判断丢包并且重传，导致发生队头阻塞的问题，但是UDP没有这个限制。除此之外，它还有如下特点：</p>
<p>（1）实现了自己的加密协议，通过类似TCP的TFO机制实现0-RTT，当然TLS1.3已经实现了0-RTT。</p>
<p>（2）支持重传和纠错机制，在只丢失一个包的情况下不需要重传，使用纠错机制恢复丢失的包。</p>
<ul>
<li>纠错机制：通过异或的方式，算出发出去的数据的异或值并单独发出一个包，服务端在发现有一个包丢失的情况下，通过其他数据包的异或值包算出丢失包。</li>
<li>在丢失两个包及以上的情况就是用重传机制，因为算不出来了。</li>
</ul>
<h5 id="14-3-附注："><a href="#14-3-附注：" class="headerlink" title="14.3 附注："></a>14.3 附注：</h5><p><strong>14.3.1 HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？</strong></p>
<ul>
<li>HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；</li>
<li>HTTP/1.1 Pipeling（流水线）解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；</li>
<li>HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行，如下图；<img src="/2020/03/17/%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%92%8C%E6%B5%81%E6%B0%B4%E7%BA%BF.jpg" alt="多路复用和流水线"></li>
</ul>
<h4 id="15-浏览器内核"><a href="#15-浏览器内核" class="headerlink" title="15. 浏览器内核"></a>15. 浏览器内核</h4><p>浏览器最重要的部分是浏览器的内核。浏览器内核是浏览器的核心，也称“渲染引擎”，用来解释网页语法并渲染到网页上。浏览器内核决定了浏览器该如何显示网页内容以及页面的格式信息。不同的浏览器内核对网页的语法解释也不同，因此网页开发者需要在不同内核的浏览器中测试网页的渲染效果。</p>
<p>浏览器内核又可以分为两部分：渲染引擎和JS引擎（随着JS引擎越来越独立，内核就倾向于只指渲染引擎）<strong>常见的浏览器内核可以分为四种：Trident,Gecko,Blink,Webkit</strong></p>
<p>（1）IE浏览器内核：Trident内核，也是俗称的IE内核；<br>（2）Chrome浏览器内核：统称为Chromium内核或Chrome内核，以前是Webkit内核，现在是Blink内核；<br>（3）Firefox浏览器内核：Gecko内核，俗称Firefox内核；<br>（4）Safari浏览器内核：Webkit内核；<br>（5）Opera浏览器内核：最初是自己的Presto内核，后来是Webkit，现在是Blink内核；<br>（6）360浏览器、猎豹浏览器内核：IE+Chrome双内核；<br>（7）搜狗、遨游、QQ浏览器内核：Trident（兼容模式）+Webkit（高速模式）；<br>（8）百度浏览器、世界之窗内核：IE内核；<br>（9）2345浏览器内核：以前是IE内核，现在也是IE+Chrome双内核；</p>
<h4 id="16-Cookie和session的区别"><a href="#16-Cookie和session的区别" class="headerlink" title="16. Cookie和session的区别"></a>16. Cookie和session的区别</h4><h4 id="17-Cookie如何防范XSS攻击？"><a href="#17-Cookie如何防范XSS攻击？" class="headerlink" title="17. Cookie如何防范XSS攻击？"></a>17. Cookie如何防范XSS攻击？</h4>]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
